<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="../../genindex.html" /><link rel="search" title="搜索" href="../../search.html" /><link rel="next" title="相机抖动抗锯齿教程" href="extensions/JitterCamera.html" /><link rel="prev" title="光线追踪" href="../Vulkan-GuideRayTracing.html" />
        <link rel="canonical" href="https://github.com/FuXiii/Essentials.of.Vulkan/Literature/NVIDIAVulkanRayTracingTutorial/NVIDIAVulkanRayTracingTutorial.html" />

    <link rel="shortcut icon" href="../../_static/VulkanLogo.png"/><!-- Generated with Sphinx 7.2.5 and Furo 2023.08.19 -->
        <title>NVIDIA Vulkan 光线追踪教程 - Vulkan入门精要</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b20cc3f5" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Vulkan入门精要</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
<div class="sidebar-sticky" ><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../_static/Vulkan.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Vulkan入门精要</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">入门精要</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../StartFromVulkanSDK.html">开始于 Vulkan SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Overview.html">纵览</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">文献翻译</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../index.html">文献</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 文献</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../VulkanRayTracingFinalSpecificationRelease.html">Vulkan 光线追踪最终标准发布</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Vulkan-GuideRayTracing.html">光线追踪</a></li>
<li class="toctree-l2 current has-children current-page"><a class="current reference internal" href="#">NVIDIA Vulkan 光线追踪教程</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of NVIDIA Vulkan 光线追踪教程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="extensions/JitterCamera.html">相机抖动抗锯齿教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/AnyHitShaders.html">任意命中着色器（Any Hit Shaders）教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/Instances.html">实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="extensions/Reflections.html">反射</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../vk_mini_path_tracer.html">Vulkan迷你路径追踪</a></li>
<li class="toctree-l2"><a class="reference internal" href="../TheRTXShaderBindingTableThreeWays.html">RTX 着色器绑定表的三种方式</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">随笔</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../InformalEssay/index.html">Vulkan 标准</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Vulkan 标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../InformalEssay/VulkanKHRRayTracing/VulkanKHRRayTracing.html">Vulkan KHR 光线追踪标准</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Vulkan KHR 光线追踪标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../InformalEssay/VulkanKHRRayTracing/VK_KHR_acceleration_structure.html">VK_KHR_acceleration_structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../InformalEssay/VulkanKHRRayTracing/VK_KHR_ray_tracing_pipeline.html">VK_KHR_ray_tracing_pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../InformalEssay/VulkanKHRRayTracing/VK_KHR_deferred_host_operations.html">VK_KHR_deferred_host_operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../InformalEssay/VK_KHR_buffer_device_address.html">VK_KHR_buffer_device_address</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">工程应用</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Application/index.html">应用</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 应用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Application/VolumetricCloud.html">体积云</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Application/WebGPUImGui.html">WebGPU ImGui</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Application/WebGPUHelloTriangle.html">WebGPU Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Application/WebGPUShaderCompiler.html">WebGPU Shader Compiler</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">更新日志</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Changelog.html">更新日志</a></li>
</ul>

</div>
</div>

</div>

    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/FuXiii/Essentials.of.Vulkan/edit/main/source/Literature/NVIDIAVulkanRayTracingTutorial/NVIDIAVulkanRayTracingTutorial.rst" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="nvidia-vulkan">
<h1>NVIDIA Vulkan 光线追踪教程<a class="headerlink" href="#nvidia-vulkan" title="Link to this heading">#</a></h1>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header sd-bg-muted sd-bg-text-muted">
<span class="sd-summary-icon"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-history" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M1.643 3.143L.427 1.927A.25.25 0 000 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 00.177-.427L2.715 4.215a6.5 6.5 0 11-1.18 4.458.75.75 0 10-1.493.154 8.001 8.001 0 101.6-5.684zM7.75 4a.75.75 0 01.75.75v2.992l2.028.812a.75.75 0 01-.557 1.392l-2.5-1A.75.75 0 017 8.25v-3.5A.75.75 0 017.75 4z"></path></svg></span>更新记录<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<ul class="simple">
<li><p class="sd-card-text">2023/5/15 创建本文</p></li>
<li><p class="sd-card-text">2023/5/15 增加 <code class="docutils literal notranslate"><span class="pre">介绍</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/15 增加 <code class="docutils literal notranslate"><span class="pre">配置环境</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/15 增加 <code class="docutils literal notranslate"><span class="pre">生成解决方案</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/17 增加 <code class="docutils literal notranslate"><span class="pre">生成解决方案</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/17 增加 <code class="docutils literal notranslate"><span class="pre">编译和运行</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/17 增加 <code class="docutils literal notranslate"><span class="pre">开始步入光线追踪</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/18 更新 <code class="docutils literal notranslate"><span class="pre">开始步入光线追踪</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/18 增加 <code class="docutils literal notranslate"><span class="pre">加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/20 更新 <code class="docutils literal notranslate"><span class="pre">加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/20 增加 <code class="docutils literal notranslate"><span class="pre">底层加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/20 增加 <code class="docutils literal notranslate"><span class="pre">帮助类细节：RaytracingBuilder::buildBlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/21 更新 <code class="docutils literal notranslate"><span class="pre">帮助类细节：RaytracingBuilder::buildBlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/22 更新 <code class="docutils literal notranslate"><span class="pre">帮助类细节：RaytracingBuilder::buildBlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/22 增加 <code class="docutils literal notranslate"><span class="pre">cmdCreateBlas</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/22 增加章节号</p></li>
<li><p class="sd-card-text">2023/5/23 更新 <code class="docutils literal notranslate"><span class="pre">5.1</span> <span class="pre">底层加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/23 更新 <code class="docutils literal notranslate"><span class="pre">5.1.1</span> <span class="pre">帮助类细节：RaytracingBuilder::buildBlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/23 更新 <code class="docutils literal notranslate"><span class="pre">5.1.1.1</span> <span class="pre">cmdCreateBlas</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/23 增加 <code class="docutils literal notranslate"><span class="pre">5.1.1.2</span> <span class="pre">cmdCompactBlas</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/24 更新 <code class="docutils literal notranslate"><span class="pre">5.1.1.2</span> <span class="pre">cmdCompactBlas</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/24 更新 <code class="docutils literal notranslate"><span class="pre">5.1.1</span> <span class="pre">帮助类细节：RaytracingBuilder::buildBlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/24 增加 <code class="docutils literal notranslate"><span class="pre">5.2</span> <span class="pre">顶层加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/24 更新 <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/25 更新 <code class="docutils literal notranslate"><span class="pre">5.2</span> <span class="pre">顶层加速结构</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/25 增加 <code class="docutils literal notranslate"><span class="pre">5.2.1</span> <span class="pre">帮助类细节：RaytracingBuilder::buildTlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/26 更新 <code class="docutils literal notranslate"><span class="pre">5.2.1</span> <span class="pre">帮助类细节：RaytracingBuilder::buildTlas()</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/26 增加 <code class="docutils literal notranslate"><span class="pre">5.3</span> <span class="pre">main</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/26 增加 <code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">光线追踪描述符集（Descriptor</span> <span class="pre">Set）</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/26 增加 <code class="docutils literal notranslate"><span class="pre">6.1</span> <span class="pre">增加场景的描述符集</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/27 更新 <code class="docutils literal notranslate"><span class="pre">6.1</span> <span class="pre">增加场景的描述符集</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/27 增加 <code class="docutils literal notranslate"><span class="pre">6.2</span> <span class="pre">描述符更新</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/27 增加 <code class="docutils literal notranslate"><span class="pre">6.3</span> <span class="pre">main</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/27 增加 <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">光线追踪管线</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/28 更新 <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">光线追踪管线</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/28 增加 <code class="docutils literal notranslate"><span class="pre">7.1</span> <span class="pre">增加着色器</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/29 更新 <code class="docutils literal notranslate"><span class="pre">7.1</span> <span class="pre">增加着色器</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/30 更新 <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">光线追踪管线</span></code> 章节，增加任意命中着色器中 <code class="docutils literal notranslate"><span class="pre">候选交点</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/5/30 更新 <code class="docutils literal notranslate"><span class="pre">7.1</span> <span class="pre">增加着色器</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/30 增加 <code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">着色器绑定表</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/31 更新 <code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">着色器绑定表</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/5/31 增加 <code class="docutils literal notranslate"><span class="pre">8.1</span> <span class="pre">句柄</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/1 更新 <code class="docutils literal notranslate"><span class="pre">5.1.1</span> <span class="pre">帮助类细节：RaytracingBuilder::buildBlas()</span></code> 章节，修改 <code class="docutils literal notranslate"><span class="pre">我们将底层加速结构分割并使用多个大约</span> <span class="pre">256MB</span> <span class="pre">的内存块创建</span></code></p></li>
<li><p class="sd-card-text">2023/6/1 更新 <code class="docutils literal notranslate"><span class="pre">8.1</span> <span class="pre">句柄</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/2 更新 <code class="docutils literal notranslate"><span class="pre">8.1</span> <span class="pre">句柄</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/2 增加 <code class="docutils literal notranslate"><span class="pre">8.2</span> <span class="pre">main</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/2 增加 <code class="docutils literal notranslate"><span class="pre">9</span> <span class="pre">光线追踪</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/2 增加 <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">开始追踪</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/2 增加 <code class="docutils literal notranslate"><span class="pre">10.1</span> <span class="pre">main</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/3 增加 <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">相机矩阵</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/3 增加 <code class="docutils literal notranslate"><span class="pre">11.1</span> <span class="pre">光线生成（raytrace.rgen）</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/3 增加 <code class="docutils literal notranslate"><span class="pre">11.2</span> <span class="pre">未命中着色器（raytrace.miss）</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/3 增加 <code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">简单光照</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 更新 <code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">简单光照</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">12.1</span> <span class="pre">最近命中着色器（raytrace.rchit）</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">13</span> <span class="pre">简单材质</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">13.1</span> <span class="pre">raytrace.rchit</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">13.2</span> <span class="pre">main</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">14</span> <span class="pre">阴影</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">14.1</span> <span class="pre">createRaytracingPipeline</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">14.2</span> <span class="pre">createRtShaderBindingTable</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">14.3</span> <span class="pre">createRtDescriptorSet</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">14.4</span> <span class="pre">raytrace.rchit</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 增加 <code class="docutils literal notranslate"><span class="pre">15</span> <span class="pre">拓展延伸</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/4 初步翻译完成</p></li>
<li><p class="sd-card-text">2023/8/23 提供 <code class="docutils literal notranslate"><span class="pre">Turbo</span></code> 实现开源示例</p></li>
<li><p class="sd-card-text">2023/8/24 增加 <code class="docutils literal notranslate"><span class="pre">任意命中着色器（Any</span> <span class="pre">Hit</span> <span class="pre">Shaders）教程</span></code> 扩展文档</p></li>
<li><p class="sd-card-text">2023/8/24 增加 <code class="docutils literal notranslate"><span class="pre">相机抖动抗锯齿教程</span></code> 扩展文档</p></li>
<li><p class="sd-card-text">2023/9/1 增加 <code class="docutils literal notranslate"><span class="pre">实例化</span></code> 文档链接</p></li>
<li><p class="sd-card-text">2023/9/7 增加 <code class="docutils literal notranslate"><span class="pre">反射</span></code> 文档链接</p></li>
</ul>
</div>
</details><p><a class="reference external" href="https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/">文献源</a></p>
<div class="note admonition">
<p class="admonition-title">Turbo 引擎中对该教程的实现示例</p>
<p><code class="docutils literal notranslate"><span class="pre">Turbo</span></code> 引擎对该教程进行了实现，具体如下：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/FuXiii/Turbo/blob/master/samples/VulkanKHRRayTracingTest.cpp">VulkanKHRRayTracingTest</a> ：提供光栅化和实时光追两种渲染方式切换。 <a class="reference external" href="https://www.bilibili.com/video/BV1Wu411779G/?spm_id_from=333.999.0.0">示例视频</a></p></li>
<li><p><a class="reference external" href="https://github.com/FuXiii/Turbo/blob/master/samples/VulkanKHRRayTracingTestForLighting.cpp">VulkanKHRRayTracingTestForLighting</a> ：提供实时光追的 <code class="docutils literal notranslate"><span class="pre">Phong</span></code> 光照模型渲染。 <a class="reference external" href="https://www.bilibili.com/video/BV1rm4y1H7EE/?spm_id_from=333.999.0.0">示例视频</a></p></li>
<li><p><a class="reference external" href="https://github.com/FuXiii/Turbo/blob/master/samples/VulkanKHRRayTracingTestForLightingShadow.cpp">VulkanKHRRayTracingTestForLightingShadow</a> ：提供实时光追光照中的阴影渲染。 <a class="reference external" href="https://www.bilibili.com/video/BV1gu4y1i7Kx/?spm_id_from=333.999.0.0">示例视频</a></p></li>
<li><p><a class="reference external" href="https://github.com/FuXiii/Turbo/blob/master/samples/VulkanKHRRayTracingTestForLightingShadowWithTexture.cpp">VulkanKHRRayTracingTestForLightingShadowWithTexture</a> ：提供实时光追光照中的纹理采样。 <a class="reference external" href="https://www.bilibili.com/video/BV1qu41177B9/?spm_id_from=333.999.0.0">示例视频</a></p></li>
</ul>
</div>
<p>本文所提供的的代码和文档聚焦于使用 <a class="reference external" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_ray_tracing_pipeline">VK_KHR_ray_tracing_pipeline</a> 扩展展示一个基础光追示例。
该教程从一个基于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 开发的基础程序开始，并且提供一步步的介绍去修改和增加函数和功能。</p>
<figure class="align-default" id="id41">
<img alt="../../_images/resultRaytraceShadowMedieval.png" src="../../_images/resultRaytraceShadowMedieval.png" />
<figcaption>
<p><span class="caption-text">最终结果</span><a class="headerlink" href="#id41" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="note admonition">
<p class="admonition-title">GitHub仓库</p>
<p><a class="reference external" href="https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR">https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR</a></p>
</div>
<section id="id6">
<h2>1 介绍<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>本教程重点介绍将光线跟踪添加到现有 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 应用中的步骤，并假设您对 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 有一定的了解。
对于像交换链管理、 <code class="docutils literal notranslate"><span class="pre">Render</span> <span class="pre">Pass</span></code> 等常见的组件已经封装在了 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/tree/master/nvvk">C++ API helpers</a> 和
英伟达的 <a class="reference external" href="https://github.com/nvpro-samples/build_all">nvpro-samples</a> 框架中。这个框架包含很多高级示例，对于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 和 <code class="docutils literal notranslate"><span class="pre">OpenGL</span></code> 最佳实践也在其中。
我们同时使用一个助手去生成光追的加速结构，我们会在本文中对其进行详细说明。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>出于教育的目的，所有的代码都在分散一些很小的文件中。要将这些结合起来需要额外的抽象层级。</p>
</div>
</section>
<section id="environment-setup">
<span id="id7"></span><h2>2 配置环境<a class="headerlink" href="#environment-setup" title="Link to this heading">#</a></h2>
<p>推荐的方式是通过 <code class="docutils literal notranslate"><span class="pre">nvpro-samples</span></code> 的 <code class="docutils literal notranslate"><span class="pre">build_all</span></code> 脚本去下载包括 <code class="docutils literal notranslate"><span class="pre">NVVK</span></code> 在内的工程。</p>
<p>在命令行中，从 <a class="reference external" href="https://github.com/nvpro-samples/build_all">https://github.com/nvpro-samples/build_all</a> 中克隆 <code class="docutils literal notranslate"><span class="pre">nvpro-samples/build_all</span></code> 仓库：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">nvpro</span><span class="o">-</span><span class="n">samples</span><span class="o">/</span><span class="n">build_all</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>之后打开 <code class="docutils literal notranslate"><span class="pre">build_all</span></code> 文件夹并执行 <code class="docutils literal notranslate"><span class="pre">clone_all.bat</span></code> ( <code class="docutils literal notranslate"><span class="pre">Windows</span></code> ) 或 <code class="docutils literal notranslate"><span class="pre">clone_all.sh</span></code> ( <code class="docutils literal notranslate"><span class="pre">Linux</span></code> )。</p>
<p>如果你希望克隆尽可能少的仓库，打开命令行，并执行如下指令，这将只克隆需要的仓库：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="o">--</span><span class="n">recursive</span> <span class="o">--</span><span class="n">shallow</span><span class="o">-</span><span class="n">submodules</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">nvpro</span><span class="o">-</span><span class="n">samples</span><span class="o">/</span><span class="n">nvpro_core</span><span class="o">.</span><span class="n">git</span>
<span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">nvpro</span><span class="o">-</span><span class="n">samples</span><span class="o">/</span><span class="n">vk_raytracing_tutorial_KHR</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<section id="id8">
<h3>2.1 生成解决方案<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>对于存储构建生成的解决方案，最经典的是在工程主目录下创建一个 <code class="docutils literal notranslate"><span class="pre">build</span></code> 文件夹。您可以是使用 <code class="docutils literal notranslate"><span class="pre">CMake-GUI</span></code> 或者如下指令生成目标工程：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">vk_raytracing_tutorial_KHR</span>
<span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="n">cmake</span> <span class="o">..</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果您没有使用 <code class="docutils literal notranslate"><span class="pre">Visual</span> <span class="pre">Studio</span> <span class="pre">2019</span></code> 或者更高版本，请确保 <code class="docutils literal notranslate"><span class="pre">Visual</span> <span class="pre">Studio</span></code> 中目标平台选择的是 <code class="docutils literal notranslate"><span class="pre">x64</span></code> 平台。
对于 <code class="docutils literal notranslate"><span class="pre">Visual</span> <span class="pre">Studio</span> <span class="pre">2019</span></code> 来说默认是 <code class="docutils literal notranslate"><span class="pre">x64</span></code> 平台，但老版本就不一定了。</p>
</div>
</section>
<section id="id9">
<h3>2.2 工具安装<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>我们需要一张支持 <code class="docutils literal notranslate"><span class="pre">VK_KHR_ray_tracing_pipeline</span></code> 扩展的显卡。对于英伟达的图形卡，您需要最起码是 <code class="docutils literal notranslate"><span class="pre">2021年</span></code> 或之后的 <a class="reference external" href="https://developer.nvidia.com/vulkan-driver">Vulkan驱动</a> 。</p>
<p>该工程最低需要 <a class="reference external" href="https://vulkan.lunarg.com/sdk/home">Vulkan SDK</a> 的版本为 <code class="docutils literal notranslate"><span class="pre">1.2.161</span></code>。该工程是使用 <code class="docutils literal notranslate"><span class="pre">1.2.182.0</span></code> 进行测试的。</p>
</section>
</section>
<section id="id10">
<h2>3 编译和运行<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>打开位于 <code class="docutils literal notranslate"><span class="pre">build</span></code> 目录下的解决方案，之后编译并运行 <a class="reference external" href="https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR/tree/master/ray_tracing__before">vk_ray_tracing__before_KHR</a> 。</p>
<p>该示例将会是此教程的示例起点。这是一个用于加载 <code class="docutils literal notranslate"><span class="pre">OBJ</span></code> 文件并使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 光栅化渲染他们的小框架。您可以通过阅读 <a class="reference external" href="https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR/blob/master/ray_tracing__before/README.md#nvidia-vulkan-ray-tracing-tutorial">Base Overview</a> 来纵观该示例是如何实现的。
我们将使用这个框架加载几何体并且渲染场景来实现光线追踪。</p>
<figure class="align-default" id="id42">
<img alt="../../_images/resultRasterCube.png" src="../../_images/resultRasterCube.png" />
<figcaption>
<p><span class="caption-text">首次执行</span><a class="headerlink" href="#id42" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>接下来的步骤将是修改 <code class="docutils literal notranslate"><span class="pre">vk_ray_tracing__before_KHR</span></code> 使其支持光线追踪。该教程修改后的最终结果将是同 <code class="docutils literal notranslate"><span class="pre">vk_ray_tracing__simple_KHR</span></code> 一样。如果开发过程发生错误
可以看看该工程。</p>
<p><code class="docutils literal notranslate"><span class="pre">vk_ray_tracing__simple_KHR</span></code> 工程将会作为额外教程的起点进行开发讲解。</p>
</section>
<section id="id11">
<h2>4 开始步入光线追踪<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
<p>首先进入 <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> 文件的 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数，找到使用 <code class="docutils literal notranslate"><span class="pre">nvvk::ContextCreateInfo</span></code> 设置需要的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 扩展。为了激活使用光线追踪，我们需要 <code class="docutils literal notranslate"><span class="pre">VK_KHR_ACCELERATION_STRUCTURE</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_KHR_RAY_TRACING_PIPELINE</span></code> 两个扩展。这两个扩展
还依赖于其他扩展，如下是所有需要激活的扩展。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// #VKRay: 激活光线追踪扩展</span>
<span class="n">VkPhysicalDeviceAccelerationStructureFeaturesKHR</span><span class="w"> </span><span class="n">accelFeature</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR</span><span class="p">};</span>
<span class="n">contextInfo</span><span class="p">.</span><span class="n">addDeviceExtension</span><span class="p">(</span><span class="n">VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">accelFeature</span><span class="p">);</span><span class="w">  </span><span class="c1">// 用于构建加速结构</span>
<span class="n">VkPhysicalDeviceRayTracingPipelineFeaturesKHR</span><span class="w"> </span><span class="n">rtPipelineFeature</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR</span><span class="p">};</span>
<span class="n">contextInfo</span><span class="p">.</span><span class="n">addDeviceExtension</span><span class="p">(</span><span class="n">VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rtPipelineFeature</span><span class="p">);</span><span class="w">  </span><span class="c1">// 用于 vkCmdTraceRaysKHR</span>
<span class="n">contextInfo</span><span class="p">.</span><span class="n">addDeviceExtension</span><span class="p">(</span><span class="n">VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME</span><span class="p">);</span><span class="w">  </span><span class="c1">// 光线追踪光线的依赖</span>
</pre></div>
</div>
<p>在这些代码背后，其帮助我们选择一个支持激活 <code class="docutils literal notranslate"><span class="pre">VK_KHR_*</span></code> 扩展的物理设备，之后在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 之前将 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice*FeaturesKHR</span></code> 结构体插入 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 链中。
这将激活光线追踪特性并且获取有关设备对于光线追踪的能力。如果你对背后的原理好奇，可与预览 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 上下文封装 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/blob/1c59039a1ab0d777c79a29b09879a2686ec286dc/nvvk/context_vk.cpp#L211">Context::initInstance()</a> 。</p>
<div class="note admonition">
<p class="admonition-title">加载函数指针</p>
<p>与 <code class="docutils literal notranslate"><span class="pre">OpenGL</span></code> 一样，当在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中使用扩展时，您需要使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 手动加载扩展函数指针。该示例的 <code class="docutils literal notranslate"><span class="pre">nvvk::Context</span></code> 类在内部使用魔法已经为您做好了，对于获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言的 <code class="docutils literal notranslate"><span class="pre">API</span></code> 可以通过调用 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/blob/fd6f14c4ddcb6b2ec1e79462d372b32f3838b016/nvvk/extensions_vk.cpp#L2647">load_VK_EXTENSIONS</a> 获取。</p>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">hello_vulkan.h</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类中，增加一个初始化函数和用于存储 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的光追属性的成员变量。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// #VKRay</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">initRayTracing</span><span class="p">();</span>
<span class="n">VkPhysicalDeviceRayTracingPipelinePropertiesKHR</span><span class="w"> </span><span class="n">m_rtProperties</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR</span><span class="p">};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">hello_vulkan.cpp</span></code> 结尾增加 <code class="docutils literal notranslate"><span class="pre">initRayTracing()</span></code> 函数体，该函数将会使用扩展查询 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的光追属性。特别是对于获取最大递归深度的属性，例如对于单个光线可调用操作的嵌套式追踪数量。其可以看做场景中的单条光线递归路径追踪中可以反弹的次数。
需要注意的是，为了性能考量，递归应该尽量保持最小，这有利于循环执行。这也会查询之后章节创建着色器绑定表所需要的着色器头部大小。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 初始化Vulkan光线追踪</span>
<span class="c1">// #VKRay</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::initRayTracing</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 设置光追属性</span>
<span class="w">  </span><span class="n">VkPhysicalDeviceProperties2</span><span class="w"> </span><span class="n">prop2</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2</span><span class="p">};</span>
<span class="w">  </span><span class="n">prop2</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_rtProperties</span><span class="p">;</span>
<span class="w">  </span><span class="n">vkGetPhysicalDeviceProperties2</span><span class="p">(</span><span class="n">m_physicalDevice</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="main">
<h3>4.1 main<a class="headerlink" href="#main" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> 的 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 函数中，我们在 <code class="docutils literal notranslate"><span class="pre">helloVk.updateDescriptorSet()</span></code> 之后调用初始化函数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// #VKRay</span>
<span class="n">helloVk</span><span class="p">.</span><span class="n">initRayTracing</span><span class="p">();</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">练习</p>
<p>当执行该程序时，您可以在 <code class="docutils literal notranslate"><span class="pre">initRayTracing()</span></code> 函数出打个断点查看光追属性数据。在 <code class="docutils literal notranslate"><span class="pre">Quadro</span> <span class="pre">RTX</span> <span class="pre">6000</span></code> 设备上，
最大的递归深度是 <code class="docutils literal notranslate"><span class="pre">31</span></code> ，着色器组处理组的大小是 <code class="docutils literal notranslate"><span class="pre">16</span></code>。</p>
</div>
</section>
</section>
<section id="id12">
<h2>5 加速结构<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>为了提高效率，光线追踪使用加速结构（ <code class="docutils literal notranslate"><span class="pre">acceleration</span> <span class="pre">structure</span></code> ( <code class="docutils literal notranslate"><span class="pre">AS</span></code> ) ）组织几何体，这样在渲染时将减少光线-三角形求交测试的次数。该结构在硬件上使用经典的层级数据结构存储，但给用户提供可接触的层级只有
两级：一个顶层加速结构 （ <code class="docutils literal notranslate"><span class="pre">top-level</span> <span class="pre">acceleration</span> <span class="pre">structure</span></code> ( <code class="docutils literal notranslate"><span class="pre">TLAS</span></code> ) ）可以引用任意数量的底层加速结构 （ <code class="docutils literal notranslate"><span class="pre">bottom-level</span> <span class="pre">acceleration</span> <span class="pre">structures</span></code> ( <code class="docutils literal notranslate"><span class="pre">BLAS</span></code> ) ）。对于可以支持多少个顶层加速结构，
可通过 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxInstanceCount</span></code> 获取到。通常一个底层加速结构对应场景中一个单独的 <code class="docutils literal notranslate"><span class="pre">3D</span></code> 模型，并且一个顶层加速结构通过每一个单独的底层加速结构所对应的的位置（使用 <code class="docutils literal notranslate"><span class="pre">3×4</span></code> 的变换矩阵）
构建场景。</p>
<p>底层加速结构存储确切具体的顶点数据，底层加速结构使用一个或多个顶点缓存（ <code class="docutils literal notranslate"><span class="pre">vertex</span> <span class="pre">buffers</span></code> ）构建，每一个顶点缓存都会有自己的变换矩阵（这与顶层加速结构的矩阵进行区分），这样我们就可以在一个底层加速结构中存储多个有位置数据的模型。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果一个物体在同一个底层加速结构中实例化多次，他们的几何体数据将会进行复制。这对于提高一些静态，未实例化的场景的性能特别有帮助。
据经验来说，底层加速结构越少越好。</p>
</div>
<p>顶层加速结构可以包含多个物体的实体（ <code class="docutils literal notranslate"><span class="pre">instance</span></code> ），每一个实体都会有自己的变换矩阵并且引用一个具体的底层加速结构。我们将会从一个底层加速结构和一个单位矩阵的顶层加速结构实例开始实现。</p>
<figure class="align-default" id="id43">
<img alt="../../_images/AccelerationStructure.svg" src="../../_images/AccelerationStructure.svg" /><figcaption>
<p><span class="caption-text">加速结构</span><a class="headerlink" href="#id43" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>该教程将会加载一个 <code class="docutils literal notranslate"><span class="pre">OBJ</span></code> 文件，并将其索引、顶点和材质数据存储到 <code class="docutils literal notranslate"><span class="pre">ObjModel</span></code> 数据结构中。该模型同时引用一个 <code class="docutils literal notranslate"><span class="pre">ObjInstance</span></code> 数据结构，其中包含用于特定实体的变换矩阵。对于光线追踪， <code class="docutils literal notranslate"><span class="pre">ObjModel</span></code> 和一系列的 <code class="docutils literal notranslate"><span class="pre">ObjInstances</span></code> 将在之后分别用于构建底层加速结构和顶层加速结构。</p>
<p>为了假话光线追踪，我们使用一个帮助类，用于充当一个顶层加速结构和多个底层加速结构的容器，并且提供构建加速结构的接口函数。在 <code class="docutils literal notranslate"><span class="pre">hello_vulkan.h</span></code> 的头文件中包含 <code class="docutils literal notranslate"><span class="pre">raytrace_vkpp</span></code> 帮助类。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// #VKRay</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nvvk/raytraceKHR_vk.hpp&quot;</span>
</pre></div>
</div>
<p>之后我们可以在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类中增加该类型的成员变量。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">nvvk</span><span class="o">::</span><span class="n">RaytracingBuilderKHR</span><span class="w"> </span><span class="n">m_rtBuilder</span><span class="p">;</span>
</pre></div>
</div>
<p>并且在 <code class="docutils literal notranslate"><span class="pre">initRaytracing()</span></code> 末尾进行初始化。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">m_rtBuilder</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">m_graphicsQueueIndex</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">内存管理</p>
<p>该光追帮助类使用 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/blob/master/nvvk/resourceallocator_vk.hpp">nvvk/resourceallocator_vk.hpp</a> 避免去管理 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 内存。其内部提供 <code class="docutils literal notranslate"><span class="pre">nvvk::AccelKHR</span></code> 类型，该类型包含 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureKHR</span></code> 用于缓存创建和备份所需要的信息。
该资源可以使用不同的内存分配策略进行分配。在该教程中我们使用我们自己的 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/blob/master/nvvk/memallocator_dma_vk.hpp">DMA</a> 。其他的内存分配器也是可以使用的，
比如 <a class="reference external" href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator（VMA）</a> 或是专用内存分配器（比如一个 <code class="docutils literal notranslate"><span class="pre">VkDeviceMemory</span></code> 对应一个对象的策略，这种分配策略对于教学目的最容易理解，但是并不能用于产品开发）。</p>
</div>
<section id="bottom-level-acceleration-structure">
<span id="id13"></span><h3>5.1 底层加速结构<a class="headerlink" href="#bottom-level-acceleration-structure" title="Link to this heading">#</a></h3>
<p>构建底层加速器的第一步就是将 <code class="docutils literal notranslate"><span class="pre">ObjModel</span></code> 的几何数据转换成构建加速结构所需要的多个结构体中。我们使用 <code class="docutils literal notranslate"><span class="pre">nvvk::RaytracingBuilderKHR::BlasInput</span></code> 来维护所有的的结构体。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类中增加一个新函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">objectToVkGeometryKHR</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ObjModel</span><span class="o">&amp;</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">objectToVkGeometryKHR()</span></code> 函数返回类型为 <code class="docutils literal notranslate"><span class="pre">nvvk::RaytracingBuilderKHR::BlasInput</span></code> 但是这里我们使用 <code class="docutils literal notranslate"><span class="pre">C++</span></code> 的 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 来将返回值的类型推演交给编译器。</p>
</div>
<p>此函数内部将会填充三个结构体，这些结构体之后会用于构建加速结构（ <code class="docutils literal notranslate"><span class="pre">vkCmdBuildAccelerationStructuresKHR</span></code> ） 。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryTrianglesDataKHR</span></code> ：指向存有三角形的顶点，索引数据的缓存，以数组解析其中的数据（跨度，数据类型等）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryKHR</span></code> ：使用集合类型的枚举（此例为三角形）和加速结构的构建 <code class="docutils literal notranslate"><span class="pre">flags</span></code> 将之前的加速结构的几何数据进行打包。这一步是需要的，因为 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryTrianglesDataKHR</span></code> 是作为联合 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryDataKHR</span></code> 的一部分而传入的（几何体也可以是实例，用于顶层加速结构的构建或者 <code class="docutils literal notranslate"><span class="pre">AABBs</span></code> 包围盒，这些该例程并没有涉及到）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureBuildRangeInfoKHR</span></code> ：指示作为底层加速结构输入的几何体中的顶点数组源的索引。</p></li>
</ul>
<div class="tip admonition">
<p class="admonition-title">对于 VkAccelerationStructureGeometryKHR 和 VkAccelerationStructureBuildRangeInfoKHR 分别为独立结构体</p>
<p>一个潜在的疑惑：为什么 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryKHR</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureBuildRangeInfoKHR</span></code> 最终在构建加速结构时是单独的不同参数，但是却协同却定了顶点数据源的真正内存。打一个粗略的比方，这有点类似于 <code class="docutils literal notranslate"><span class="pre">glVertexAttribPointer</span></code> 定义的如何将一个缓存解析成顶点数组，并在 <code class="docutils literal notranslate"><span class="pre">glDrawArrays</span></code> 时确定顶点数组中到底那一部分需要绘制。</p>
</div>
<p>多个如上的结构体可以组建一个数组并可以用于构建一个底层加速结构。在该示例中，此数组的大小总是 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。 每一个底层加速结构有多个几何体是因为加速结构会更加高效，他会将求交的物体在空间上进行合理的划分。对于那种巨大、单一且静态的物体组需要考虑构建加速结构。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>我们现在认为所有的物体都是不透明的，并以此为前提进行潜在的优化。更具体的说是禁用了任意命中着色器（ <code class="docutils literal notranslate"><span class="pre">anyhit</span> <span class="pre">shader</span></code> ）的调用，之后会细说。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">VertexObj</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec3f</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="w">    </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec3f</span><span class="w"> </span><span class="n">nrm</span><span class="p">;</span>
<span class="w">    </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec3f</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec2f</span><span class="w"> </span><span class="n">texCoord</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 将一个OBJ模型转变成光追几何体用于构建底层加速结构</span>
<span class="c1">//</span>
<span class="k">auto</span><span class="w"> </span><span class="n">HelloVulkan</span><span class="o">::</span><span class="n">objectToVkGeometryKHR</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ObjModel</span><span class="o">&amp;</span><span class="w"> </span><span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 底层加速结构的侯建需要数据的原内存地址</span>
<span class="w">  </span><span class="n">VkDeviceAddress</span><span class="w"> </span><span class="n">vertexAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvvk</span><span class="o">::</span><span class="n">getBufferDeviceAddress</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">.</span><span class="n">vertexBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">  </span><span class="n">VkDeviceAddress</span><span class="w"> </span><span class="n">indexAddress</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">nvvk</span><span class="o">::</span><span class="n">getBufferDeviceAddress</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">.</span><span class="n">indexBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>

<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">maxPrimitiveCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">.</span><span class="n">nbIndices</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 将缓存描述为VertexObj（顶点）数组</span>
<span class="w">  </span><span class="n">VkAccelerationStructureGeometryTrianglesDataKHR</span><span class="w"> </span><span class="n">triangles</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR</span><span class="p">};</span>
<span class="w">  </span><span class="n">triangles</span><span class="p">.</span><span class="n">vertexFormat</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">VK_FORMAT_R32G32B32_SFLOAT</span><span class="p">;</span><span class="w">  </span><span class="c1">// vec3 顶点位置数据</span>
<span class="w">  </span><span class="n">triangles</span><span class="p">.</span><span class="n">vertexData</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertexAddress</span><span class="p">;</span>
<span class="w">  </span><span class="n">triangles</span><span class="p">.</span><span class="n">vertexStride</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">VertexObj</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// 描述索引数据 (32-bit unsigned int)</span>
<span class="w">  </span><span class="n">triangles</span><span class="p">.</span><span class="n">indexType</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="n">VK_INDEX_TYPE_UINT32</span><span class="p">;</span>
<span class="w">  </span><span class="n">triangles</span><span class="p">.</span><span class="n">indexData</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indexAddress</span><span class="p">;</span>
<span class="w">  </span><span class="c1">//当前transformData设置为null时代表是单位矩阵</span>
<span class="w">  </span><span class="c1">//triangles.transformData = {};</span>
<span class="w">  </span><span class="n">triangles</span><span class="p">.</span><span class="n">maxVertex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">.</span><span class="n">nbVertices</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 将之前的三角形设定成不透明</span>
<span class="w">  </span><span class="n">VkAccelerationStructureGeometryKHR</span><span class="w"> </span><span class="n">asGeom</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR</span><span class="p">};</span>
<span class="w">  </span><span class="n">asGeom</span><span class="p">.</span><span class="n">geometryType</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">VK_GEOMETRY_TYPE_TRIANGLES_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">asGeom</span><span class="p">.</span><span class="n">flags</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">VK_GEOMETRY_OPAQUE_BIT_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">asGeom</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">triangles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">triangles</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 整个数组都将用于构建底层加速结构</span>
<span class="w">  </span><span class="n">VkAccelerationStructureBuildRangeInfoKHR</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">  </span><span class="n">offset</span><span class="p">.</span><span class="n">firstVertex</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">offset</span><span class="p">.</span><span class="n">primitiveCount</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">maxPrimitiveCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">offset</span><span class="p">.</span><span class="n">primitiveOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">offset</span><span class="p">.</span><span class="n">transformOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 我们的底层加速结构只用一个几何体描述，但可以使用更多几何体</span>
<span class="w">  </span><span class="n">nvvk</span><span class="o">::</span><span class="n">RaytracingBuilderKHR</span><span class="o">::</span><span class="n">BlasInput</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">asGeometry</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">asGeom</span><span class="p">);</span>
<span class="w">  </span><span class="n">input</span><span class="p">.</span><span class="n">asBuildOffsetInfo</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">顶点属性</p>
<p>在上面的代码中， <code class="docutils literal notranslate"><span class="pre">VertexObj</span></code> 结构体中第一个成员是位置数据，如果成员在任意位置，我们需要使用 <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> 手动调整 <code class="docutils literal notranslate"><span class="pre">vertexAddress</span></code> 。对于加速结构的构建只需位置属性。之后我们将学习
在光追时绑定顶点缓存并使用其他顶点属性。</p>
</div>
<div class="warning admonition">
<p class="admonition-title">内存安全</p>
<p><code class="docutils literal notranslate"><span class="pre">BlasInput</span></code> 作为一个花里胡哨的设备指针指向顶点缓存数据。对于帮助类中并没有顶点数据的拷贝或管理。对于该示例，我们假设所有的模型都在一开始加载并且直到创建底层加速结构时内存不会篡改并有效。
如果你是动态加载并且卸载一个大场景的一部分或者动态生成顶点数据，您需要做的是在构建加速结构时避免发生资源竞争。</p>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类声明中，我们现在可以增加 <code class="docutils literal notranslate"><span class="pre">createBottomLevelAS()</span></code> 函数用于对每一个对象生成 <code class="docutils literal notranslate"><span class="pre">nvvk::RaytracingBuilderKHR::BlasInput</span></code> 并用于构建底层加速结构：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">createBottomLevelAS</span><span class="p">();</span>
</pre></div>
</div>
<p>在批量创建所有的底层加速结构前，使用一个循环遍历所有的模型，并且填入 <code class="docutils literal notranslate"><span class="pre">nvvk::RaytracingBuilderKHR::BlasInput</span></code> 数组中。加速结构的结存将会根据帮助类中的构建顺序存储，这样他们可以直接使用索引进行引用。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::createBottomLevelAS</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 底层加速结构 - 存储每个几何体中的图元</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">nvvk</span><span class="o">::</span><span class="n">RaytracingBuilderKHR</span><span class="o">::</span><span class="n">BlasInput</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allBlas</span><span class="p">;</span>
<span class="w">  </span><span class="n">allBlas</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_objModel</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_objModel</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">blas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objectToVkGeometryKHR</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 每一个底层加速结构都可以增加多个几何体，但现在我们只添加一个</span>
<span class="w">    </span><span class="n">allBlas</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">blas</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">m_rtBuilder</span><span class="p">.</span><span class="n">buildBlas</span><span class="p">(</span><span class="n">allBlas</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="raytracingbuilder-buildblas">
<h4>5.1.1 帮助类细节：RaytracingBuilder::buildBlas()<a class="headerlink" href="#raytracingbuilder-buildblas" title="Link to this heading">#</a></h4>
<p>这个帮助函数可以在 <code class="docutils literal notranslate"><span class="pre">raytraceKHR_vkpp.hpp</span></code> 中找到：其可以在很多项目中重用，并且也是 <a class="reference external" href="https://github.com/nvpro-samples">nvpro-samples</a> 中众多帮助类中的其中之一。该函数会对每一个 <code class="docutils literal notranslate"><span class="pre">RaytracingBuilderKHR::BlasInput</span></code> 生成一个底层加速结构。</p>
<p>创建一个底层加速结构需要如下元素：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureBuildGeometryInfoKHR</span></code> ：创建并构建加速结构，其基于 <code class="docutils literal notranslate"><span class="pre">objectToVkGeometryKHR()</span></code> 中创建的 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryKHR</span></code> 数组。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureBuildRangeInfoKHR</span></code> ：范围引用，与 <code class="docutils literal notranslate"><span class="pre">objectToVkGeometryKHR()</span></code> 中使用的相同。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureBuildSizesInfoKHR</span></code> ：创建加速结构所需要的大小和暂付缓存信息</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nvvk::AccelKHR</span></code> ：结果</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">暂付缓存</p>
<p>暂付缓存（ <code class="docutils literal notranslate"><span class="pre">scratch</span> <span class="pre">buffer</span></code> ），是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 对于内部缓存的优化。原本的内部缓存应由 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 驱动内部自身分配和管理，但是有些内部内存会经常性的更新，为了优化这一部分缓存， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 将这一部分
缓存交由用户分配管理，优化了内存使用和读写。 <code class="docutils literal notranslate"><span class="pre">scratch</span></code> 原本是抓挠之意，由于这部分内存时不时的要更新一下，像猫抓一样，所以叫 <code class="docutils literal notranslate"><span class="pre">抓挠</span></code> 缓存，实则是暂时交付给 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 驱动内部。</p>
</div>
<p>如上这些数据将存储到名为 <code class="docutils literal notranslate"><span class="pre">BuildAccelerationStructure</span></code> 结构体中用于简化创建。</p>
<p>在函数一开始，我们仅仅初始化我们之后需要的数据。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 使用BlasInput的数组创建所有的底层加速结构</span>
<span class="c1">// - input数组中的每一个BlasInput都对应一个底层加速结构</span>
<span class="c1">// - 底层加速结构的数量将会和input.size()一样</span>
<span class="c1">// - 创建的底层加速结构将会存储在m_blas（类型为std::vector&lt;nvvk::AccelKHR&gt;），并可以通过数组索引获取引用</span>
<span class="c1">// - 如果flag里设置了Compact位域，底层加速结构将会被压缩</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nvvk::RaytracingBuilderKHR::buildBlas</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BlasInput</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">VkBuildAccelerationStructureFlagsKHR</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">m_cmdPool</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_queueIndex</span><span class="p">);</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">     </span><span class="n">nbBlas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w"> </span><span class="n">asTotalSize</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w">     </span><span class="c1">// 所有要分配的底层加速结构所需要的内存大小</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">     </span><span class="n">nbCompactions</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w">   </span><span class="c1">// 需要压缩的底层加速结构的数量</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w"> </span><span class="n">maxScratchSize</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w">  </span><span class="c1">// 最大的暂付缓存大小</span>
</pre></div>
</div>
<p>接下来就是为每个底层加速结构构建 <code class="docutils literal notranslate"><span class="pre">BuildAccelerationStructure</span></code> ，用于引用几何体、构建范围、内存大小和暂付缓存大小。我们需要在每一次创建时都使用同一个暂付缓存，所以
我们需要留意需要的暂付缓存的最大大小，之后我们将使用该大小分配暂付缓存。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 为构建加速结构指令准备必要信息</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BuildAccelerationStructure</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buildAs</span><span class="p">(</span><span class="n">nbBlas</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nbBlas</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 填充VkAccelerationStructureBuildGeometryInfoKHR的部分属性用于获取构建的大小</span>
<span class="w">  </span><span class="c1">// 其他信息将会在createBlas时填入 (see #2)</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">type</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">mode</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">flags</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">geometryCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">asGeometry</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">pGeometries</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">asGeometry</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 设置范围信息</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">rangeInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">asBuildOffsetInfo</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// 获取创建加速结构所需的缓存和暂付缓存的大小</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">maxPrimCount</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">asBuildOffsetInfo</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">asBuildOffsetInfo</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">tt</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">maxPrimCount</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">asBuildOffsetInfo</span><span class="p">[</span><span class="n">tt</span><span class="p">].</span><span class="n">primitiveCount</span><span class="p">;</span><span class="w">  </span><span class="c1">// Number of primitives/triangles</span>
<span class="w">  </span><span class="n">vkGetAccelerationStructureBuildSizesKHR</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR</span><span class="p">,</span>
<span class="w">                                          </span><span class="o">&amp;</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">,</span><span class="w"> </span><span class="n">maxPrimCount</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 统计合并必要的数据大小</span>
<span class="w">  </span><span class="n">asTotalSize</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">accelerationStructureSize</span><span class="p">;</span>
<span class="w">  </span><span class="n">maxScratchSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">maxScratchSize</span><span class="p">,</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">buildScratchSize</span><span class="p">);</span>
<span class="w">  </span><span class="n">nbCompactions</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">hasFlag</span><span class="p">(</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在遍历完所有的底层加速结构后，我们有了需要创建的暂付缓存最大的大小。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 分配一个暂付缓存用于存储加速结构构建的临时数据</span>
<span class="n">nvvk</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">scratchBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">maxScratchSize</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="p">);</span>
<span class="n">VkBufferDeviceAddressInfo</span><span class="w"> </span><span class="n">bufferInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">scratchBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">};</span>
<span class="n">VkDeviceAddress</span><span class="w"> </span><span class="n">scratchAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkGetBufferDeviceAddress</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferInfo</span><span class="p">);</span>
</pre></div>
</div>
<p>接下来就是获取每一个底层加速结构的真正的大小。为了得到真正的大小，我们将使用 <code class="docutils literal notranslate"><span class="pre">VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR</span></code> 类型获取。 如果我们想要在之后压缩加速结构该类型是需要的。默认的情况下， <code class="docutils literal notranslate"><span class="pre">vkGetAccelerationStructureBuildSizesKHR</span></code> 将会返回无任何优化（最糟糕）的内存大小。在压缩创建之后，真实占有的空间大小可以相对较小，并且在加速结构之后拷贝仅拷贝必要信息。这将会节省超过 <code class="docutils literal notranslate"><span class="pre">50%</span></code> 的设备内存使用。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 创建一个用于获取每一个底层加速结构压缩的存储大小的查询队列</span>
<span class="n">VkQueryPool</span><span class="w"> </span><span class="n">queryPool</span><span class="p">{</span><span class="n">VK_NULL_HANDLE</span><span class="p">};</span>
<span class="k">if</span><span class="p">(</span><span class="n">nbCompactions</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="c1">// 是否有压缩的需求？</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">nbCompactions</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nbBlas</span><span class="p">);</span><span class="w">  </span><span class="c1">// 不允许混合使用压缩与非压缩的底层加速结构（要么全都压缩，要么都不压缩）</span>
<span class="w">  </span><span class="n">VkQueryPoolCreateInfo</span><span class="w"> </span><span class="n">qpci</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO</span><span class="p">};</span>
<span class="w">  </span><span class="n">qpci</span><span class="p">.</span><span class="n">queryCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbBlas</span><span class="p">;</span>
<span class="w">  </span><span class="n">qpci</span><span class="p">.</span><span class="n">queryType</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">vkCreateQueryPool</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qpci</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queryPool</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">压缩</p>
<p>为了使用压缩，底层加速结构的 <code class="docutils literal notranslate"><span class="pre">flags</span></code> 必须包含 <code class="docutils literal notranslate"><span class="pre">VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR</span></code> 位域。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 允许使用一个命令缓存（ <code class="docutils literal notranslate"><span class="pre">command</span> <span class="pre">buffer</span></code> ）创建所有的底层加速结构，但是这可能会导致管线的停顿和潜在的创建问题。为了避免这些问题，我们将底层加速结构按照大约 <code class="docutils literal notranslate"><span class="pre">256MB</span></code> 为一批进行创建。如果我们有压缩的需求，我们将立即执行，从而限制所需的内存分配。</p>
<p>如下即为将底层加速结构分割创建，对于 <code class="docutils literal notranslate"><span class="pre">cmdCreateBlas</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cmdCompactBlas</span></code> 函数将会一会儿细说。</p>
<div class="attention admonition">
<p class="admonition-title">256MB</p>
<p>并不是将一个占有巨大内存的加速结构分割成多个 <code class="docutils literal notranslate"><span class="pre">256MB</span></code> 的小内存块，而是每当一批加速结构的内存超过 <code class="docutils literal notranslate"><span class="pre">256MB</span></code> 的话，创建一个新的命令缓存负责该批加速结构的创建、构建和压缩。是将加速结构分散在不同的命令缓存中。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 批量创建/压缩底层加速结构，这样可以存入有限的内存</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">indices</span><span class="p">;</span><span class="w">  </span><span class="c1">// 底层加速结构创建对应的索引</span>
<span class="n">VkDeviceSize</span><span class="w">          </span><span class="n">batchSize</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">VkDeviceSize</span><span class="w">          </span><span class="n">batchLimit</span><span class="p">{</span><span class="mi">256&#39;000&#39;000</span><span class="p">};</span><span class="w">  </span><span class="c1">// 256 MB</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nbBlas</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="w">  </span><span class="n">batchSize</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">accelerationStructureSize</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 超过限值或是最后一个底层加速结构</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">batchSize</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">batchLimit</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nbBlas</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">cmdBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_cmdPool</span><span class="p">.</span><span class="n">createCommandBuffer</span><span class="p">();</span>
<span class="w">    </span><span class="n">cmdCreateBlas</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">buildAs</span><span class="p">,</span><span class="w"> </span><span class="n">scratchAddress</span><span class="p">,</span><span class="w"> </span><span class="n">queryPool</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_cmdPool</span><span class="p">.</span><span class="n">submitAndWait</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">queryPool</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">cmdBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_cmdPool</span><span class="p">.</span><span class="n">createCommandBuffer</span><span class="p">();</span>
<span class="w">      </span><span class="n">cmdCompactBlas</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">buildAs</span><span class="p">,</span><span class="w"> </span><span class="n">queryPool</span><span class="p">);</span>
<span class="w">      </span><span class="n">m_cmdPool</span><span class="p">.</span><span class="n">submitAndWait</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">);</span><span class="w">  </span><span class="c1">// 将命令缓存推送到队列执行并且调用vkQueueWaitIdle等待执行结束</span>

<span class="w">      </span><span class="c1">// 销毁未压缩版本</span>
<span class="w">      </span><span class="n">destroyNonCompacted</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">buildAs</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 重置</span>

<span class="w">    </span><span class="n">batchSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">indices</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>创建的加速结构将会保存在 <code class="docutils literal notranslate"><span class="pre">BuildAccelerationStructure</span></code> 中，可以通过索引获取到。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 存储所有创建的加速结构</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">buildAs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// b.as中的as即为创建的加速结构结果，类型为nvvk::AccelKHR</span>
<span class="w">  </span><span class="n">m_blas</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">as</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后我们将会清空不再需要的对象和内存。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 清空</span>
<span class="n">vkDestroyQueryPool</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">queryPool</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">finalizeAndReleaseStaging</span><span class="p">();</span>
<span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">scratchBuffer</span><span class="p">);</span>
<span class="n">m_cmdPool</span><span class="p">.</span><span class="n">deinit</span><span class="p">();</span>
</pre></div>
</div>
<section id="cmdcreateblas">
<h5>5.1.1.1 cmdCreateBlas<a class="headerlink" href="#cmdcreateblas" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 为buildAs数组中所有的BuildAccelerationStructure创建底层加速结构。</span>
<span class="c1">// BuildAccelerationStructure的数组是在buildBlas函数中构建的。</span>
<span class="c1">// indices的数组用于限值一次性创建底层加速结构的数量。</span>
<span class="c1">// 当压缩底层加速结构这将会限值内存量</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nvvk::RaytracingBuilderKHR::cmdCreateBlas</span><span class="p">(</span><span class="n">VkCommandBuffer</span><span class="w">                          </span><span class="n">cmdBuf</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w">                    </span><span class="n">indices</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BuildAccelerationStructure</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buildAs</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">VkDeviceAddress</span><span class="w">                          </span><span class="n">scratchAddress</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">VkQueryPool</span><span class="w">                              </span><span class="n">queryPool</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</div>
<p>首先我们为了获取底层加速结构的真正的大小需要重置查询。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">queryPool</span><span class="p">)</span><span class="w">  </span><span class="c1">// 用于查询压缩大小</span>
<span class="w">  </span><span class="n">vkResetQueryPool</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">queryPool</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">queryCnt</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
<p>该函数将会根据索引数组中的索引创建所有对应的底层加速结构</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</div>
<p>创建底层加速结构分两步：</p>
<ul class="simple">
<li><p>创建加速结构：使用抽象内存分配器和之前获取的大小信息，调用 <code class="docutils literal notranslate"><span class="pre">createAcceleration()</span></code> 函数来创建缓存和加速结构。</p></li>
<li><p>构建加速结构：使用加速结构，暂付缓存和几何信息构建真正的底层加速结构。</p></li>
</ul>
<p>这之后调用 <code class="docutils literal notranslate"><span class="pre">m_alloc-&gt;createAcceleration</span></code> 函数，该函数背后将按照查询到的加速结构的大小，并使用 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span></code> 两个缓存功能位域创建缓存（ 由于之后创建顶层加速结构需要底层加速结构的地址，所以需要 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span></code> ），
并通过 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureCreateInfoKHR</span></code> 设置目标 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 以此将分配的内存与加速结构进行绑定。而 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">image</span></code> 在绑定内存上与加速结构不同，对于 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">image</span></code> 其在 <code class="docutils literal notranslate"><span class="pre">Vk*</span></code> 的句柄分配和内存绑定是分开独立进行的，而加速结构是在通过 <code class="docutils literal notranslate"><span class="pre">vkCreateAccelerationStructureKHR</span></code> 创建时同时创建和绑定内存。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 真正的缓存分配和加速结构创建</span>
<span class="n">VkAccelerationStructureCreateInfoKHR</span><span class="w"> </span><span class="n">createInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR</span><span class="p">};</span>
<span class="n">createInfo</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR</span><span class="p">;</span>
<span class="n">createInfo</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">accelerationStructureSize</span><span class="p">;</span><span class="w">  </span><span class="c1">// 将用于内存分配</span>
<span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">createAcceleration</span><span class="p">(</span><span class="n">createInfo</span><span class="p">);</span>
<span class="n">NAME_IDX_VK</span><span class="p">(</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">.</span><span class="n">accel</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="n">NAME_IDX_VK</span><span class="p">(</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>

<span class="c1">// BuildInfo #2 part</span>
<span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">dstAccelerationStructure</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">.</span><span class="n">accel</span><span class="p">;</span><span class="w">  </span><span class="c1">// 设置构建的目标加速结构</span>
<span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">scratchData</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scratchAddress</span><span class="p">;</span><span class="w">  </span><span class="c1">// 所有的构建都使用同一个暂付缓存</span>

<span class="c1">// 构建底层加速结构</span>
<span class="n">vkCmdBuildAccelerationStructuresKHR</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">rangeInfo</span><span class="p">);</span>
</pre></div>
</div>
<p>注意在每次调用构建之后需要设置栅栏（ <code class="docutils literal notranslate"><span class="pre">barrier</span></code> ）：为了方便起见，在构建时重复使用暂付缓存，所以这里需要确保在开始一个新的构建前，之前的构建已经完成。按理来说，我们应该使用暂付缓存的不同部分以此来同时创建多个底层加速结构。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 一旦暂付缓存被重复使用, 我们需要一个栅栏用于确保之前的构建已经结束才开始构建下一个</span>
<span class="n">VkMemoryBarrier</span><span class="w"> </span><span class="n">barrier</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_MEMORY_BARRIER</span><span class="p">};</span>
<span class="n">barrier</span><span class="p">.</span><span class="n">srcAccessMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR</span><span class="p">;</span>
<span class="n">barrier</span><span class="p">.</span><span class="n">dstAccessMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR</span><span class="p">;</span>
<span class="n">vkCmdPipelineBarrier</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR</span><span class="p">,</span>
<span class="w">                     </span><span class="n">VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">barrier</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>之后我们查询需要的加速结构大小</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">queryPool</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 查询真正需要的内存数量，用于压缩</span>
<span class="w">  </span><span class="n">vkCmdWriteAccelerationStructuresPropertiesKHR</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">dstAccelerationStructure</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR</span><span class="p">,</span><span class="w"> </span><span class="n">queryPool</span><span class="p">,</span><span class="w"> </span><span class="n">queryCnt</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>尽管该方法可以很好的保持所有的底层加速结构的独立性，但构建很多底层加速结构将需要大量的暂付缓存并同时启动多个构建。当前的这个教程并没有使用可以大量减少加速结构内存的压缩策略。有关这两个方面将会在未来的高级教程中有所体现。</p>
</section>
<section id="cmdcompactblas">
<h5>5.1.1.2 cmdCompactBlas<a class="headerlink" href="#cmdcompactblas" title="Link to this heading">#</a></h5>
<p>当位域（ <code class="docutils literal notranslate"><span class="pre">flag</span></code> ）设置了压缩的话将会进入 <code class="docutils literal notranslate"><span class="pre">cmdCompactBlas</span></code>，将底层加速结构压缩进内存，这一部分功能是可选的。我们将会等待所有的底层加速结构构建完成之后再将其拷贝至合适的内存空间中。这就是为什么我们要在调用 <code class="docutils literal notranslate"><span class="pre">cmdCompactBlas</span></code> 函数之前调用 <code class="docutils literal notranslate"><span class="pre">m_cmdPool.submitAndWait(cmdBuf)</span></code> 。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 使用查询队列查询到的大小创建新的缓存和加速结构并替换</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nvvk::RaytracingBuilderKHR::cmdCompactBlas</span><span class="p">(</span><span class="n">VkCommandBuffer</span><span class="w">                          </span><span class="n">cmdBuf</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w">                    </span><span class="n">indices</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BuildAccelerationStructure</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buildAs</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">VkQueryPool</span><span class="w">                              </span><span class="n">queryPool</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</div>
<p>大体上来说，压缩流程如下：</p>
<ol class="arabic simple">
<li><p>获取查询到的数据（压缩大小）</p></li>
<li><p>使用较小的大小创建一个新的加速结构</p></li>
<li><p>将之前的加速结构拷贝到新创建的加速结构中</p></li>
<li><p>将之前的加速结构销毁</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queryCtn</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">nvvk</span><span class="o">::</span><span class="n">AccelKHR</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cleanupAS</span><span class="p">;</span><span class="w">  </span><span class="c1">// 准备将之前的加速结构销毁</span>

<span class="c1">// 获取查询到的压缩大小</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkDeviceSize</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compactSizes</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="n">vkGetQueryPoolResults</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">queryPool</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">compactSizes</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">compactSizes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">VkDeviceSize</span><span class="p">),</span>
<span class="w">                      </span><span class="n">compactSizes</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">VkDeviceSize</span><span class="p">),</span><span class="w"> </span><span class="n">VK_QUERY_RESULT_WAIT_BIT</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">cleanupAS</span><span class="w">                          </span><span class="o">=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">;</span><span class="w">           </span><span class="c1">// 设置要销毁的加速结构</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">accelerationStructureSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compactSizes</span><span class="p">[</span><span class="n">queryCtn</span><span class="o">++</span><span class="p">];</span><span class="w">  </span><span class="c1">// 使用压缩大小</span>

<span class="w">  </span><span class="c1">// 创建压缩版本的加速结构</span>
<span class="w">  </span><span class="n">VkAccelerationStructureCreateInfoKHR</span><span class="w"> </span><span class="n">asCreateInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR</span><span class="p">};</span>
<span class="w">  </span><span class="n">asCreateInfo</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">accelerationStructureSize</span><span class="p">;</span>
<span class="w">  </span><span class="n">asCreateInfo</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">createAcceleration</span><span class="p">(</span><span class="n">asCreateInfo</span><span class="p">);</span>
<span class="w">  </span><span class="n">NAME_IDX_VK</span><span class="p">(</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">.</span><span class="n">accel</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="w">  </span><span class="n">NAME_IDX_VK</span><span class="p">(</span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 将之前的底层加速结构拷贝至压缩版本中</span>
<span class="w">  </span><span class="n">VkCopyAccelerationStructureInfoKHR</span><span class="w"> </span><span class="n">copyInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR</span><span class="p">};</span>
<span class="w">  </span><span class="n">copyInfo</span><span class="p">.</span><span class="n">src</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buildInfo</span><span class="p">.</span><span class="n">dstAccelerationStructure</span><span class="p">;</span>
<span class="w">  </span><span class="n">copyInfo</span><span class="p">.</span><span class="n">dst</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">buildAs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">as</span><span class="p">.</span><span class="n">accel</span><span class="p">;</span>
<span class="w">  </span><span class="n">copyInfo</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">vkCmdCopyAccelerationStructureKHR</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">copyInfo</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id15">
<h3>5.2 顶层加速结构<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<p>顶层加速结构是描述光追场景的入口，并且存有所有的实体。在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类中增加一个新成员方法：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">createTopLevelAS</span><span class="p">();</span>
</pre></div>
</div>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureInstanceKHR</span></code> 代表一个实体，其内部有用于与 <code class="docutils literal notranslate"><span class="pre">buildBlas</span></code> 中创建的底层加速结构相关联的变换矩阵（ <code class="docutils literal notranslate"><span class="pre">transform</span></code> ），并且还包括一个实体 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 号，可以在着色器中通过 <code class="docutils literal notranslate"><span class="pre">gl_InstanceCustomIndex</span></code> 获取到，用于表示着色器中调用被击中对象组中的索引（ <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureInstanceKHR::instanceShaderBindingTableRecordOffset</span></code> 在帮助类中也叫 <code class="docutils literal notranslate"><span class="pre">hitGroupId</span></code> ）。</p>
<div class="warning admonition">
<p class="admonition-title">gl_InstanceID</p>
<p>不要将 <code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> 和 <code class="docutils literal notranslate"><span class="pre">gl_InstanceCustomIndex</span></code> 搞混。 <code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> 仅仅用于表示在顶层加速结构内实体集中被击中的实体索引。</p>
<p>在本教程中，我们可以暂时忽略自定义索引（ <code class="docutils literal notranslate"><span class="pre">gl_InstanceCustomIndex</span></code> ），因为其值将会与 <code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> 相等（ <code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> 用于表示与当前光线相交的实体索引，目前该索引值与 <code class="docutils literal notranslate"><span class="pre">i</span></code> 值相同）。在之后的例子中该值将会不同。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<ul>
<li><p>这个 <code class="docutils literal notranslate"><span class="pre">i</span></code> 突然冒出来，不知所云。估计应该是着色器中的实体索引：</p>
<blockquote>
<div><div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eObjDescs</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">objDesc_</span><span class="w"> </span><span class="p">{</span><span class="n">ObjDesc</span><span class="w"> </span><span class="n">i</span><span class="p">[];}</span><span class="w"> </span><span class="n">objDesc</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_InstanceCustomIndex</span></code> 。根据 <a class="reference external" href="https://github.com/KhronosGroup/GLSL/blob/883a2113d8ab3cbf0cc534989a90ba1bb0ba6a11/extensions/ext/GLSL_EXT_ray_tracing.txt#L728">GLSL标准</a> 中的描述， 其是用于描述：与当前光线相交的实体中应用自定义的值，该值为 <code class="docutils literal notranslate"><span class="pre">32</span></code> 位，使用低 <code class="docutils literal notranslate"><span class="pre">24</span></code> 位，高 <code class="docutils literal notranslate"><span class="pre">8</span></code> 位是 <code class="docutils literal notranslate"><span class="pre">0</span></code>。使用时一般写作 <code class="docutils literal notranslate"><span class="pre">gl_InstanceCustomIndexEXT</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_InstanceID</span></code> 根据 <a class="reference external" href="https://github.com/KhronosGroup/GLSL/blob/883a2113d8ab3cbf0cc534989a90ba1bb0ba6a11/extensions/ext/GLSL_EXT_ray_tracing.txt#L745">GLSL标准</a> 中的描述， 其是用于描述：与当前光线相交的实体的索引。</p></li>
</ul>
<p>详情可参考该 <a class="reference external" href="https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR/issues/57">Issue</a> 。</p>
</div>
</div>
<p>索引和命中组（ <code class="docutils literal notranslate"><span class="pre">hit</span> <span class="pre">groups</span></code> ）概念贯穿光追管线和着色器绑定表，将会在后面介绍并用于在运行时选择确认哪些着色器被调用。就目前来说我们整个场景中只会使用一个命中组，所以命中组的索引将一直是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。最终实体也许会指示剔除选项，比如使用 <code class="docutils literal notranslate"><span class="pre">VkGeometryInstanceFlagsKHR</span> <span class="pre">flags</span></code> 剔除背面。在此例子中我们为了简单和独立输入模型决定禁用剔除。</p>
<p>一旦所有的实体对象创建完成，我们将会构建顶层加速结构，构建器比较喜欢生成光追性能友好的顶层加速结构（比如加速结构的大小不是首要考虑的）。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::createTopLevelAS</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkAccelerationStructureInstanceKHR</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tlas</span><span class="p">;</span>
<span class="w">  </span><span class="n">tlas</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_instances</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">HelloVulkan</span><span class="o">::</span><span class="n">ObjInstance</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inst</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_instances</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkAccelerationStructureInstanceKHR</span><span class="w"> </span><span class="n">rayInst</span><span class="p">{};</span>
<span class="w">    </span><span class="n">rayInst</span><span class="p">.</span><span class="n">transform</span><span class="w">                      </span><span class="o">=</span><span class="w"> </span><span class="n">nvvk</span><span class="o">::</span><span class="n">toTransformMatrixKHR</span><span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">transform</span><span class="p">);</span><span class="w">  </span><span class="c1">// 该实体的位置</span>
<span class="w">    </span><span class="n">rayInst</span><span class="p">.</span><span class="n">instanceCustomIndex</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">inst</span><span class="p">.</span><span class="n">objIndex</span><span class="p">;</span><span class="w">                               </span><span class="c1">// gl_InstanceCustomIndexEXT</span>
<span class="w">    </span><span class="n">rayInst</span><span class="p">.</span><span class="n">accelerationStructureReference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtBuilder</span><span class="p">.</span><span class="n">getBlasDeviceAddress</span><span class="p">(</span><span class="n">inst</span><span class="p">.</span><span class="n">objIndex</span><span class="p">);</span>
<span class="w">    </span><span class="n">rayInst</span><span class="p">.</span><span class="n">flags</span><span class="w">                          </span><span class="o">=</span><span class="w"> </span><span class="n">VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR</span><span class="p">;</span>
<span class="w">    </span><span class="n">rayInst</span><span class="p">.</span><span class="n">mask</span><span class="w">                           </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w">       </span><span class="c1">//  只有当 rayMask &amp; instance.mask != 0 成立方为命中</span>
<span class="w">    </span><span class="n">rayInst</span><span class="p">.</span><span class="n">instanceShaderBindingTableRecordOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 对于所有的对象我们将使用相同的命中组</span>
<span class="w">    </span><span class="n">tlas</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">rayInst</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">m_rtBuilder</span><span class="p">.</span><span class="n">buildTlas</span><span class="p">(</span><span class="n">tlas</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">m_instances 的 inst.transform 和 inst.objIndex</p>
<p>都是在一开始调用 <code class="docutils literal notranslate"><span class="pre">loadModel(const</span> <span class="pre">std::string&amp;</span> <span class="pre">filename,</span> <span class="pre">nvmath::mat4f</span> <span class="pre">transform</span> <span class="pre">=</span> <span class="pre">nvmath::mat4f(1))</span></code> 函数加载模型时设置好的，对于 <code class="docutils literal notranslate"><span class="pre">inst.transform</span></code> 设置的是默认参数 <code class="docutils literal notranslate"><span class="pre">nvmath::mat4f(1)</span></code> 也就是单位矩阵。
对于 <code class="docutils literal notranslate"><span class="pre">inst.objIndex</span></code> 设置的是读取的第几个模型作为对象索引。每一个模型对应 <code class="docutils literal notranslate"><span class="pre">m_instances</span></code> 数组中的一个元素。</p>
</div>
<div class="note admonition">
<p class="admonition-title">getBlasDeviceAddress(uint32_t blasId)</p>
<p>该函数返回 <code class="docutils literal notranslate"><span class="pre">blasId</span></code> 索引处的底层加速结构的设备内存地址句柄</p>
</div>
<p>和往常使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 一样，我们需要对于之前创建的对象在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan::destroyResources</span></code> 结尾销毁。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// #VKRay</span>
<span class="n">m_rtBuilder</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</pre></div>
</div>
<section id="raytracingbuilder-buildtlas">
<h4>5.2.1 帮助类细节：RaytracingBuilder::buildTlas()<a class="headerlink" href="#raytracingbuilder-buildtlas" title="Link to this heading">#</a></h4>
<p>作为 <a class="reference external" href="https://github.com/nvpro-samples">nvpro-samples</a> 的一部分，该帮助类提供用于构建构建顶层加速结构并且使用一批 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> (实体)对象来创建一个顶层加速结构。</p>
<p>我们首先创建一个命令缓存并且将 <code class="docutils literal notranslate"><span class="pre">flags</span></code> 的默认值在这里显示出来。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用一批实体创建顶层加速结构</span>
<span class="c1">// - 注意instances的类型（一批实体）</span>
<span class="c1">// - 创建的顶层加速结构的结果将会存储在m_tlas</span>
<span class="c1">// - 对于顶层加速结构的更新就是使用新的变换矩阵重新构建顶层加速结构</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">buildTlas</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkAccelerationStructureInstanceKHR</span><span class="o">&gt;&amp;</span><span class="w">         </span><span class="n">instances</span><span class="p">,</span>
<span class="w">               </span><span class="n">VkBuildAccelerationStructureFlagsKHR</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR</span><span class="p">,</span>
<span class="w">               </span><span class="kt">bool</span><span class="w">                                 </span><span class="n">update</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 除非要更新顶层加速结构否则buildTlas函数只能调用一次</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">m_tlas</span><span class="p">.</span><span class="n">accel</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">update</span><span class="p">);</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">countInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instances</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// 用于创建顶层加速结构的命令缓存</span>
<span class="w">  </span><span class="n">nvvk</span><span class="o">::</span><span class="n">CommandPool</span><span class="w"> </span><span class="n">genCmdBuf</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_queueIndex</span><span class="p">);</span>
<span class="w">  </span><span class="n">VkCommandBuffer</span><span class="w">   </span><span class="n">cmdBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">genCmdBuf</span><span class="p">.</span><span class="n">createCommandBuffer</span><span class="p">();</span>
</pre></div>
</div>
<p>之后，我能需要将实体们加载进设备中。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 用于创建顶层加速结构的命令缓存</span>
<span class="n">nvvk</span><span class="o">::</span><span class="n">CommandPool</span><span class="w"> </span><span class="nf">genCmdBuf</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_queueIndex</span><span class="p">);</span>
<span class="n">VkCommandBuffer</span><span class="w">   </span><span class="n">cmdBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">genCmdBuf</span><span class="p">.</span><span class="n">createCommandBuffer</span><span class="p">();</span>

<span class="c1">// 创建一个缓存用于存放该批实体数据用于加速结构的构建</span>
<span class="n">nvvk</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">instancesBuffer</span><span class="p">;</span><span class="w">  </span><span class="c1">// 该批的实体缓存中包含每个实体的变换矩阵和底层加速结构的ID</span>
<span class="n">instancesBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">instances</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span>
<span class="w">                                            </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</span><span class="p">);</span>
<span class="n">NAME_VK</span><span class="p">(</span><span class="n">instancesBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
<span class="n">VkBufferDeviceAddressInfo</span><span class="w"> </span><span class="n">bufferInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">instancesBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">};</span>
<span class="n">VkDeviceAddress</span><span class="w">           </span><span class="n">instBufferAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkGetBufferDeviceAddress</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferInfo</span><span class="p">);</span>

<span class="c1">// 插入一个栅栏用于确保在开始构建加速结构之前实体数据的缓存拷贝已经完成（注意下面的备注）</span>
<span class="n">VkMemoryBarrier</span><span class="w"> </span><span class="n">barrier</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_MEMORY_BARRIER</span><span class="p">};</span>
<span class="n">barrier</span><span class="p">.</span><span class="n">srcAccessMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCESS_TRANSFER_WRITE_BIT</span><span class="p">;</span>
<span class="n">barrier</span><span class="p">.</span><span class="n">dstAccessMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR</span><span class="p">;</span>
<span class="n">vkCmdPipelineBarrier</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">VK_PIPELINE_STAGE_TRANSFER_BIT</span><span class="p">,</span><span class="w"> </span><span class="n">VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR</span><span class="p">,</span>
<span class="w">                     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">barrier</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">插入一个栅栏用于确保在开始构建加速结构之前实体数据的缓存拷贝已经完成</p>
<p>在调用 <code class="docutils literal notranslate"><span class="pre">m_alloc-&gt;createBuffer</span></code> 时会进行两步任务</p>
<ol class="arabic simple">
<li><p>创建缓存</p></li>
<li><p>使用命令缓存将外部数据拷贝至缓存中（使用 <code class="docutils literal notranslate"><span class="pre">vkCmdCopyBuffer</span></code> ）</p></li>
</ol>
<p>所以这里在之后需要插入一个栅栏，用于确保数据已经复制拷贝完成再进行接下来的任务。</p>
</div>
<p>此时我们已经有两一个命令缓存（ <code class="docutils literal notranslate"><span class="pre">cmdBuf</span></code> ），实体数量（ <code class="docutils literal notranslate"><span class="pre">countInstance</span></code> ）和存有所有 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureInstanceKHR</span></code> 数据的缓存地址。有了这些信息，我们就可以调用顶层加速结构构建函数了，该函数将会分配一个暂付缓存，该暂付缓存将会在所有工作结束后销毁。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// 创建顶层加速结构</span>
<span class="w">    </span><span class="n">nvvk</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">scratchBuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">cmdCreateTlas</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">countInstance</span><span class="p">,</span><span class="w"> </span><span class="n">instBufferAddr</span><span class="p">,</span><span class="w"> </span><span class="n">scratchBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">update</span><span class="p">,</span><span class="w"> </span><span class="n">motion</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 最后销毁临时数据</span>
<span class="w">    </span><span class="n">genCmdBuf</span><span class="p">.</span><span class="n">submitAndWait</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">);</span><span class="w">  </span><span class="c1">// 内部会等待任务执行结束</span>
<span class="w">    </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">finalizeAndReleaseStaging</span><span class="p">();</span>
<span class="w">    </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">scratchBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">instancesBuffer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>接下来开始构建真正的顶层加速结构</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 创建顶层加速结构</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nvvk::RaytracingBuilderKHR::cmdCreateTlas</span><span class="p">(</span><span class="n">VkCommandBuffer</span><span class="w">                      </span><span class="n">cmdBuf</span><span class="p">,</span>
<span class="w">                                               </span><span class="kt">uint32_t</span><span class="w">                             </span><span class="n">countInstance</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">VkDeviceAddress</span><span class="w">                      </span><span class="n">instBufferAddr</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">nvvk</span><span class="o">::</span><span class="n">Buffer</span><span class="o">&amp;</span><span class="w">                        </span><span class="n">scratchBuffer</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">VkBuildAccelerationStructureFlagsKHR</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span>
<span class="w">                                               </span><span class="kt">bool</span><span class="w">                                 </span><span class="n">update</span><span class="p">,</span>
<span class="w">                                               </span><span class="kt">bool</span><span class="w">                                 </span><span class="n">motion</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>
</div>
<p>接下来就是填充创建顶层加速结构的结构体。该加速结构用于表示一个包含很多实体的几何体。</p>
<div class="note admonition">
<p class="admonition-title">该加速结构用于表示一个包含很多实体的几何体</p>
<p>创建和构建顶层加速结构其实和构建底层加速结构区别不大，与底层加速结构的主要区别是：底层加速结构的几何信息是真的几何信息，而顶层加速结构的几何信息是实体信息。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 将之前拷贝上传的实体设备内存进行设置打包</span>
<span class="n">VkAccelerationStructureGeometryInstancesDataKHR</span><span class="w"> </span><span class="n">instancesVk</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR</span><span class="p">};</span>
<span class="n">instancesVk</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instBufferAddr</span><span class="p">;</span>

<span class="c1">// 将instancesVk设置到VkAccelerationStructureGeometryKHR中. 我们需要将实体数据放入联合体中并指定该数据为实体数据（见下面的备注详情）</span>
<span class="n">VkAccelerationStructureGeometryKHR</span><span class="w"> </span><span class="n">topASGeometry</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR</span><span class="p">};</span>
<span class="n">topASGeometry</span><span class="p">.</span><span class="n">geometryType</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">VK_GEOMETRY_TYPE_INSTANCES_KHR</span><span class="p">;</span>
<span class="n">topASGeometry</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">instances</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instancesVk</span><span class="p">;</span>

<span class="c1">// 获取加速结构大小</span>
<span class="n">VkAccelerationStructureBuildGeometryInfoKHR</span><span class="w"> </span><span class="n">buildInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR</span><span class="p">};</span>
<span class="n">buildInfo</span><span class="p">.</span><span class="n">flags</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="n">buildInfo</span><span class="p">.</span><span class="n">geometryCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">buildInfo</span><span class="p">.</span><span class="n">pGeometries</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">topASGeometry</span><span class="p">;</span>
<span class="n">buildInfo</span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR</span><span class="p">;</span>
<span class="n">buildInfo</span><span class="p">.</span><span class="n">type</span><span class="w">                     </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</span><span class="p">;</span>
<span class="n">buildInfo</span><span class="p">.</span><span class="n">srcAccelerationStructure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkAccelerationStructureBuildSizesInfoKHR</span><span class="w"> </span><span class="n">sizeInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR</span><span class="p">};</span>
<span class="n">vkGetAccelerationStructureBuildSizesKHR</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildInfo</span><span class="p">,</span>
<span class="w">                                      </span><span class="o">&amp;</span><span class="n">countInstance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sizeInfo</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">我们需要将实体数据放入联合体中并指定该数据为实体数据</p>
<ul>
<li><p>对于 <code class="docutils literal notranslate"><span class="pre">实体数据放入联合体中</span></code>：</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">instancesVk</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instBufferAddr</span>
</pre></div>
</div>
<p>主要是指上面这行代码，将实体数据 <code class="docutils literal notranslate"><span class="pre">instBufferAddr</span></code> 设置到 <code class="docutils literal notranslate"><span class="pre">instancesVk.data.deviceAddress</span></code> 中。而在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中 <code class="docutils literal notranslate"><span class="pre">instancesVk.data</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">VkDeviceOrHostAddressConstKHR</span></code> ，声明如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由VK_KHR_acceleration_structure提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">VkDeviceOrHostAddressConstKHR</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkDeviceAddress</span><span class="w">    </span><span class="n">deviceAddress</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">        </span><span class="n">hostAddress</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceOrHostAddressConstKHR</span><span class="p">;</span>
</pre></div>
</div>
<p>可以看到该结构体被声明为 <code class="docutils literal notranslate"><span class="pre">union</span></code> 联合体（ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 光追标准中很多相关的结构体都是联合体）。</p>
</div></blockquote>
</li>
<li><p>对于 <code class="docutils literal notranslate"><span class="pre">指定该数据为实体数据</span></code>：</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">topASGeometry</span><span class="p">.</span><span class="n">geometryType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_GEOMETRY_TYPE_INSTANCES_KHR</span><span class="p">;</span>
</pre></div>
</div>
<p>主要是指上面这行代码，用于告诉 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 驱动，将数据解析成实体数据。</p>
</div></blockquote>
</li>
</ul>
</div>
<p>现在我们就可以创建加速结构了，目前还没到构建阶段。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkAccelerationStructureCreateInfoKHR</span><span class="w"> </span><span class="n">createInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR</span><span class="p">};</span>
<span class="n">createInfo</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</span><span class="p">;</span>
<span class="n">createInfo</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">accelerationStructureSize</span><span class="p">;</span>

<span class="n">m_tlas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">createAcceleration</span><span class="p">(</span><span class="n">createInfo</span><span class="p">);</span>
<span class="n">NAME_VK</span><span class="p">(</span><span class="n">m_tlas</span><span class="p">.</span><span class="n">accel</span><span class="p">);</span>
<span class="n">NAME_VK</span><span class="p">(</span><span class="n">m_tlas</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
</pre></div>
</div>
<p>构建顶层加速结构同样需要暂付缓存。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 分配暂付缓存</span>
<span class="n">scratchBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="o">-&gt;</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">sizeInfo</span><span class="p">.</span><span class="n">buildScratchSize</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span><span class="p">);</span>

<span class="n">VkBufferDeviceAddressInfo</span><span class="w"> </span><span class="n">bufferInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">scratchBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">};</span>
<span class="n">VkDeviceAddress</span><span class="w">           </span><span class="n">scratchAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkGetBufferDeviceAddress</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferInfo</span><span class="p">);</span>
<span class="n">NAME_VK</span><span class="p">(</span><span class="n">scratchBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">);</span>
</pre></div>
</div>
<p>最后我们就可以构建该顶层加速结构了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// 更新构建信息</span>
<span class="w">  </span><span class="n">buildInfo</span><span class="p">.</span><span class="n">srcAccelerationStructure</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
<span class="w">  </span><span class="n">buildInfo</span><span class="p">.</span><span class="n">dstAccelerationStructure</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">m_tlas</span><span class="p">.</span><span class="n">accel</span><span class="p">;</span>
<span class="w">  </span><span class="n">buildInfo</span><span class="p">.</span><span class="n">scratchData</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scratchAddress</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 构建偏移信息: 实体数量（其实设置的是VkAccelerationStructureBuildRangeInfoKHR::primitiveCount信息）</span>
<span class="w">  </span><span class="n">VkAccelerationStructureBuildRangeInfoKHR</span><span class="w">        </span><span class="n">buildOffsetInfo</span><span class="p">{</span><span class="n">countInstance</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkAccelerationStructureBuildRangeInfoKHR</span><span class="o">*</span><span class="w"> </span><span class="n">pBuildOffsetInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildOffsetInfo</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 构建顶层加速结构</span>
<span class="w">  </span><span class="n">vkCmdBuildAccelerationStructuresKHR</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buildInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pBuildOffsetInfo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id18">
<h3>5.3 main<a class="headerlink" href="#id18" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中，我现在可以在初始化光追之后增加对于几何实体和加速结构的创建了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// #VKRay</span>
<span class="n">helloVk</span><span class="p">.</span><span class="n">initRayTracing</span><span class="p">();</span>
<span class="n">helloVk</span><span class="p">.</span><span class="n">createBottomLevelAS</span><span class="p">();</span>
<span class="n">helloVk</span><span class="p">.</span><span class="n">createTopLevelAS</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="descriptor-set">
<h2>6 光线追踪描述符集（Descriptor Set）<a class="headerlink" href="#descriptor-set" title="Link to this heading">#</a></h2>
<p>与光栅化着色器一样，光线追踪着色器同样使用描述符集来引用外部资源。在光栅化图形管线中使用不同的材质绘制场景，我们可以根据材质来组织要绘制的对象，并根据材质的使用情况确定渲染顺序。只有当材质要绘制物体时才需要绑定对应的材质管线和描述符。</p>
<p>然而，在光线追踪时，不可能事先知道哪些物体会和光线相交，所以在任意时刻都有可能调用某个着色器。为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 光追扩展使用单独的描述符集集合来描述场景渲染时所需的所有资源。比如，它可能包含所有材质需要的所有纹理。此外加速结构中只存有位置数据，我们需要将顶点和索引缓存传入到着色器中，
这样我们就可以获取到其他的顶点属性。</p>
<p>为了维持光栅化和光线追踪之间的兼容性，我们将会重复利用之前光栅化渲染器的描述符集，该描述符集不仅会包含场景信息，此外还会增加另外一些描述符集用于引用顶层加速结构和缓存输出结果。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">hello_vulkan.h</span></code> 头文件中，我们声明与的描述符集相关的对象：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">createRtDescriptorSet</span><span class="p">();</span>

<span class="n">nvvk</span><span class="o">::</span><span class="n">DescriptorSetBindings</span><span class="w">                     </span><span class="n">m_rtDescSetLayoutBind</span><span class="p">;</span>
<span class="n">VkDescriptorPool</span><span class="w">                                </span><span class="n">m_rtDescPool</span><span class="p">;</span>
<span class="n">VkDescriptorSetLayout</span><span class="w">                           </span><span class="n">m_rtDescSetLayout</span><span class="p">;</span>
<span class="n">VkDescriptorSet</span><span class="w">                                 </span><span class="n">m_rtDescSet</span><span class="p">;</span>
</pre></div>
</div>
<p>光线生成着色器（ <code class="docutils literal notranslate"><span class="pre">Ray</span> <span class="pre">Generation</span> <span class="pre">shader</span></code> ）将会通过代用 <code class="docutils literal notranslate"><span class="pre">TraceRayEXT()</span></code> 来访问加速结构，在该文档的后面，我们也将使用最近命中着色器（ <code class="docutils literal notranslate"><span class="pre">Closest</span> <span class="pre">Hit</span> <span class="pre">shader</span></code> ）来访问加速结构，输出的图片将会通过光栅化离屏输出，并且只有光线生成着色器可以写入。</p>
<div class="note admonition">
<p class="admonition-title">离屏输出</p>
<p>离屏输出意思是，输出的图片不与屏幕或者窗口有直接联系，图片也不会直接输出到屏幕上，一般输出的图片为用户自己创建的图片，需要将该图片拷贝至与窗口或屏幕相关的图片上才能显示。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 该描述符集包含加速结构和输出图片</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::createRtDescriptorSet</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">RtxBindings</span><span class="o">::</span><span class="n">eTlas</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="p">);</span><span class="w">  </span><span class="c1">// 顶层加速结构</span>
<span class="w">  </span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">RtxBindings</span><span class="o">::</span><span class="n">eOutImage</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="p">);</span><span class="w">  </span><span class="c1">// 输出图片</span>

<span class="w">  </span><span class="n">m_rtDescPool</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">createPool</span><span class="p">(</span><span class="n">m_device</span><span class="p">);</span>
<span class="w">  </span><span class="n">m_rtDescSetLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">createLayout</span><span class="p">(</span><span class="n">m_device</span><span class="p">);</span>

<span class="w">  </span><span class="n">VkDescriptorSetAllocateInfo</span><span class="w"> </span><span class="n">allocateInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO</span><span class="p">};</span>
<span class="w">  </span><span class="n">allocateInfo</span><span class="p">.</span><span class="n">descriptorPool</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtDescPool</span><span class="p">;</span>
<span class="w">  </span><span class="n">allocateInfo</span><span class="p">.</span><span class="n">descriptorSetCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">allocateInfo</span><span class="p">.</span><span class="n">pSetLayouts</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_rtDescSetLayout</span><span class="p">;</span>
<span class="w">  </span><span class="n">vkAllocateDescriptorSets</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">allocateInfo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_rtDescSet</span><span class="p">);</span>


<span class="w">  </span><span class="n">VkAccelerationStructureKHR</span><span class="w">                   </span><span class="n">tlas</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtBuilder</span><span class="p">.</span><span class="n">getAccelerationStructure</span><span class="p">();</span>
<span class="w">  </span><span class="n">VkWriteDescriptorSetAccelerationStructureKHR</span><span class="w"> </span><span class="n">descASInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR</span><span class="p">};</span>
<span class="w">  </span><span class="n">descASInfo</span><span class="p">.</span><span class="n">accelerationStructureCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">descASInfo</span><span class="p">.</span><span class="n">pAccelerationStructures</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tlas</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkDescriptorImageInfo</span><span class="w"> </span><span class="n">imageInfo</span><span class="p">{{},</span><span class="w"> </span><span class="n">m_offscreenColor</span><span class="p">.</span><span class="n">descriptor</span><span class="p">.</span><span class="n">imageView</span><span class="p">,</span><span class="w"> </span><span class="n">VK_IMAGE_LAYOUT_GENERAL</span><span class="p">};</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkWriteDescriptorSet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">writes</span><span class="p">;</span>
<span class="w">  </span><span class="n">writes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">makeWrite</span><span class="p">(</span><span class="n">m_rtDescSet</span><span class="p">,</span><span class="w"> </span><span class="n">RtxBindings</span><span class="o">::</span><span class="n">eTlas</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">descASInfo</span><span class="p">));</span>
<span class="w">  </span><span class="n">writes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">makeWrite</span><span class="p">(</span><span class="n">m_rtDescSet</span><span class="p">,</span><span class="w"> </span><span class="n">RtxBindings</span><span class="o">::</span><span class="n">eOutImage</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imageInfo</span><span class="p">));</span>
<span class="w">  </span><span class="n">vkUpdateDescriptorSets</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">writes</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span><span class="w"> </span><span class="n">writes</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="additions-to-the-scene-descriptor-set">
<span id="id19"></span><h3>6.1 增加场景的描述符集<a class="headerlink" href="#additions-to-the-scene-descriptor-set" title="Link to this heading">#</a></h3>
<p>光线追踪同样也需要访问场景描述信息，我们需要通过修改 <code class="docutils literal notranslate"><span class="pre">createDescriptorSetLayout()</span></code> 函数将原先这些数据在支持光栅化着色器访问的同时支持光追着色器。光线生成着色器需要访问相机矩阵用于计算光线方向，最近命中着色器需要访问材质，场景的实体，纹理，顶点缓存和索引缓存。尽管顶点和索引缓存目前仅会被光追着色器使用，我们在原本光栅化着色器的基础上增加光追着色器也是符合标准的。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 相机矩阵</span>
<span class="n">m_descSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">SceneBindings</span><span class="o">::</span><span class="n">eGlobals</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                               </span><span class="n">VK_SHADER_STAGE_VERTEX_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="p">);</span>
<span class="c1">// 物体描述</span>
<span class="n">m_descSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">SceneBindings</span><span class="o">::</span><span class="n">eObjDescs</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                               </span><span class="n">VK_SHADER_STAGE_VERTEX_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_FRAGMENT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="p">);</span>
<span class="c1">// 纹理</span>
<span class="n">m_descSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">SceneBindings</span><span class="o">::</span><span class="n">eTextures</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</span><span class="p">,</span><span class="w"> </span><span class="n">nbTxt</span><span class="p">,</span>
<span class="w">                               </span><span class="n">VK_SHADER_STAGE_FRAGMENT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="p">);</span>
</pre></div>
</div>
<p>原本顶点缓存和索引缓存只在光栅化管线中使用，光追踪中这些缓存将会用于存储缓存，所以在分配缓存时设置支持存储功能。此外由于这些缓存将会被加速结构构建器所访问，这种访问需要获取到缓存的原始设备地址（在 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureGeometryTrianglesDataKHR</span></code> 中），所以创建该缓存时也需要附上 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</span></code> 功能位域。</p>
<p>我们通过更新 <code class="docutils literal notranslate"><span class="pre">loadModel</span></code> 中的缓存使用来达到此目的：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkBufferUsageFlags</span><span class="w"> </span><span class="n">flag</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span><span class="p">;</span>
<span class="n">VkBufferUsageFlags</span><span class="w"> </span><span class="n">rayTracingFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// 同样也用于构建加速结构</span>
<span class="w">    </span><span class="n">flag</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="p">;</span>
<span class="n">model</span><span class="p">.</span><span class="n">vertexBuffer</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">loader</span><span class="p">.</span><span class="n">m_vertices</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">rayTracingFlags</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">indexBuffer</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">loader</span><span class="p">.</span><span class="n">m_indices</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">rayTracingFlags</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">matColorBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">loader</span><span class="p">.</span><span class="n">m_materials</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flag</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">matIndexBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">loader</span><span class="p">.</span><span class="n">m_matIndx</span><span class="p">,</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flag</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">缓存数组</p>
<p>每一个模型（ <code class="docutils literal notranslate"><span class="pre">OBJ</span></code> ）都是由顶点、索引和材质缓存构成的。因此一个场景有一系列这样的缓存。在着色器中我们通过使用实体的 <code class="docutils literal notranslate"><span class="pre">ObjectID</span></code> 来获取到正确的缓存。
这对于光追来说很方便，我们可以以此来访问光追场景中的所有数据。</p>
</div>
</section>
<section id="id20">
<h3>6.2 描述符更新<a class="headerlink" href="#id20" title="Link to this heading">#</a></h3>
<p>和光栅化描述符集一样，光追描述符集也需要当内容放生改变时进行更新，特别是在窗口大小发生改变、输出图片发生了重新创建并且需要重新链接进描述符集。通过在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类
中增加一个新成员函数来达到更新描述符集的目的。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">updateRtDescriptorSet</span><span class="p">();</span>
</pre></div>
</div>
<p>该函数的实现非常直接，仅仅更新输出图片的引用：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 将输出图片更新到描述符集中</span>
<span class="c1">// - 当窗口分辨率发生了改变</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::updateRtDescriptorSet</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// (1) 设置输出纹理</span>
<span class="w">  </span><span class="n">VkDescriptorImageInfo</span><span class="w"> </span><span class="n">imageInfo</span><span class="p">{{},</span><span class="w"> </span><span class="n">m_offscreenColor</span><span class="p">.</span><span class="n">descriptor</span><span class="p">.</span><span class="n">imageView</span><span class="p">,</span><span class="w"> </span><span class="n">VK_IMAGE_LAYOUT_GENERAL</span><span class="p">};</span>
<span class="w">  </span><span class="n">VkWriteDescriptorSet</span><span class="w">  </span><span class="n">wds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">makeWrite</span><span class="p">(</span><span class="n">m_rtDescSet</span><span class="p">,</span><span class="w"> </span><span class="n">RtxBindings</span><span class="o">::</span><span class="n">eOutImage</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imageInfo</span><span class="p">);</span>
<span class="w">  </span><span class="n">vkUpdateDescriptorSets</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wds</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>我们使用 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/tree/master/nvvk#class-nvvkdescriptorsetbindings">nvvk::DescriptorSetBindings</a> 来辅助创建描述符集。这将会避免很多重复性代码和潜在错误。</p>
</div>
<p>之后在 <code class="docutils literal notranslate"><span class="pre">onResize</span></code> 函数（窗口大小发生了改变）中调用该更新函数</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">updateRtDescriptorSet</span><span class="p">();</span>
</pre></div>
</div>
<p>当程序被关闭时我们需要在 <code class="docutils literal notranslate"><span class="pre">destroyResources</span></code> 函数中销毁本章节创建的资源</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vkDestroyDescriptorPool</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtDescPool</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="n">vkDestroyDescriptorSetLayout</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtDescSetLayout</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id21">
<h3>6.3 main<a class="headerlink" href="#id21" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中，我们将在其他光追调用之后开始创建描述符集。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">helloVk</span><span class="p">.</span><span class="n">createRtDescriptorSet</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="id22">
<h2>7 光线追踪管线<a class="headerlink" href="#id22" title="Link to this heading">#</a></h2>
<p>就像前面说的，当进行光线追踪时，不能像光栅化那样，我们不能按照材质组织渲染，所以，所有的的着色器都必须在光追的任意时刻都是有效可执行的，并且具体哪个着色器在执行是在设备运行时动态确定的。
接下来两个章节最主要的目的就是介绍使用着色器绑定表（ <code class="docutils literal notranslate"><span class="pre">Shader</span> <span class="pre">Binding</span> <span class="pre">Table</span></code> 简称 <code class="docutils literal notranslate"><span class="pre">SBT</span></code>）：该结构使得运行时选择着色器成为可能。该结构的本质是着色器句柄表（也许存储着设备地址），有点
类似于 <code class="docutils literal notranslate"><span class="pre">C++</span></code> 的虚函数表，但是这张表是需要我们自己构建（用户也可以通过使用 <code class="docutils literal notranslate"><span class="pre">shaderRecordEXT</span></code> ，以此在着色器绑定表中携带更多信息），建表步骤如下：</p>
<ul class="simple">
<li><p>像平常一样将需要的着色器加载、编译到 <code class="docutils literal notranslate"><span class="pre">VkShaderModule</span></code> 中</p></li>
<li><p>将这些 <code class="docutils literal notranslate"><span class="pre">VkShaderModule</span></code> 打包到 <code class="docutils literal notranslate"><span class="pre">VkPipelineShaderStageCreateInfo</span></code> 数组中</p></li>
<li><p>创建一个 <code class="docutils literal notranslate"><span class="pre">VkRayTracingShaderGroupCreateInfoKHR</span></code> 数组，数组中的每一个 <code class="docutils literal notranslate"><span class="pre">VkRayTracingShaderGroupCreateInfoKHR</span></code> 最终都会成为一个着色器绑定表的入口。此时通过数组的索引从着色器组中区分各自的着色器，此时还没有分配设备内存地址。</p></li>
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">vkCreateRayTracingPipelineKHR</span></code> 将上述的两个数组编译成一个光线追踪管线</p></li>
<li><p>管线编译时会根据 <code class="docutils literal notranslate"><span class="pre">VkPipelineShaderStageCreateInfo</span></code> 数组的索引将对应的着色器句柄存入一个数组中。该数组可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetRayTracingShaderGroupHandlesKHR</span></code> 获取。</p></li>
<li><p>创建一个带有 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</span></code> 功能位域的缓存，并将句柄拷贝到该缓存中。</p></li>
</ul>
<p>相比于光栅化图形管线，光线追踪管线的行为更像计算着色器。光追的激发维度是在一个虚拟的长宽高三维空间中，追踪结果使用 <code class="docutils literal notranslate"><span class="pre">imageStore</span></code> 手动写入。与激发计算管线使用本地组（ <code class="docutils literal notranslate"><span class="pre">local</span> <span class="pre">group</span></code> ）不同，对于光追需要激发单独的着色器调用。光线追踪的入口为：</p>
<ul class="simple">
<li><p>光线生成着色器（ <code class="docutils literal notranslate"><span class="pre">ray</span> <span class="pre">generation</span> <span class="pre">shader</span></code> ），对于每一个像素我们都会调用光线生成着色器。这将会从相机的位置出发，以像素处按照相机镜头评估出一个光线方向。这之后将会调用 <code class="docutils literal notranslate"><span class="pre">traceRayEXT()</span></code> 函数往场景中发射光线。 <code class="docutils literal notranslate"><span class="pre">traceRayEXT()</span></code> 将会调用下文的各类着色器，这些着色器将会使用光追负载传达结果。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">光追负载</p>
<p>光追负载一般是指着色器中使用了 <code class="docutils literal notranslate"><span class="pre">rayPayloadEXT</span></code> 或 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 关键字声明的变量，相关介绍下文也有，这里给出一个示例。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">hitPayload</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">vec3</span><span class="w"> </span><span class="n">hitValue</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">rayPayloadInEXT</span><span class="w"> </span><span class="n">hitPayload</span><span class="w"> </span><span class="n">prd</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">rayPayloadEXT</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isShadowed</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>光追负载被声明作为 <code class="docutils literal notranslate"><span class="pre">rayPayloadEXT</span></code> 或 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 关键字的变量，同时其构成了着色器之间调用与被调用的关系。每一个着色器的执行都会将其
自身本地声明的 <code class="docutils literal notranslate"><span class="pre">rayPayloadEXT</span></code> 变量拷贝一份，当调用 <code class="docutils literal notranslate"><span class="pre">traceRayEXT()</span></code> 调用其他着色器时，调用者可以选择自身的其中一个负载，使得被调用着色器通
过 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 可以访问到调用者所分享的负载（ 多称为 <code class="docutils literal notranslate"><span class="pre">输入负载</span></code> ）。</p>
<p>负载需要明确声明，否则将会导致 <code class="docutils literal notranslate"><span class="pre">SM</span></code> 的并行占用率随着内存使用过多而降低。</p>
<div class="note admonition">
<p class="admonition-title">SM</p>
<p>这里的 <code class="docutils literal notranslate"><span class="pre">SM</span></code> 应该是指流式多处理器（ <code class="docutils literal notranslate"><span class="pre">Stream</span> <span class="pre">Multi-processor</span></code> ，简写为 <code class="docutils literal notranslate"><span class="pre">SM</span></code> ），是构建整个 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的核心模块，一个流式多处理器上一般同时运行多个线程块。每个流式多处理器可以视为具有较小结构的 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> ，支持指令并行。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">SM</span></code> 的占用率是越高越好</p>
</div></blockquote>
</div>
<p>接下来需要如下两个类型的的着色器：</p>
<ul class="simple">
<li><p>未命中着色器（ <code class="docutils literal notranslate"><span class="pre">miss</span> <span class="pre">shader</span></code> ），当没有与任何几何体相交时会调用该着色器。一般用于对环境纹理进行采样或者通过光追负载直接返回一个颜色。</p></li>
<li><p>最近命中着色器（ <code class="docutils literal notranslate"><span class="pre">closest</span> <span class="pre">hit</span> <span class="pre">shader</span></code> ），当光线与的几何体相交并且离光线起点最近时会调用该着色器。一般用于计算光照并使用光追负载返回结果。有多少最近相交就有多少最近命中着色器的调用，这与基于物体光栅化渲染时覆盖了多少像素概念相通。</p></li>
</ul>
<p>另外还有两个可选着色器类型：</p>
<ul class="simple">
<li><p>相交着色器（ <code class="docutils literal notranslate"><span class="pre">intersection</span> <span class="pre">shader</span></code> ），允许与用户与自定义几何体相交。比如为了按需加载几何体而与几何占位符相交，或者与程序化几何体相交而不需要提前进行细分。使用该着色器将会改变加速结构的构建策略，这一部分已经超出了本教程的范围。
目前我们仅采用该 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 光追扩展内置好的光线-三角相交测试，该测试将会返回 <code class="docutils literal notranslate"><span class="pre">2</span></code> 个浮点类型坐标值，用于表示位于三角形表面上相交点的 <code class="docutils literal notranslate"><span class="pre">(u,v)</span></code> 质心坐标（ <code class="docutils literal notranslate"><span class="pre">barycentric</span> <span class="pre">coordinates</span></code> ），对于一个由点 <code class="docutils literal notranslate"><span class="pre">v0</span></code> ， <code class="docutils literal notranslate"><span class="pre">v1</span></code> ， <code class="docutils literal notranslate"><span class="pre">v2</span></code> 构成的三角形，
质心坐标用于定义该交点相对于三角形三个顶点的权重：</p></li>
</ul>
<figure class="align-default">
<img alt="../../_images/barycentric_coordinates_weight.svg" src="../../_images/barycentric_coordinates_weight.svg" /></figure>
<div class="note admonition">
<p class="admonition-title">质心坐标与交点坐标</p>
<p>一般获取到质心坐标之后需要计算出所在三角形上的交点坐标，该交点坐标计算可参考如下：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="n">hitAttributeEXT</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">attribs</span><span class="p">;</span><span class="w"> </span><span class="c1">// 质心坐标</span>

<span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">barycentrics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// 计算质心权重</span>
<span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">z</span><span class="p">;</span><span class="w"> </span><span class="c1">// 计算交点坐标</span>
</pre></div>
</div>
</div>
<ul class="simple">
<li><p>任意命中着色器（ <code class="docutils literal notranslate"><span class="pre">any</span> <span class="pre">hit</span> <span class="pre">shader</span></code> ），在每一个可能的交点处执行。当查找与光线原点最近的交点的过程中可能会发现几个候选交点。任意命中着色器经常用于高效的透明测试，如果透明测试失败，光线可以继续遍历而不需要再次调用 <code class="docutils literal notranslate"><span class="pre">traceRayEXT()</span></code> ，内置的任意命中着色器
只是简单的将交点返回给遍历引擎，用于确定哪一个交点是最近的那一个交点。对于本教程，由于我们在构建加速结构时设置了不透明 <code class="docutils literal notranslate"><span class="pre">VK_GEOMETRY_OPAQUE_BIT_KHR</span></code> 位域（ <a class="reference internal" href="#bottom-level-acceleration-structure"><span class="std std-ref">5.1 底层加速结构</span></a> ），任意命中着色器将永远都不会调用。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">候选交点</p>
<p>根据 <a class="reference external" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap9.html#shaders-any-hit">Vulkan标准文档 9.19. Any-Hit Shaders</a> 中的说明，在相交着色器返回位于光路长度 [t <sub>min</sub>,t <sub>max</sub>] 之内的交点时将会执行任意命中着色器。换句话就是，当光线穿透几何体时
有可能会有多个交点。</p>
<p>任意命中着色器主要用于筛选相交着色器返回的交点的。</p>
</div>
<figure class="align-default" id="id44">
<img alt="../../_images/ShaderPipeline.svg" src="../../_images/ShaderPipeline.svg" /><figcaption>
<p><span class="caption-text">光线追踪管线</span><a class="headerlink" href="#id44" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>我们将从使用三个主要着色器开始：一个光线生成着色器，一个未命中着色器和由一个最近命中着色器构成的一个命中组。这在 <code class="docutils literal notranslate"><span class="pre">GLSL</span></code> 编译成 <code class="docutils literal notranslate"><span class="pre">SPIR-V</span></code> 时已经完成。 <code class="docutils literal notranslate"><span class="pre">SPIR-V</span></code> 的着色器们将会链接成一个能够通过求交计算执行正确的击中着色器的光线追踪管线。</p>
<p>为了专注于创建管线，我们提供了一些简单的着色器。</p>
<section id="id23">
<h3>7.1 增加着色器<a class="headerlink" href="#id23" title="Link to this heading">#</a></h3>
<div class="note admonition">
<p class="admonition-title">下载光线追踪着色器</p>
<p>将着色器下载下来并且解压到 <code class="docutils literal notranslate"><span class="pre">src/shaders</span></code> 。之后返回 <code class="docutils literal notranslate"><span class="pre">CMake</span></code> 中再次发布工程，相应的着色器文件将会增加到工程中。</p>
<div class="hint admonition">
<p class="admonition-title">着色器下载</p>
<p>在 <a class="reference internal" href="#environment-setup"><span class="std std-ref">2 配置环境</span></a> 章节中，通过 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">--recursive</span></code> 指令克隆的项目里已经自带着色器文件，不需要再另外单独下载。</p>
</div>
</div>
<p>目前 <code class="docutils literal notranslate"><span class="pre">shaders</span></code> 文件夹下与光追有关了的着色器文件有三种：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">raytrace.rgen</span></code> 包含光线生成程序。其同时也声明访问输出缓存 <code class="docutils literal notranslate"><span class="pre">image</span></code> 和绑定的 <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureKHR</span></code> 光追加速结构 <code class="docutils literal notranslate"><span class="pre">topLevelAS</span></code> 。对于此时该着色器仅仅向输出缓存中写入一个固定颜色。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">raytrace.rmiss</span></code> 用于定义未命中着色器。当没有几何体与光线相交时，该着色器将会被调用，并且会往光追负载 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 中写入一个固定颜色。由于我们目前的光线生成程序现在不会追踪任何光线，该未命中着色器将不会被调用。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">raytrace.rchit</span></code> 包含一个非常简单的最近命中着色器。其将在光线击中几何体（三角形）时被调用。与未命中着色器相同，其也会使用光追负载 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 。此外该着色器还有另外一个交点属性输入 <code class="docutils literal notranslate"><span class="pre">hitAttributeEXT</span></code> （ 也就是质心坐标 ）作为内置的光线-三角形相交测试结果。目前
该着色器仅仅往光追负载中写入一个固定颜色。</p></li>
</ul>
<p>在头文件中，增加用于构建光线追踪管线的函数，并且增加用于存储管线的成员变量：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w">                                              </span><span class="nf">createRtPipeline</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkRayTracingShaderGroupCreateInfoKHR</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_rtShaderGroups</span><span class="p">;</span>
<span class="n">VkPipelineLayout</span><span class="w">                                  </span><span class="n">m_rtPipelineLayout</span><span class="p">;</span>
<span class="n">VkPipeline</span><span class="w">                                        </span><span class="n">m_rtPipeline</span><span class="p">;</span>
</pre></div>
</div>
<p>管线同样也会使用常量推送（ <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">constants</span></code> ）存储全局变量，即背景颜色和光源信息。一旦我们在 <code class="docutils literal notranslate"><span class="pre">host</span></code> 端（ <code class="docutils literal notranslate"><span class="pre">CPU</span></code> ）设置了相关数据并在设备中使用，数据的结构声明在 <code class="docutils literal notranslate"><span class="pre">shaders/host_device.h</span></code> 文件中。</p>
<div class="note admonition">
<p class="admonition-title">常量推送</p>
<p>常量推送（ <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">constants</span></code> ），一般用于直接向着色器中推送数据，虽然叫常量推送，但每次推送的数据是可以变化的，该推送方式比传统的描述符集推送方便不少，但方便的代价是常量推送可推送的数据大小有限制（一般都比较小）。比如 <code class="docutils literal notranslate"><span class="pre">NVIDIA</span> <span class="pre">GeForce</span> <span class="pre">RTX</span> <span class="pre">3070</span></code> 桌面版的显卡设备支持的最大常量推送大小为 <code class="docutils literal notranslate"><span class="pre">256</span></code> 字节。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Push constant structure for the ray tracer</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">PushConstantRay</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">vec4</span><span class="w">  </span><span class="n">clearColor</span><span class="p">;</span>
<span class="w">  </span><span class="n">vec3</span><span class="w">  </span><span class="n">lightPosition</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">lightIntensity</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w">   </span><span class="n">lightType</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类中增加一个常量推送成员。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 用于光线追踪的常量推送</span>
<span class="n">PushConstantRay</span><span class="w"> </span><span class="n">m_pcRay</span><span class="p">{};</span>
</pre></div>
</div>
<p>我们实现光线追踪管线是先从光线生成着色器和未命中着色器开始，然后是最近命中着色器。注意，这个着色器顺序是我们自己定的，该 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 光追扩展其实在创建管线时设置的着色器顺序可以是随意的。光追着色器的概念是对光栅化管线着色器的延续，在光线追踪中也有类似光栅化着色器的执行顺序和彼此着色器间的数据流通。</p>
<p>所有的着色器都使用 <code class="docutils literal notranslate"><span class="pre">VkPipelineShaderStageCreateInfo</span></code> 类型组成的 <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> 数组存储。如前所属，此时，该着色器数组中的索引值将作为着色器的唯一标识。这三个着色器都会使用同样的 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数作为入口函数。之后使用 <code class="docutils literal notranslate"><span class="pre">vkCreateShaderModule</span></code> 从已经编译好着色器代码创建着色器句柄 <code class="docutils literal notranslate"><span class="pre">VkShaderModule</span></code> 并定义相关着色器阶段。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 光线追踪管线: 所有着色器, 光线生成着色器, 最近命中着色器, 未命中着色器</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::createRtPipeline</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="nc">StageIndices</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">eRaygen</span><span class="p">,</span>
<span class="w">    </span><span class="n">eMiss</span><span class="p">,</span>
<span class="w">    </span><span class="n">eClosestHit</span><span class="p">,</span>
<span class="w">    </span><span class="n">eShaderGroupCount</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// 所有的着色器</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">VkPipelineShaderStageCreateInfo</span><span class="p">,</span><span class="w"> </span><span class="n">eShaderGroupCount</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stages</span><span class="p">{};</span>
<span class="w">  </span><span class="n">VkPipelineShaderStageCreateInfo</span><span class="w">              </span><span class="n">stage</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</span><span class="p">};</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="n">pName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;main&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// 全都使用相同的入口函数</span>
<span class="w">  </span><span class="c1">// 光线生成着色器</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvvk</span><span class="o">::</span><span class="n">createShaderModule</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">loadFile</span><span class="p">(</span><span class="s">&quot;spv/raytrace.rgen.spv&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">defaultSearchPaths</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="n">stage</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">stages</span><span class="p">[</span><span class="n">eRaygen</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 未命中着色器</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvvk</span><span class="o">::</span><span class="n">createShaderModule</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">loadFile</span><span class="p">(</span><span class="s">&quot;spv/raytrace.rmiss.spv&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">defaultSearchPaths</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="n">stage</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_MISS_BIT_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">stages</span><span class="p">[</span><span class="n">eMiss</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 击中组 - 最近命中着色器</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvvk</span><span class="o">::</span><span class="n">createShaderModule</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">loadFile</span><span class="p">(</span><span class="s">&quot;spv/raytrace.rchit.spv&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">defaultSearchPaths</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span>
<span class="w">  </span><span class="n">stage</span><span class="p">.</span><span class="n">stage</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="p">;</span>
<span class="w">  </span><span class="n">stages</span><span class="p">[</span><span class="n">eClosestHit</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage</span><span class="p">;</span>
</pre></div>
</div>
<p>对应的索引标识将会使用 <code class="docutils literal notranslate"><span class="pre">VkRayTracingShaderGroupCreateInfoKHR</span></code> 结构体存储。该结构体第一个参数 <code class="docutils literal notranslate"><span class="pre">type</span></code> 用于表示本结构体中所代表的的着色器组的类型。光线
生成着色器和未命中着色器属于 <code class="docutils literal notranslate"><span class="pre">general</span></code> 着色器，对应的类型就是 <code class="docutils literal notranslate"><span class="pre">VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</span></code> ，并且之后仅设置该结构体的 <code class="docutils literal notranslate"><span class="pre">generalShader</span></code> 成员变量，其他成员
都设置成 <code class="docutils literal notranslate"><span class="pre">VK_SHADER_UNUSED_KHR</span></code> 。这种设置同样适用于可调用着色器（ <code class="docutils literal notranslate"><span class="pre">callable</span> <span class="pre">shaders</span></code> ），但是本教程并没有使用。在我们的布局下光线生成着色器在第一个（ <code class="docutils literal notranslate"><span class="pre">0</span></code> ），之后是未命中着色器（ <code class="docutils literal notranslate"><span class="pre">1</span></code> ）。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 着色器组</span>
<span class="n">VkRayTracingShaderGroupCreateInfoKHR</span><span class="w"> </span><span class="n">group</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR</span><span class="p">};</span>
<span class="n">group</span><span class="p">.</span><span class="n">anyHitShader</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_UNUSED_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">closestHitShader</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_UNUSED_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">generalShader</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_UNUSED_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">intersectionShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_UNUSED_KHR</span><span class="p">;</span>

<span class="c1">// 光线生成</span>
<span class="n">group</span><span class="p">.</span><span class="n">type</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">generalShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eRaygen</span><span class="p">;</span>
<span class="n">m_rtShaderGroups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>

<span class="c1">// 未命中</span>
<span class="n">group</span><span class="p">.</span><span class="n">type</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">generalShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eMiss</span><span class="p">;</span>
<span class="n">m_rtShaderGroups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</pre></div>
</div>
<p>如之前所述，求交是使用 <code class="docutils literal notranslate"><span class="pre">3</span></code> 个着色器配合完成：相交着色器用于计算光线与几何体的相交，之后任意命中着色器在每个候选的相交点上执行，并且最近命中着色器将会在光路上最近的相交点上执行。
这 <code class="docutils literal notranslate"><span class="pre">3</span></code> 个着色器将会合并到一个击中组中。在本示例中我们的几何体是使用三角形构成的，所以 <code class="docutils literal notranslate"><span class="pre">VkRayTracingShaderGroupCreateInfoKHR</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">type</span></code> 参数设置的是 <code class="docutils literal notranslate"><span class="pre">VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR</span></code> 。
我们一开始将 <code class="docutils literal notranslate"><span class="pre">generalShader</span></code> 设置成 <code class="docutils literal notranslate"><span class="pre">VK_SHADER_UNUSED_KHR</span></code>。之后我们将 <code class="docutils literal notranslate"><span class="pre">intersectionShader</span></code> 成员设置成 <code class="docutils literal notranslate"><span class="pre">VK_SHADER_UNUSED_KHR</span></code> 是应为我能使用硬件设备内置的光追算法代替相交着色器。我们不使用任意命中着色器，这样系统将会使用内置的交点筛选策略，所以
将 <code class="docutils literal notranslate"><span class="pre">anyHitShader</span></code> 设置成 <code class="docutils literal notranslate"><span class="pre">VK_SHADER_UNUSED_KHR</span></code> 。接下来我们使用的着色器就是最近命中着色器，通过将 <code class="docutils literal notranslate"><span class="pre">closestHitShader</span></code> 成员设置成索引值 <code class="docutils literal notranslate"><span class="pre">2</span></code> （ 最近命中着色器的索引 ），此时 <code class="docutils literal notranslate"><span class="pre">stages</span></code> 数组中已经包含光线生成着色器和未命中着色器。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 最近命中着色器</span>
<span class="n">group</span><span class="p">.</span><span class="n">type</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">generalShader</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_UNUSED_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">closestHitShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eClosestHit</span><span class="p">;</span>
<span class="n">m_rtShaderGroups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果几何数据不是三角形，我们需要将 <code class="docutils literal notranslate"><span class="pre">type</span></code> 设置成 <code class="docutils literal notranslate"><span class="pre">VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR</span></code> ，并且需要自定义一个相交着色器。</p>
</div>
<p>在创建着色器组之后，我们需要通过管线布局（ <code class="docutils literal notranslate"><span class="pre">pipeline</span> <span class="pre">layout</span></code> ）来描述管线如何与外部数据交互：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPipelineLayoutCreateInfo</span><span class="w"> </span><span class="n">pipelineLayoutCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<p>首先在布局中增加用于光线追踪着色器的全局数据常量推送：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 常量推送: 我们希望能够更新着色器使用的常量</span>
<span class="n">VkPushConstantRange</span><span class="w"> </span><span class="n">pushConstant</span><span class="p">{</span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_MISS_BIT_KHR</span><span class="p">,</span>
<span class="w">                                 </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PushConstantRay</span><span class="p">)};</span>


<span class="n">VkPipelineLayoutCreateInfo</span><span class="w"> </span><span class="n">pipelineLayoutCreateInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</span><span class="p">};</span>
<span class="n">pipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pushConstantRangeCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">pipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pPushConstantRanges</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pushConstant</span><span class="p">;</span>
</pre></div>
</div>
<p>如前述所言，管线使用两个描述符集： <code class="docutils literal notranslate"><span class="pre">set=0</span></code> 用于光追管线（ 顶层加速结构和输出图片 ）， <code class="docutils literal notranslate"><span class="pre">set=1</span></code> 用于与光栅化分享数据（场景数据）。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 描述符集: 一个用于光追, 另一个与光栅化管线分享数据</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkDescriptorSetLayout</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rtDescSetLayouts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">m_rtDescSetLayout</span><span class="p">,</span><span class="w"> </span><span class="n">m_descSetLayout</span><span class="p">};</span>
<span class="n">pipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">setLayoutCount</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rtDescSetLayouts</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">pipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pSetLayouts</span><span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="n">rtDescSetLayouts</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</pre></div>
</div>
<p>现在管线布局信息已经完成，之后就可以创建布局本身了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vkCreatePipelineLayout</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pipelineLayoutCreateInfo</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_rtPipelineLayout</span><span class="p">);</span>
</pre></div>
</div>
<p>光追管线的创建是不同于经典的（光栅化）图形管线的。在图形管线中我们仅需要简单的将几个可编程阶段（顶点着色器，片元着色器等）塞入管线中即可。而在光追管线中根据场景中激活的着色器数量，光追管线可以包含任意数量的
着色器。</p>
<p>首先我们需要提供所有要使用的着色器：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 将着色器和递归深度信息存储到光追管线中</span>
<span class="n">VkRayTracingPipelineCreateInfoKHR</span><span class="w"> </span><span class="n">rayPipelineInfo</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR</span><span class="p">};</span>
<span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">stageCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">stages</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w">  </span><span class="c1">// Stages are shaders</span>
<span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">pStages</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">stages</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</pre></div>
</div>
<p>之后，我们指引驱动如何将着色器装配成组。一个光线生成着色器或未命中着色器可以自身成组，但是命中组可以由相交着色器、任意命中着色器和最近命中着色器这 <code class="docutils literal notranslate"><span class="pre">3</span></code> 种着色器组成。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 当前示例下， m_rtShaderGroups.size() == 3: 我们有一个光线生成着色器组，</span>
<span class="c1">// 一个未命中着色器组，和一个最近命中着色器组。</span>
<span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">groupCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_rtShaderGroups</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">pGroups</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtShaderGroups</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</pre></div>
</div>
<p>光线生成着色器和最近命中着色器可以进行光线追踪，使光线追踪成为一个潜在的递归过程。为了底层的 <code class="docutils literal notranslate"><span class="pre">RTX</span></code> 层能够优化管线我们设置了着色器中最大的递归深度。我们当前的着色器都非常的简单，我们设置递归深度为 <code class="docutils literal notranslate"><span class="pre">1</span></code> ，意味着
我们不会进行光追递归（ 即最近命中着色器调用 <code class="docutils literal notranslate"><span class="pre">TraceRayEXT()</span></code> 函数 ）。注意，请尽量保持递归深度为最小深度，代之以一个循环函数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">maxPipelineRayRecursionDepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Ray depth</span>
<span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">layout</span><span class="w">                       </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtPipelineLayout</span><span class="p">;</span>

<span class="n">vkCreateRayTracingPipelinesKHR</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rayPipelineInfo</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_rtPipeline</span><span class="p">);</span>
</pre></div>
</div>
<p>一旦管线创建完成，我们就可以销毁支持创建的着色器句柄了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">stages</span><span class="p">)</span>
<span class="w">    </span><span class="n">vkDestroyShaderModule</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于管线布局和管线本身将会在程序关闭时销毁回收，因此增加如下代码到 <code class="docutils literal notranslate"><span class="pre">destroyResources</span></code> 函数中：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vkDestroyPipeline</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtPipeline</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="n">vkDestroyPipelineLayout</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtPipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id24">
<h3>7.2 main<a class="headerlink" href="#id24" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中，在其他光追函数调用完成之后我们调用管线创建函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">helloVk</span><span class="p">.</span><span class="n">createRtPipeline</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="id25">
<h2>8 着色器绑定表<a class="headerlink" href="#id25" title="Link to this heading">#</a></h2>
<p>在经典的光栅化渲染中，着色器和相应的资源是在绘制具体物体之前就已经绑定好了，之后，其他物体渲染绑定其他着色器和资源，如此这般。但是光线追踪在任意时刻都会与场景中的任意表面相交，此时需要所有的着色器时时刻刻保持有效可用。</p>
<p>着色器绑定表（ <code class="docutils literal notranslate"><span class="pre">Shader</span> <span class="pre">Binding</span> <span class="pre">Table</span></code> ，简称 <code class="docutils literal notranslate"><span class="pre">SBT</span></code> ）就是光追的“蓝图”。其允许我们选择哪一个光线生成着色器作为入口，选择哪一个未命中着色器在未发生相交时执行，选择哪一个命中着色器组可在每一个实体上执行。这涉及到当创建几何体时创建的实体和着色器组：
对于每一个顶层加速结构中的每一个实体所对应的 <code class="docutils literal notranslate"><span class="pre">hitGroupId</span></code> ，该值用于计算命中组中实体相对应着色器绑定表的索引。这需要每一个条目跨度计算基于：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleSize</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shaderRecordEXT</span></code> 数据的大小，如果用户有提供。（目前示例中不需要）</p></li>
</ul>
<section id="id26">
<h3>8.1 句柄<a class="headerlink" href="#id26" title="Link to this heading">#</a></h3>
<p>着色器绑定表是最多四个数组的集合，用于存储光线追踪管线着色器组句柄，分别对应：管线生成着色器组，未命中着色器组，最近命中着色器组合和可调用着色器组。在本示例中我们将创建一个缓存用于存储前三组数组。就目前，每个着色器类型我们只有一个着色器，所以每个数组中只有一个句柄组成着色器组。</p>
<p>缓存的结构如下所示，之后将会在调用 <code class="docutils literal notranslate"><span class="pre">vkCmdTraceRaysKHR</span></code> 时使用。</p>
<img alt="../../_images/sbt_0.png" class="align-center" src="../../_images/sbt_0.png" />
<p>我们需要确保所有组的开头地址都与 <code class="docutils literal notranslate"><span class="pre">shaderGroupBaseAlignment</span></code> 进行内存对齐，并且组内的每一个元素与 <code class="docutils literal notranslate"><span class="pre">shaderGroupHandleAlignment</span></code> 进行内存对其。所有组的元素都与 <code class="docutils literal notranslate"><span class="pre">shaderGroupHandleAlignment</span></code> 进行对其。</p>
<div class="warning admonition">
<p class="admonition-title">内存大小和对齐</p>
<p>特别注意对齐大小和句柄或组大小相对应的。句柄或组大小相应的对齐并不保证一定正确，所以需要向上取整。使用 <code class="docutils literal notranslate"><span class="pre">groupHandleSize</span></code> 作为内存跨度也许碰巧能够在您的设备上工作，其他设备就不一定了。在一些设备上句柄大小小于对齐大小时，当没有设置相关的内存使用策略将会导致着色器存储（ <a href="#id27"><span class="problematic" id="id28">``</span></a>shaderRecordEXT `` ）的数据重叠错位。</p>
<p>向上取整获取下一个对齐位置使用如下算法：</p>
<p><span class="math notranslate nohighlight">\(alignedSize = [size + (alignment - 1)]\ \texttt{&amp;}\ \texttt{~}(alignment - 1)\)</span>.</p>
</div>
<div class="note admonition">
<p class="admonition-title">特例</p>
<p>光线生成着色器组（ <code class="docutils literal notranslate"><span class="pre">RayGen</span></code> ）的大小和跨度需要相等。</p>
</div>
<p>首先我们在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan</span></code> 类中增加对于着色器绑定表的创建的函数和缓存的相关声明：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w">           </span><span class="nf">createRtShaderBindingTable</span><span class="p">();</span>

<span class="n">nvvk</span><span class="o">::</span><span class="n">Buffer</span><span class="w">                    </span><span class="n">m_rtSBTBuffer</span><span class="p">;</span>
<span class="n">VkStridedDeviceAddressRegionKHR</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">{};</span>
<span class="n">VkStridedDeviceAddressRegionKHR</span><span class="w"> </span><span class="n">m_missRegion</span><span class="p">{};</span>
<span class="n">VkStridedDeviceAddressRegionKHR</span><span class="w"> </span><span class="n">m_hitRegion</span><span class="p">{};</span>
<span class="n">VkStridedDeviceAddressRegionKHR</span><span class="w"> </span><span class="n">m_callRegion</span><span class="p">{};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">createRtShaderBindingTable()</span></code> 一开始我们收集组相关的信息。对于光线生成着色器总是 <code class="docutils literal notranslate"><span class="pre">1</span></code> 个也只能是 <code class="docutils literal notranslate"><span class="pre">1</span></code> 个，所以我们加了一个常数 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 着色器绑定表 (SBT)</span>
<span class="c1">// - 获取所有的着色器句柄并将其写入着色器绑定表缓存中</span>
<span class="c1">// - 除了例外，你总可以像如下代码所示使用。</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::createRtShaderBindingTable</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">missCount</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hitCount</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">  </span><span class="k">auto</span><span class="w">     </span><span class="n">handleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">missCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hitCount</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">handleSize</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">m_rtProperties</span><span class="p">.</span><span class="n">shaderGroupHandleSize</span><span class="p">;</span>
</pre></div>
</div>
<p>之后设置每个组的跨度和大小。除了光线生成组，跨度大小是句柄与 <code class="docutils literal notranslate"><span class="pre">shaderGroupHandleAlignment</span></code> 对齐的大小。每一个组的大小是元素数量与 <code class="docutils literal notranslate"><span class="pre">shaderGroupBaseAlignment</span></code> 对齐的结果。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 着色器绑定表 (缓存) 需要开头的组已经完成对齐并且组中的句柄也已经对齐完成。</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">handleSizeAligned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">align_up</span><span class="p">(</span><span class="n">handleSize</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtProperties</span><span class="p">.</span><span class="n">shaderGroupHandleAlignment</span><span class="p">);</span>

<span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">align_up</span><span class="p">(</span><span class="n">handleSizeAligned</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtProperties</span><span class="p">.</span><span class="n">shaderGroupBaseAlignment</span><span class="p">);</span>
<span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">stride</span><span class="p">;</span><span class="w">  </span><span class="c1">// pRayGenShaderBindingTable的size成员大小必须与stride（跨度）成员大小相等</span>
<span class="n">m_missRegion</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handleSizeAligned</span><span class="p">;</span>
<span class="n">m_missRegion</span><span class="p">.</span><span class="n">size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">align_up</span><span class="p">(</span><span class="n">missCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">handleSizeAligned</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtProperties</span><span class="p">.</span><span class="n">shaderGroupBaseAlignment</span><span class="p">);</span>
<span class="n">m_hitRegion</span><span class="p">.</span><span class="n">stride</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">handleSizeAligned</span><span class="p">;</span>
<span class="n">m_hitRegion</span><span class="p">.</span><span class="n">size</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">align_up</span><span class="p">(</span><span class="n">hitCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">handleSizeAligned</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtProperties</span><span class="p">.</span><span class="n">shaderGroupBaseAlignment</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">pRayGenShaderBindingTable</p>
<p>指的是 <code class="docutils literal notranslate"><span class="pre">vkCmdTraceRaysKHR</span></code> 函数中的 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">VkStridedDeviceAddressRegionKHR*</span> <span class="pre">pRaygenShaderBindingTable</span></code> 成员：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由VK_KHR_ray_tracing_pipeline提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkCmdTraceRaysKHR</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkCommandBuffer</span><span class="w">                             </span><span class="n">commandBuffer</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkStridedDeviceAddressRegionKHR</span><span class="o">*</span><span class="w">      </span><span class="n">pRaygenShaderBindingTable</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkStridedDeviceAddressRegionKHR</span><span class="o">*</span><span class="w">      </span><span class="n">pMissShaderBindingTable</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkStridedDeviceAddressRegionKHR</span><span class="o">*</span><span class="w">      </span><span class="n">pHitShaderBindingTable</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkStridedDeviceAddressRegionKHR</span><span class="o">*</span><span class="w">      </span><span class="n">pCallableShaderBindingTable</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">width</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">height</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">depth</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>之后获取光追管线中的着色器组句柄。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 获取着色器组的句柄</span>
<span class="kt">uint32_t</span><span class="w">             </span><span class="n">dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handleCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">handleSize</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">handles</span><span class="p">(</span><span class="n">dataSize</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkGetRayTracingShaderGroupHandlesKHR</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtPipeline</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">handleCount</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">,</span><span class="w"> </span><span class="n">handles</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">);</span>
</pre></div>
</div>
<p>之后分配一个缓存用于存储句柄数据。注意，创建着色器绑定表缓存需要 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</span></code> 位域。为了追踪光线我们需要着色器绑定表的地址，这需要 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span></code> 位域。
目前我们没有使用可调用着色器，其值应该为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p>
<div class="note admonition">
<p class="admonition-title">其值应该为 <code class="docutils literal notranslate"><span class="pre">0</span></code></p>
<p>指的是如下代码中 <code class="docutils literal notranslate"><span class="pre">m_callRegion.size</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 分配用于存储着色器绑定表的缓存.</span>
<span class="n">VkDeviceSize</span><span class="w"> </span><span class="n">sbtSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_missRegion</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_hitRegion</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_callRegion</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="n">m_rtSBTBuffer</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">createBuffer</span><span class="p">(</span><span class="n">sbtSize</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</span>
<span class="w">                                         </span><span class="o">|</span><span class="w"> </span><span class="n">VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">);</span>
<span class="n">m_debug</span><span class="p">.</span><span class="n">setObjectName</span><span class="p">(</span><span class="n">m_rtSBTBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;SBT&quot;</span><span class="p">));</span><span class="w">  </span><span class="c1">// NSight中设置一个调试名称</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">NSight</p>
<p>是 <code class="docutils literal notranslate"><span class="pre">NVIDIA</span></code> 推出的一款 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 图形计算调试分析工具。和 <code class="docutils literal notranslate"><span class="pre">RenderDoc</span></code> 属于同级别工具。</p>
</div>
<p>接下来，我们获取每一个着色器组的设备地址并存储。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 获取每组的着色器绑定表</span>
<span class="n">VkBufferDeviceAddressInfo</span><span class="w"> </span><span class="n">info</span><span class="p">{</span><span class="n">VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtSBTBuffer</span><span class="p">.</span><span class="n">buffer</span><span class="p">};</span>
<span class="n">VkDeviceAddress</span><span class="w">           </span><span class="n">sbtAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkGetBufferDeviceAddress</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">sbtAddress</span><span class="p">;</span>
<span class="n">m_missRegion</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">sbtAddress</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="n">m_hitRegion</span><span class="p">.</span><span class="n">deviceAddress</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">sbtAddress</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_missRegion</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</pre></div>
</div>
<p>如下 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 表达式将会返回之前获取到的句柄指针。该函数在将句柄数据拷贝至着色器绑定表中使用。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 用于帮助获取句柄数据</span>
<span class="k">auto</span><span class="w"> </span><span class="n">getHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">handles</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">handleSize</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>由于我们的着色器绑定表缓存在 <code class="docutils literal notranslate"><span class="pre">host</span></code> 端是可访问的，我们将其内存映射出来用于数据拷贝。</p>
<div class="note admonition">
<p class="admonition-title">在 <code class="docutils literal notranslate"><span class="pre">host</span></code> 端是可访问</p>
<p>在创建 <code class="docutils literal notranslate"><span class="pre">m_rtSBTBuffer</span></code> 着色器绑定表缓存时指定了创建支持 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span></code> 功能的内存。这样该缓存在 <code class="docutils literal notranslate"><span class="pre">host</span></code> 端（一般指 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 端）可以进行读写访问。访问的途径是通过内存映射进行（ <code class="docutils literal notranslate"><span class="pre">m_alloc.map()</span></code> 其内部最终会调用 <code class="docutils literal notranslate"><span class="pre">vkMapMemory()</span></code> 内存映射函数）。</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 将着色器绑定表缓存映射出来并写入句柄数据</span>
<span class="k">auto</span><span class="o">*</span><span class="w">    </span><span class="n">pSBTBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m_alloc</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">m_rtSBTBuffer</span><span class="p">));</span>
<span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pData</span><span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">handleIdx</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
<p>拷贝光线着色器句柄。即使数据跨度和大小都比较大，我们也只拷贝句柄数据。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 光线着色器句柄</span>
<span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pSBTBuffer</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="n">getHandle</span><span class="p">(</span><span class="n">handleIdx</span><span class="o">++</span><span class="p">),</span><span class="w"> </span><span class="n">handleSize</span><span class="p">);</span>
</pre></div>
</div>
<p>将拷贝起始位置定位到未命中着色器组的开头并拷贝所有的未命中着色器句柄，我们目前只有一个，但此时的循环可以支持我们增加多个未命中着色器。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 未命中着色器</span>
<span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pSBTBuffer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">missCount</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="n">getHandle</span><span class="p">(</span><span class="n">handleIdx</span><span class="o">++</span><span class="p">),</span><span class="w"> </span><span class="n">handleSize</span><span class="p">);</span>
<span class="w">  </span><span class="n">pData</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">m_missRegion</span><span class="p">.</span><span class="n">stride</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同样的方式，拷贝最近命中着色器组中的句柄。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 最近命中着色器</span>
<span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pSBTBuffer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_rgenRegion</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_missRegion</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">hitCount</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="n">getHandle</span><span class="p">(</span><span class="n">handleIdx</span><span class="o">++</span><span class="p">),</span><span class="w"> </span><span class="n">handleSize</span><span class="p">);</span>
<span class="w">  </span><span class="n">pData</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">m_hitRegion</span><span class="p">.</span><span class="n">stride</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后回收内存和释放临时资源。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">unmap</span><span class="p">(</span><span class="n">m_rtSBTBuffer</span><span class="p">);</span>
<span class="w">  </span><span class="n">m_alloc</span><span class="p">.</span><span class="n">finalizeAndReleaseStaging</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>和其他资源销毁一样，我们在 <code class="docutils literal notranslate"><span class="pre">destroyResources</span></code> 增加对取着色器绑定表资源的销毁：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">m_alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">m_rtSBTBuffer</span><span class="p">);</span>
</pre></div>
</div>
<div class="tip admonition">
<p class="admonition-title">着色器顺序</p>
<p>没有要求说着色器必须以光线生成着色器、未命中着色器和最近命中着色器的顺序。就目前而言我们也没有必要非要改变顺序，我们构建的着色器绑定表中对应的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 号元素、 <code class="docutils literal notranslate"><span class="pre">1</span></code> 号元素和 <code class="docutils literal notranslate"><span class="pre">2</span></code> 号元素与构建管线时设置的
<code class="docutils literal notranslate"><span class="pre">VkPipelineShaderStageCreateInfo</span></code> 数组中的的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 号元素、 <code class="docutils literal notranslate"><span class="pre">1</span></code> 号元素和 <code class="docutils literal notranslate"><span class="pre">2</span></code> 号元素相对应。一般来说，着色器绑定表中和顺序并不需要与管线中的着色器顺序相对应。</p>
</div>
<div class="tip admonition">
<p class="admonition-title">着色器绑定表的封装</p>
<p>每个组中的元素都可以通过 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceRayTracingPipelinePropertiesKHR</span></code> 中的数据获得，使用这个结构体中的数据获取信息的好处就是我们不再需要按照指定的顺序获取。其原因已超出本教程的范围，但是我们提供了一个封装类用于将之前的流程自动化。
可以到 <a class="reference external" href="https://github.com/nvpro-samples/nvpro_core/tree/master/nvvk#sbtwrapper_vkhpp">nnvk::SBTWrapper</a> 中找到实现。一些额外的示例将会使用该类。</p>
</div>
</section>
<section id="id29">
<h3>8.2 main<a class="headerlink" href="#id29" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中，现在增加着色器绑定表的构建函数调用。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">helloVk</span><span class="p">.</span><span class="n">createRtShaderBindingTable</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="id30">
<h2>9 光线追踪<a class="headerlink" href="#id30" title="Link to this heading">#</a></h2>
<p>创建一个记录调用光追着色器的指令函数。首先，头文件中增加如下声明：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">raytrace</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandBuffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec4f</span><span class="o">&amp;</span><span class="w"> </span><span class="n">clearColor</span><span class="p">);</span>
</pre></div>
</div>
<p>我们首先绑定管线和相应的管线布局，设置常量推送：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--------------------------------------------------------------------------------------------------</span>
<span class="c1">// 对场景进行光线追踪</span>
<span class="c1">//</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HelloVulkan::raytrace</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandBuffer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec4f</span><span class="o">&amp;</span><span class="w"> </span><span class="n">clearColor</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">m_debug</span><span class="p">.</span><span class="n">beginLabel</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ray trace&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// 初始化常量推送数据</span>
<span class="w">  </span><span class="n">m_pcRay</span><span class="p">.</span><span class="n">clearColor</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">clearColor</span><span class="p">;</span>
<span class="w">  </span><span class="n">m_pcRay</span><span class="p">.</span><span class="n">lightPosition</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">m_pcRaster</span><span class="p">.</span><span class="n">lightPosition</span><span class="p">;</span>
<span class="w">  </span><span class="n">m_pcRay</span><span class="p">.</span><span class="n">lightIntensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_pcRaster</span><span class="p">.</span><span class="n">lightIntensity</span><span class="p">;</span>
<span class="w">  </span><span class="n">m_pcRay</span><span class="p">.</span><span class="n">lightType</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m_pcRaster</span><span class="p">.</span><span class="n">lightType</span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkDescriptorSet</span><span class="o">&gt;</span><span class="w"> </span><span class="n">descSets</span><span class="p">{</span><span class="n">m_rtDescSet</span><span class="p">,</span><span class="w"> </span><span class="n">m_descSet</span><span class="p">};</span>
<span class="w">  </span><span class="n">vkCmdBindPipeline</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtPipeline</span><span class="p">);</span>
<span class="w">  </span><span class="n">vkCmdBindDescriptorSets</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtPipelineLayout</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                          </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">descSets</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">descSets</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="n">vkCmdPushConstants</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">m_rtPipelineLayout</span><span class="p">,</span>
<span class="w">                     </span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_MISS_BIT_KHR</span><span class="p">,</span>
<span class="w">                     </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PushConstantRay</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_pcRay</span><span class="p">);</span>
</pre></div>
</div>
<p>幸好，所有与 <code class="docutils literal notranslate"><span class="pre">VkStridedDeviceAddressRegionKHR</span></code> 有关的数据都已在 <code class="docutils literal notranslate"><span class="pre">createRtShaderBindingTable()</span></code> 中创建完成了。</p>
<p>我们终于可以在指令缓存中增加 <code class="docutils literal notranslate"><span class="pre">vkCmdTraceRaysKHR</span></code> 指令用于激发光线追踪。注意着色器绑定表缓存的地址已经多次提及。这是因为可以将一个着色器绑定表分开存放到多个缓存中，每种类型对应一个缓存：光线生成着色器，未命中着色器，最近命中着色器和可调用着色器（如何拆分已然超出了本教程的范围）。最后面的三个参数等效于激发计算管线的纬度大小，并表示线程的总数。我们希望每一个像素追踪一根射线，激发纬度设置了输出图片的的宽、高和深度值 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">vkCmdTraceRaysKHR</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_rgenRegion</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_missRegion</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_hitRegion</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_callRegion</span><span class="p">,</span><span class="w"> </span><span class="n">m_size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">m_size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">m_debug</span><span class="p">.</span><span class="n">endLabel</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="tip admonition">
<p class="admonition-title">选择光线生成着色器</p>
<p>如果你构建的管线中有多个光线生成着色器，则可通过改变设备地址来选择具体的光线生成着色器。</p>
</div>
<div class="tip admonition">
<p class="admonition-title">SBTWrapper</p>
<p>如果使用 <code class="docutils literal notranslate"><span class="pre">SBTWrapper</span></code> 的话，上面得代码可以替换如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_stbWrapper</span><span class="p">.</span><span class="n">getRegions</span><span class="p">();</span>
<span class="n">vkCmdTraceRaysKHR</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">regions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">regions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">regions</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div>
</section>
<section id="id31">
<h2>10 开始追踪<a class="headerlink" href="#id31" title="Link to this heading">#</a></h2>
<p>现在我们已经完成了光线追踪的所有前置设置和构建：加速结构，描述符集，光追管线和着色器绑定表。现在尝试生成渲染图片吧。</p>
<section id="id32">
<h3>10.1 main<a class="headerlink" href="#id32" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中，我们将定义一个用于在光栅化和光线追踪之间切换的本地变量。在光线追踪初始化之后增加如下代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">useRaytracer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</pre></div>
</div>
<p>在同一函数中，在界面上增加一个复选框，用于运行时进行切换。在 <code class="docutils literal notranslate"><span class="pre">ImGui::ColorEdit3()</span></code> 之后我们增加：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ImGui</span><span class="o">::</span><span class="n">Checkbox</span><span class="p">(</span><span class="s">&quot;Ray Tracer mode&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">useRaytracer</span><span class="p">);</span><span class="w"> </span><span class="c1">// 光栅化和光线追踪之间进行切换</span>
</pre></div>
</div>
<p>代码往下找，你可以找到一个包含 <code class="docutils literal notranslate"><span class="pre">helloVk.rasterize()</span></code> 调用的代码块。我们的应用将支持两种渲染模式，所以将代码块替换成如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 渲染场景</span>
<span class="k">if</span><span class="p">(</span><span class="n">useRaytracer</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">helloVk</span><span class="p">.</span><span class="n">raytrace</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">clearColor</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">vkCmdBeginRenderPass</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offscreenRenderPassBeginInfo</span><span class="p">,</span><span class="w"> </span><span class="n">VK_SUBPASS_CONTENTS_INLINE</span><span class="p">);</span>
<span class="w">  </span><span class="n">helloVk</span><span class="p">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">);</span>
<span class="w">  </span><span class="n">vkCmdEndRenderPass</span><span class="p">(</span><span class="n">cmdBuf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>光线追踪的行为相较于传统的图形渲染任务更像是个基于计算着色器的计算管线，并且不依赖渲染通道（ <code class="docutils literal notranslate"><span class="pre">render</span> <span class="pre">pass</span></code> ）。</p>
</div>
<p>我们现在可以在光栅化和光线追踪之间切换了。然后现在光线追踪的渲染结果仅仅渲染一个灰色图片：最简单的光线生成着色器现在还没有追踪任何光线，所以仅仅返回一个固定颜色。</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>光栅化</p></th>
<th class="head"></th>
<th class="head"><p>光线追踪</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><img alt="../../_images/resultRasterCube.png" src="../../_images/resultRasterCube.png" />
</td>
<td><p>↔</p></td>
<td><img alt="../../_images/resultRaytraceEmptyCube.png" src="../../_images/resultRaytraceEmptyCube.png" />
</td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="id33">
<h2>11 相机矩阵<a class="headerlink" href="#id33" title="Link to this heading">#</a></h2>
<p>相机矩阵存储在一个 <code class="docutils literal notranslate"><span class="pre">uniform</span></code> 缓存中并使用 <code class="docutils literal notranslate"><span class="pre">updateUniformBuffer</span></code> 更新。光线追踪同样会使用该矩阵，所有我们需要将该缓存适配到光追着色器中。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">uboUsageStages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR</span><span class="p">;</span>
</pre></div>
</div>
<section id="raytrace-rgen">
<h3>11.1 光线生成（ <code class="docutils literal notranslate"><span class="pre">raytrace.rgen</span></code> ）<a class="headerlink" href="#raytrace-rgen" title="Link to this heading">#</a></h3>
<p>在着色器中我们需要引入外部头文件，所有需要支持 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 指令的 <code class="docutils literal notranslate"><span class="pre">GLSL</span></code> 扩展，在着色器中增加如下：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="cp">#extension GL_GOOGLE_include_directive : enable</span>
</pre></div>
</div>
<p>现在是时候丰富光线生成着色器使其可以追踪光线。我们首先在着色器中增加一个 <code class="docutils literal notranslate"><span class="pre">binding</span></code> 资源绑定声明，这样着色器就可以访问相机矩阵了。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="cp">#include &quot;host_device.h&quot;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eGlobals</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">_GlobalUniforms</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">GlobalUniforms</span><span class="w"> </span><span class="n">uni</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">Binding</p>
<p>相机缓存之所以绑定在 <code class="docutils literal notranslate"><span class="pre">binding</span> <span class="pre">=</span> <span class="pre">eGlobals</span></code> 的位置是与 <code class="docutils literal notranslate"><span class="pre">host_device.h</span></code> 中声明的绑定位置相对应，其中 <code class="docutils literal notranslate"><span class="pre">eGlobals</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，对于 <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">=</span> <span class="pre">1</span></code> 是因为在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan::createRtPipeline()</span></code> 中为第二个 <code class="docutils literal notranslate"><span class="pre">pipelineLayoutCreateInfo.pSetLayouts</span></code> 描述符集（用于光追资源绑定），对应的索引值为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="c1">// host_device.h 中</span>
<span class="cp">#define START_BINDING(a) enum a {</span>
<span class="cp">#define END_BINDING() }</span>

<span class="n">START_BINDING</span><span class="p">(</span><span class="n">SceneBindings</span><span class="p">)</span>
<span class="w">  </span><span class="n">eGlobals</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// 全局uniform包含相机矩阵</span>
<span class="w">  </span><span class="n">eObjDescs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// 访问物体描述</span>
<span class="w">  </span><span class="n">eTextures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">   </span><span class="c1">// 访问纹理</span>
<span class="n">END_BINDING</span><span class="p">();</span>

<span class="c1">// 用于每一帧的uniform缓存</span>
<span class="k">struct</span><span class="w"> </span><span class="n">GlobalUniforms</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">mat4</span><span class="w"> </span><span class="n">viewProj</span><span class="p">;</span><span class="w">     </span><span class="c1">// 相机 view * projection</span>
<span class="w">  </span><span class="kt">mat4</span><span class="w"> </span><span class="n">viewInverse</span><span class="p">;</span><span class="w">  </span><span class="c1">// 相机view矩阵的逆矩阵</span>
<span class="w">  </span><span class="kt">mat4</span><span class="w"> </span><span class="n">projInverse</span><span class="p">;</span><span class="w">  </span><span class="c1">// 相机projection矩阵的逆矩阵</span>
<span class="p">};</span>

<span class="c1">// raytrace.rgen 中</span>
<span class="k">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eGlobals</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">_GlobalUniforms</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">GlobalUniforms</span><span class="w"> </span><span class="n">uni</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
</div>
<p>当追踪一条光线时，最近命中着色器或未命中着色器需要返回一些信息给着色器程序用于对一条新的光线激发光线追踪。这是用过使用 <code class="docutils literal notranslate"><span class="pre">rayPayloadEXT</span></code> 关键字声明光追负载实现的。</p>
<p>由于该负载会被很多着色器使用，我们创建一个通用着色器文件 <code class="docutils literal notranslate"><span class="pre">raycommon.glsl</span></code> 用于声明通用数据。</p>
<p>该文件仅仅包括一个负载定义：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">hitPayload</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w"> </span><span class="n">hitValue</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>我们现在修改 <code class="docutils literal notranslate"><span class="pre">raytrace.rgen</span></code> ，在其中包含 <code class="docutils literal notranslate"><span class="pre">raycommon.glsl</span></code>。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="cp">#include &quot;raycommon.glsl&quot;</span>
</pre></div>
</div>
<p>该负载就是使用 <code class="docutils literal notranslate"><span class="pre">rayPayloadEXT</span></code> 声明的 <code class="docutils literal notranslate"><span class="pre">hitPayload</span></code> 结构体。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="n">rayPayloadEXT</span><span class="w"> </span><span class="n">hitPayload</span><span class="w"> </span><span class="n">prd</span><span class="p">;</span>
</pre></div>
</div>
<p>着色器的主函数 <code class="docutils literal notranslate"><span class="pre">main</span></code> 从计算像素的浮点数坐标开始，该坐标被归一化到 <span class="math notranslate nohighlight">\([0,1]\)</span> 之间。 <code class="docutils literal notranslate"><span class="pre">gl_LaunchIDEXT</span></code> 包含被渲染像素的整数坐标位置，并且 <code class="docutils literal notranslate"><span class="pre">gl_LaunchSizeEXT</span></code> 包含了当执行 <code class="docutils literal notranslate"><span class="pre">vkCmdTraceRaysKHR</span></code> 指令时指定的渲染图片维度。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">pixelCenter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec2</span><span class="p">(</span><span class="nb">gl_LaunchIDEXT</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">vec2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">inUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pixelCenter</span><span class="o">/</span><span class="kt">vec2</span><span class="p">(</span><span class="nb">gl_LaunchSizeEXT</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec2</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inUV</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
</pre></div>
</div>
<p>获取该像素的坐标系之后，我们可以使用 <code class="docutils literal notranslate"><span class="pre">view</span></code> 和 <code class="docutils literal notranslate"><span class="pre">projection</span></code> 变换的逆矩阵得到光线的起点和方向。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">vec4</span><span class="w"> </span><span class="n">origin</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">uni</span><span class="p">.</span><span class="n">viewInverse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">target</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">uni</span><span class="p">.</span><span class="n">projInverse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="kt">vec4</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uni</span><span class="p">.</span><span class="n">viewInverse</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">xyz</span><span class="p">),</span><span class="w"> </span><span class="mo">0</span><span class="p">);</span>
</pre></div>
</div>
<p>此外，我们为光线提供一些位域和设置：首先，一个位域用于指示所有的几何体都按照不透明物体对待，就像我们创建加速结构时指定不透明那样。同样我们也设定一条光线的潜在相交的最小和最大距离。这个距离在光线超出该范围后提前退出减少光追消耗，一个经典的用例就是计算环境遮罩（ <code class="docutils literal notranslate"><span class="pre">ambient</span> <span class="pre">occlusion</span></code> ）。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="w">  </span><span class="n">rayFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_RayFlagsOpaqueEXT</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">tMin</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mf">0.001</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">tMax</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mf">10000.0</span><span class="p">;</span>
</pre></div>
</div>
<p>现在我们通过调用 <code class="docutils literal notranslate"><span class="pre">traceRayEXT</span></code> 函数进行追踪光线。对应的参数为：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">traceRayEXT</span><span class="p">(</span><span class="n">accelerationStructureEXT</span><span class="w"> </span><span class="n">topLevel</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint</span><span class="w"> </span><span class="n">rayFlags</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint</span><span class="w"> </span><span class="n">cullMask</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint</span><span class="w"> </span><span class="n">sbtRecordOffset</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint</span><span class="w"> </span><span class="n">sbtRecordStride</span><span class="p">,</span>
<span class="w">               </span><span class="kt">uint</span><span class="w"> </span><span class="n">missIndex</span><span class="p">,</span>
<span class="w">               </span><span class="kt">vec3</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span>
<span class="w">               </span><span class="kt">float</span><span class="w"> </span><span class="n">Tmin</span><span class="p">,</span>
<span class="w">               </span><span class="kt">vec3</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span>
<span class="w">               </span><span class="kt">float</span><span class="w"> </span><span class="n">Tmax</span><span class="p">,</span>
<span class="w">               </span><span class="kt">int</span><span class="w"> </span><span class="n">payload</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>顶层加速结构用于相交查询</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rayFlags</span></code> 控制光线追踪的位域</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">8</span></code> 比特的剔除遮罩 <code class="docutils literal notranslate"><span class="pre">culling</span> <span class="pre">mask</span></code> ，加速结构的每一个实体都会有一个 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特的遮罩。这个实体遮罩将会与该遮罩值按位与，如果结果为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 将会忽略该交点。我们没有利用该特性，所以这里我们给 <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> 遮罩值，并且帮助类会设置每一个实体的遮罩为 <code class="docutils literal notranslate"><span class="pre">0xFF</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sbtRecordOffset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sbtRecordStride</span></code> 用于控制每一个实体的 <code class="docutils literal notranslate"><span class="pre">hitGroupId</span></code> （ <code class="docutils literal notranslate"><span class="pre">VkAccelerationStructureInstanceKHR::instanceShaderBindingTableRecordOffset</span></code> ）是如何从底层加速结构命中组数组中获取命中组的。由于我们目前只有一个命中组，所以两个都设置成 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。其中的细节相当复杂，可以通过阅读 <a class="reference external" href="https://www.willusher.io/graphics/2019/11/20/the-sbt-three-ways">Will Usher’s article</a> 了解更多。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">missIndex</span></code> 表示底层加速结构的未命中着色器组的索引，当没有与任何实体相交时将会调用该索引对应的未命中着色器。</p></li>
<li><p>光线的起点，最小范围，方向和对打范围。</p></li>
<li><p>该着色器中声明的负载位置，本例中 <code class="docutils literal notranslate"><span class="pre">location</span> <span class="pre">=</span> <span class="pre">0</span></code> 。这个编译期间的常数建立了 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 的调用者和被调用关系，使得允许我们可以选择着色器在哪输出。作为 <code class="docutils literal notranslate"><span class="pre">traceRayEXT</span></code> 直接的结果执行着色器（被调用者），其中的 <code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 参数将会成为 <code class="docutils literal notranslate"><span class="pre">traceRayEXT</span></code> 调用者规定的 <code class="docutils literal notranslate"><span class="pre">rayPayloadEXT</span></code> 位置别名（ <code class="docutils literal notranslate"><span class="pre">alias</span></code> ）。为了能够更好的运行，两个参数都应该是相同的结构体。这允许我们运行时决定着色器的输出往哪里写，这对于逆向光线追踪非常有用处。</p></li>
</ul>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="n">traceRayEXT</span><span class="p">(</span><span class="n">topLevelAS</span><span class="p">,</span><span class="w"> </span><span class="c1">// acceleration structure</span>
<span class="w">        </span><span class="n">rayFlags</span><span class="p">,</span><span class="w">       </span><span class="c1">// rayFlags</span>
<span class="w">        </span><span class="mh">0xFF</span><span class="p">,</span><span class="w">           </span><span class="c1">// cullMask</span>
<span class="w">        </span><span class="mo">0</span><span class="p">,</span><span class="w">              </span><span class="c1">// sbtRecordOffset</span>
<span class="w">        </span><span class="mo">0</span><span class="p">,</span><span class="w">              </span><span class="c1">// sbtRecordStride</span>
<span class="w">        </span><span class="mo">0</span><span class="p">,</span><span class="w">              </span><span class="c1">// missIndex</span>
<span class="w">        </span><span class="n">origin</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span><span class="w">     </span><span class="c1">// ray origin</span>
<span class="w">        </span><span class="n">tMin</span><span class="p">,</span><span class="w">           </span><span class="c1">// ray min range</span>
<span class="w">        </span><span class="n">direction</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span><span class="w">  </span><span class="c1">// ray direction</span>
<span class="w">        </span><span class="n">tMax</span><span class="p">,</span><span class="w">           </span><span class="c1">// ray max range</span>
<span class="w">        </span><span class="mo">0</span><span class="w">               </span><span class="c1">// payload (location = 0)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>最后，我们将负载结果写入图片。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">imageStore</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">ivec2</span><span class="p">(</span><span class="nb">gl_LaunchIDEXT</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">prd</span><span class="p">.</span><span class="n">hitValue</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>光栅化</p></th>
<th class="head"></th>
<th class="head"><p>光线追踪</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><img alt="../../_images/resultRasterCube.png" src="../../_images/resultRasterCube.png" />
</td>
<td><p>↔</p></td>
<td><img alt="../../_images/resultRaytraceFlatCube.png" src="../../_images/resultRaytraceFlatCube.png" />
</td>
</tr>
</tbody>
</table>
</div>
<div class="note admonition">
<p class="admonition-title">rayPayloadEXT 的 locations</p>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> 用于给予 <code class="docutils literal notranslate"><span class="pre">traceRayEXT</span></code> 负载一个唯一识别号。由于某些原因，你不能仅通过负载名称将其传递给 <code class="docutils literal notranslate"><span class="pre">traceRayEXT</span></code> （这被认为是 <code class="docutils literal notranslate"><span class="pre">un-GLSL-y</span></code> ）。</p>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> 的范围为一个着色器一次调用。因此，</p>
<ul class="simple">
<li><p>如果两个不同的着色器链接进入了同一个光追管线，如果这两个着色器的负载使用同一个 <code class="docutils literal notranslate"><span class="pre">location</span></code> 号声明，这两个负载不会互相干扰。</p></li>
<li><p>如果着色器被递归调用，即使他们的 <code class="docutils literal notranslate"><span class="pre">location</span></code> 号都是一样的，每一次的调用各自的负载都是独立的。这就是为什么光追着色器需要 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的栈，这对于计算机图形学来说是一个非常新颖的概念。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>负载的 <code class="docutils literal notranslate"><span class="pre">location</span></code> 和描述符集中的 <code class="docutils literal notranslate"><span class="pre">set</span></code> 和 <code class="docutils literal notranslate"><span class="pre">binding</span></code> 还有与顶点属性的 <code class="docutils literal notranslate"><span class="pre">location</span></code> 是不一样的，后者的作用域范围为全局的。</p>
</div>
</div>
<div class="note admonition">
<p class="admonition-title">rayPayloadInEXT 的 locations</p>
<p><code class="docutils literal notranslate"><span class="pre">rayPayloadInEXT</span></code> 声明的变量同样有一个 <code class="docutils literal notranslate"><span class="pre">location</span></code> ，因此其也可以作为 <code class="docutils literal notranslate"><span class="pre">traceRayEXT</span></code> 的负载进行传递。在本示例中，传入调用着色器的负载背身将会成为被调用着色器传入的负载。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于被调用者的负载和调用者的负载之前并没有要求 <code class="docutils literal notranslate"><span class="pre">location</span></code> 需要匹配！这与用于连接顶点着色器和片元着色器之间的 <code class="docutils literal notranslate"><span class="pre">in/out</span></code> 变量有很大的不同。</p>
</div>
</div>
</section>
<section id="raytrace-miss">
<h3>11.2 未命中着色器（raytrace.miss）<a class="headerlink" href="#raytrace-miss" title="Link to this heading">#</a></h3>
<p>为了共享与光线追踪光栅化清屏颜色，我们将会使用常量推送来改变未命中着色器的返回值。常量推送的 <code class="docutils literal notranslate"><span class="pre">PushConstantRay</span></code> 结构包含很多成员数据，这里我们声明使用该结构体的第一个成员变量 <code class="docutils literal notranslate"><span class="pre">clearColor</span></code> 。对于其他成员目前还未声明。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="cp">#extension GL_GOOGLE_include_directive : enable</span>
<span class="cp">#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require</span>

<span class="cp">#include &quot;raycommon.glsl&quot;</span>
<span class="cp">#include &quot;wavefront.glsl&quot;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="n">rayPayloadInEXT</span><span class="w"> </span><span class="n">hitPayload</span><span class="w"> </span><span class="n">prd</span><span class="p">;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">push_constant</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">_PushConstantRay</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">PushConstantRay</span><span class="w"> </span><span class="n">pcRay</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">prd</span><span class="p">.</span><span class="n">hitValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcRay</span><span class="p">.</span><span class="n">clearColor</span><span class="p">.</span><span class="n">xyz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.8</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>为了区分光栅化和光追渲染结果，返回的背景颜色较深。</p>
</div>
</section>
</section>
<section id="id34">
<h2>12 简单光照<a class="headerlink" href="#id34" title="Link to this heading">#</a></h2>
<p>当前最近命中着色器仅返回一个固定单色。为了增加一些光照，我们需要介绍一下表面法线这个概念。然而，光追命中点处只能获取到质心坐标，为了得到交点处的法线和其他顶点属性，我们需要在顶点缓存中找到他们，之后使用质心坐标计算相关属性值。这就是为什么我们在创建光追描述符集时将顶点缓存和索引缓存的可访问范围扩展至最近命中着色器。</p>
<div class="note admonition">
<p class="admonition-title">可访问范围扩展至最近命中着色器</p>
<p>指的是 <a class="reference internal" href="#additions-to-the-scene-descriptor-set"><span class="std std-ref">6.1 增加场景的描述符集</span></a> 中的如下代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">m_descSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">SceneBindings</span><span class="o">::</span><span class="n">eObjDescs</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                       </span><span class="n">VK_SHADER_STAGE_VERTEX_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_FRAGMENT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="p">);</span>
</pre></div>
</div>
</div>
<section id="raytrace-rchit">
<h3>12.1 最近命中着色器（raytrace.rchit）<a class="headerlink" href="#raytrace-rchit" title="Link to this heading">#</a></h3>
<p>当我们创建光追描述符集的时候，其中已经包含了几何数据的定义。因此我们可以直接在最近命中着色器中通过 <code class="docutils literal notranslate"><span class="pre">binding</span> <span class="pre">=</span> <span class="pre">2</span></code> 访问顶点缓存和索引缓存。</p>
<p>我们首先在着色器中包含负载定义和 <code class="docutils literal notranslate"><span class="pre">OBJ-Wavefront</span></code> 数据结构的头文件</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="cp">#extension GL_EXT_scalar_block_layout : enable</span>
<span class="cp">#extension GL_GOOGLE_include_directive : enable</span>
<span class="cp">#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require</span>
<span class="cp">#extension GL_EXT_buffer_reference2 : require</span>
<span class="cp">#include &quot;raycommon.glsl&quot;</span>
<span class="cp">#include &quot;wavefront.glsl&quot;</span>
</pre></div>
</div>
<p>之后按照描述符集布局声明对应的资源</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="n">rayPayloadInEXT</span><span class="w"> </span><span class="n">hitPayload</span><span class="w"> </span><span class="n">prd</span><span class="p">;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">Vertices</span><span class="w"> </span><span class="p">{</span><span class="n">Vertex</span><span class="w"> </span><span class="n">v</span><span class="p">[];</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 物体的位置</span>
<span class="k">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">Indices</span><span class="w"> </span><span class="p">{</span><span class="kt">ivec3</span><span class="w"> </span><span class="n">i</span><span class="p">[];</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 三角形的索引</span>
<span class="k">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">Materials</span><span class="w"> </span><span class="p">{</span><span class="n">WaveFrontMaterial</span><span class="w"> </span><span class="n">m</span><span class="p">[];</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 一个物体最终所有的材质</span>
<span class="k">layout</span><span class="p">(</span><span class="n">buffer_reference</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">MatIndices</span><span class="w"> </span><span class="p">{</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">[];</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 每个三角形对应的材质ID</span>
<span class="k">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eObjDescs</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">buffer</span><span class="w"> </span><span class="n">ObjDesc_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ObjDesc</span><span class="w"> </span><span class="n">i</span><span class="p">[];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">objDesc</span><span class="p">;</span>

<span class="k">layout</span><span class="p">(</span><span class="n">push_constant</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">_PushConstantRay</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PushConstantRay</span><span class="w"> </span><span class="n">pcRay</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中， <code class="docutils literal notranslate"><span class="pre">gl_InstanceCustomIndexEXT</span></code> 用于告诉我们光线和哪一个物体相交了，并且使用 <code class="docutils literal notranslate"><span class="pre">gl_PrimitiveID</span></code> 可以找到被击中三角形的顶点信息。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Object data</span>
<span class="w">    </span><span class="n">ObjDesc</span><span class="w">    </span><span class="n">objResource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objDesc</span><span class="p">.</span><span class="n">i</span><span class="p">[</span><span class="nb">gl_InstanceCustomIndexEXT</span><span class="p">];</span>
<span class="w">    </span><span class="n">MatIndices</span><span class="w"> </span><span class="n">matIndices</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">MatIndices</span><span class="p">(</span><span class="n">objResource</span><span class="p">.</span><span class="n">materialIndexAddress</span><span class="p">);</span>
<span class="w">    </span><span class="n">Materials</span><span class="w">  </span><span class="n">materials</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">Materials</span><span class="p">(</span><span class="n">objResource</span><span class="p">.</span><span class="n">materialAddress</span><span class="p">);</span>
<span class="w">    </span><span class="n">Indices</span><span class="w">    </span><span class="n">indices</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">Indices</span><span class="p">(</span><span class="n">objResource</span><span class="p">.</span><span class="n">indexAddress</span><span class="p">);</span>
<span class="w">    </span><span class="n">Vertices</span><span class="w">   </span><span class="n">vertices</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">Vertices</span><span class="p">(</span><span class="n">objResource</span><span class="p">.</span><span class="n">vertexAddress</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Indices of the triangle</span>
<span class="w">    </span><span class="kt">ivec3</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">.</span><span class="n">i</span><span class="p">[</span><span class="nb">gl_PrimitiveID</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Vertex of the triangle</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertices</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">ind</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertices</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">ind</span><span class="p">.</span><span class="n">y</span><span class="p">];</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertices</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">ind</span><span class="p">.</span><span class="n">z</span><span class="p">];</span>
</pre></div>
</div>
<p>根据如下算法计算质心坐标。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">barycentrics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">attribs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>世界空间下的坐标可以通过两种方式计算出来，第一种是使用来自最近命中着色器获得的信息获取，如果交点非常非常远的话，这会有一个精度问题。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_WorldRayOriginEXT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">gl_WorldRayDirectionEXT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_HitTEXT</span><span class="p">;</span>
</pre></div>
</div>
<p>另一种更加精确的方式是：通过插值计算位置。我们使用当前击中点上所处的矩阵进行计算，这个矩阵是通过使用顶层加速结构和底层加速结构提供的信息计算出来的。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>目前我们所有的底层加速结构都没有提供任何矩阵变换，只有顶层加速结构的实体提供了相应的变换矩阵。</p>
</div>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="c1">// 计算命中点的坐标</span>
<span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">pos</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="nb">gl_ObjectToWorldEXT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span><span class="w">  </span><span class="c1">// 将坐标变换到世界空间下</span>
</pre></div>
</div>
<p>相同的算法也可以应用到法线上。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在命中点位置计算法线</span>
<span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">nrm</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="n">nrm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">nrm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">nrm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">worldNrm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="kt">vec3</span><span class="p">(</span><span class="n">nrm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_WorldToObjectEXT</span><span class="p">));</span><span class="w">  </span><span class="c1">// 将法线变换到世界空间下</span>
</pre></div>
</div>
<p>光源目前以一个常量数据呈现，之后可以将法线与光源方向进行点乘得到一个不一样的简单光照效果。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="c1">// 光源方向的向量</span>
<span class="kt">vec3</span><span class="w">  </span><span class="n">L</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">lightIntensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcRay</span><span class="p">.</span><span class="n">lightIntensity</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">lightDistance</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">100000.0</span><span class="p">;</span>
<span class="c1">// 点光源</span>
<span class="k">if</span><span class="p">(</span><span class="n">pcRay</span><span class="p">.</span><span class="n">lightType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lDir</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">pcRay</span><span class="p">.</span><span class="n">lightPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">worldPos</span><span class="p">;</span>
<span class="w">  </span><span class="n">lightDistance</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">lDir</span><span class="p">);</span>
<span class="w">  </span><span class="n">lightIntensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pcRay</span><span class="p">.</span><span class="n">lightIntensity</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">lightDistance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lightDistance</span><span class="p">);</span>
<span class="w">  </span><span class="n">L</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lDir</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="w">  </span><span class="c1">// 平行光</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">pcRay</span><span class="p">.</span><span class="n">lightPosition</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/resultRaytraceLightGreyCube.png" src="../../_images/resultRaytraceLightGreyCube.png" />
</figure>
</section>
</section>
<section id="id35">
<h2>13 简单材质<a class="headerlink" href="#id35" title="Link to this heading">#</a></h2>
<p>基于上面的渲染，我们可以通过增加材质来呈现更有趣的渲染效果。加载进来的 <code class="docutils literal notranslate"><span class="pre">OBJ</span></code> 对象提供了一个简单的 <code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">Wavefront</span></code> 材质。</p>
<div class="note admonition">
<p class="admonition-title">Alias Wavefront</p>
<p>估计是指 <code class="docutils literal notranslate"><span class="pre">Alias</span></code> （原 <code class="docutils literal notranslate"><span class="pre">Alias|Wavefront</span></code> ）是著名的3D软件公司，旗下作品 <code class="docutils literal notranslate"><span class="pre">Maya</span></code> 、 <code class="docutils literal notranslate"><span class="pre">StudioTools</span></code> 、等。后来被 <code class="docutils literal notranslate"><span class="pre">Autodesk</span></code> 公司收购。</p>
<p><code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">Wavefront</span></code> 应该是 <code class="docutils literal notranslate"><span class="pre">OBJ</span></code> 模型文件内部的材质数据格式。本人没具体研究过。</p>
</div>
<section id="id36">
<h3>13.1 raytrace.rchit<a class="headerlink" href="#id36" title="Link to this heading">#</a></h3>
<p>该材质使用简单的颜色系数定义基础反射属性，并同时支持纹理。包含该材质的缓存已经在光栅化渲染时创建完成，并且同时也被光追描述符集使用。如下在最近命中着色器中绑定要采样的纹理：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eTextures</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">textureSamplers</span><span class="p">[];</span>
</pre></div>
</div>
<p>声明的该材质和在光栅化渲染时使用的是一样的，被定义在 <code class="docutils literal notranslate"><span class="pre">wavefront.glsl</span></code> 中。</p>
<div class="note admonition">
<p class="admonition-title">定义在 <code class="docutils literal notranslate"><span class="pre">wavefront.glsl</span></code> 中</p>
<p><code class="docutils literal notranslate"><span class="pre">wavefront.glsl</span></code> 会去包含 <code class="docutils literal notranslate"><span class="pre">host_device.h</span></code> 头文件，材质结构体的定义位于 <code class="docutils literal notranslate"><span class="pre">host_device.h</span></code> 中。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="n">WaveFrontMaterial</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w">  </span><span class="n">ambient</span><span class="p">;</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w">  </span><span class="n">diffuse</span><span class="p">;</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w">  </span><span class="n">specular</span><span class="p">;</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w">  </span><span class="n">transmittance</span><span class="p">;</span>
<span class="w">  </span><span class="kt">vec3</span><span class="w">  </span><span class="n">emission</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">shininess</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">ior</span><span class="p">;</span><span class="w">       </span><span class="c1">// 反射的索引</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">dissolve</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1 == 不透明; 0 == 完全透明</span>
<span class="w">  </span><span class="kt">int</span><span class="w">   </span><span class="n">illum</span><span class="p">;</span><span class="w">     </span><span class="c1">// 光照模式 (请阅读 http://www.fileformat.info/format/material/)</span>
<span class="w">  </span><span class="kt">int</span><span class="w">   </span><span class="n">textureId</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Vertex</span></code> 结构体中包括材质的索引，我们将使用该索引去对应的缓存中获取相应的材质。</p>
<p>我们首先将 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数的结尾处移除如下代码：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">dotNL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">),</span><span class="w"> </span><span class="mf">0.2</span><span class="p">);</span>
<span class="n">prd</span><span class="p">.</span><span class="n">hitValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">dotNL</span><span class="p">);</span>
</pre></div>
</div>
<p>更换成获取材质定义代码：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="c1">// 对象的材质</span>
<span class="kt">int</span><span class="w">               </span><span class="n">matIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">matIndices</span><span class="p">.</span><span class="n">i</span><span class="p">[</span><span class="nb">gl_PrimitiveID</span><span class="p">];</span>
<span class="n">WaveFrontMaterial</span><span class="w"> </span><span class="n">mat</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">materials</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">matIdx</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>本示例中每一个对象一个材质，并且可通过索引分别获取到每一个材质。并且每一个三角形都有一个材质索引。</p>
</div>
<p>基于此材质定义，我们使用漫反射和高光反射来计算关照。代码同样也支持使用纹理来设置表面反照率。</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="c1">// 漫反射</span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">diffuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeDiffuse</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">mat</span><span class="p">.</span><span class="n">textureId</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint</span><span class="w"> </span><span class="n">txtId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mat</span><span class="p">.</span><span class="n">textureId</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">scnDesc</span><span class="p">.</span><span class="n">i</span><span class="p">[</span><span class="nb">gl_InstanceCustomIndexEXT</span><span class="p">].</span><span class="n">txtOffset</span><span class="p">;</span>
<span class="w">  </span><span class="kt">vec2</span><span class="w"> </span><span class="n">texCoord</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">v0</span><span class="p">.</span><span class="n">texCoord</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">texCoord</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">texCoord</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">barycentrics</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">diffuse</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">textureSamplers</span><span class="p">[</span><span class="n">nonuniformEXT</span><span class="p">(</span><span class="n">txtId</span><span class="p">)],</span><span class="w"> </span><span class="n">texCoord</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 高光反射</span>
<span class="kt">vec3</span><span class="w"> </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeSpecular</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="nb">gl_WorldRayDirectionEXT</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">);</span>
</pre></div>
</div>
<p>最终的光照计算如下：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="n">prd</span><span class="p">.</span><span class="n">hitValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">lightIntensity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">));</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/resultRaytraceLightMatCube.png" src="../../_images/resultRaytraceLightMatCube.png" />
</figure>
</section>
<section id="id37">
<h3>13.2 main<a class="headerlink" href="#id37" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">OBJ</span></code> 的模型是在 <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> 中通过调用 <code class="docutils literal notranslate"><span class="pre">helloVk.loadModel</span></code> 加载的。相比于加载一个方盒子，让我们加载一些更有趣的模型：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">helloVk</span><span class="p">.</span><span class="n">loadModel</span><span class="p">(</span><span class="n">nvh</span><span class="o">::</span><span class="n">findFile</span><span class="p">(</span><span class="s">&quot;media/scenes/Medieval_building.obj&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">defaultSearchPaths</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span>
<span class="n">helloVk</span><span class="p">.</span><span class="n">loadModel</span><span class="p">(</span><span class="n">nvh</span><span class="o">::</span><span class="n">findFile</span><span class="p">(</span><span class="s">&quot;media/scenes/plane.obj&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">defaultSearchPaths</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span>
</pre></div>
</div>
<p>由于该模型较大，我们可以将 <code class="docutils literal notranslate"><span class="pre">CameraManip.setLookat</span></code> 设置成：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CameraManip</span><span class="p">.</span><span class="n">setLookat</span><span class="p">(</span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec3f</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">nvmath</span><span class="o">::</span><span class="n">vec3f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/resultRaytraceLightMatMedieval.png" src="../../_images/resultRaytraceLightMatMedieval.png" />
</figure>
</section>
</section>
<section id="id38">
<h2>14 阴影<a class="headerlink" href="#id38" title="Link to this heading">#</a></h2>
<p>如上光追渲染能得到一个应用了一些光照的场景，但是目前还没有阴影。在本示例的结尾，我们将会增加一个新的光线类型，并且从最近命中着色器中发射该光线，该新增加的光线类型需要增加一个新的未命中着色器。</p>
<section id="createraytracingpipeline">
<h3>14.1 createRaytracingPipeline<a class="headerlink" href="#createraytracingpipeline" title="Link to this heading">#</a></h3>
<p>对于简单的阴影光线我们只需要计算出该光线是否与几何体相交即可。我们可以使用一个布尔（ <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> ）负载来指示是否发生了相交，并且使用当新增加的未命中着色器将负载设置成未命中状态。</p>
<div class="warning admonition">
<p class="admonition-title"><a class="reference external" href="https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/files/shadowShaders.zip">Download Shadow Shader</a></p>
<p>下载并增加着色器文件</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果按照 <a class="reference internal" href="#environment-setup"><span class="std std-ref">2 配置环境</span></a> 中的步骤，用于阴影的未命中着色器会一并包含下载。</p>
</div>
</div>
<p>该压缩文件中只有一个文件 <code class="docutils literal notranslate"><span class="pre">raytraceShadow.rmiss</span></code> 。将该着色器文件解压并加到 <code class="docutils literal notranslate"><span class="pre">src/shaders</span></code> 目录下，之后执行 <code class="docutils literal notranslate"><span class="pre">CMake</span></code> 即可。该着色器文件将会被编译，并且编译的 <code class="docutils literal notranslate"><span class="pre">SPIR-V</span></code> 目标文件将会和其他 <code class="docutils literal notranslate"><span class="pre">GLSL</span></code> 文件一道存放到 <code class="docutils literal notranslate"><span class="pre">shaders</span></code> 文件夹中。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">createRtPipeline</span></code> 函数体中，我们需要在之前的未命中着色器之后增加对于新未命中着色器的定义。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">StageIndices</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">eRaygen</span><span class="p">,</span>
<span class="w">  </span><span class="n">eMiss</span><span class="p">,</span>
<span class="w">  </span><span class="n">eMiss2</span><span class="p">,</span><span class="w"> </span><span class="c1">// 新增未命中着色器</span>
<span class="w">  </span><span class="n">eClosestHit</span><span class="p">,</span>
<span class="w">  </span><span class="n">eShaderGroupCount</span>
<span class="p">};</span>
</pre></div>
</div>
<p>并且创建相应的着色器句柄：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 当阴影光线没有和任何几何体相交的话将会调用第二个未命中着色器。其只是表示未发生遮挡。</span>
<span class="n">stage</span><span class="p">.</span><span class="k">module</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">nvvk</span><span class="o">::</span><span class="n">createShaderModule</span><span class="p">(</span><span class="n">m_device</span><span class="p">,</span><span class="w"> </span><span class="n">nvh</span><span class="o">::</span><span class="n">loadFile</span><span class="p">(</span><span class="s">&quot;spv/raytraceShadow.rmiss.spv&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">defaultSearchPaths</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">));</span>
<span class="n">stage</span><span class="p">.</span><span class="n">stage</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_MISS_BIT_KHR</span><span class="p">;</span>
<span class="n">stages</span><span class="p">[</span><span class="n">eMiss2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stage</span><span class="p">;</span>
</pre></div>
</div>
<p>之后使用该着色器句柄并将其添加到相应的着色器组中：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 阴影的未命中着色器</span>
<span class="n">group</span><span class="p">.</span><span class="n">type</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</span><span class="p">;</span>
<span class="n">group</span><span class="p">.</span><span class="n">generalShader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eMiss2</span><span class="p">;</span>
<span class="n">m_rtShaderGroups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
</pre></div>
</div>
<p>现在光追管线可以允许从最近命中着色器发生光线，其中需要将光线追踪的递归次数增加到 <code class="docutils literal notranslate"><span class="pre">2</span></code> 级。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 光线追踪可以从相机发射光线，并且阴影光线可以从命中的相交点处发射光线，因此递归级别是2。</span>
<span class="c1">// 为了性能考虑这个递归层级越小越好。</span>
<span class="c1">// 为了防止过深的递归，在生成光线时光线追踪递归会展成一个循环。</span>
<span class="n">rayPipelineInfo</span><span class="p">.</span><span class="n">maxPipelineRayRecursionDepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// 光线递归深度</span>
</pre></div>
</div>
<div class="warning admonition">
<p class="admonition-title">资源限制</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 规范在运行时并不保证进行递归检查。如果在设置光追管线构造信息时设置了超过物理设备支持的递归深度，其结果是未定义的。</p>
<p><code class="docutils literal notranslate"><span class="pre">KHR</span></code> 的光追规范中将原本 <code class="docutils literal notranslate"><span class="pre">NV</span></code> 规范中的最小递归深度 <code class="docutils literal notranslate"><span class="pre">31</span></code> 降低到了 <code class="docutils literal notranslate"><span class="pre">1</span></code> （比如不进行递归）。由于我们现在需要将递归限制在 <code class="docutils literal notranslate"><span class="pre">2</span></code> ，我们
需要检查一下设备是否支持该递归深度：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Spec only guarantees 1 level of &quot;recursion&quot;. Check for that sad possibility here.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m_rtProperties</span><span class="p">.</span><span class="n">maxRayRecursionDepth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Device fails to support ray recursion (m_rtProperties.maxRayRecursionDepth &lt;= 1)&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">m_rtProperties</span></code> 将会在 <code class="docutils literal notranslate"><span class="pre">HelloVulkan::initRayTracing</span></code> 中进行获取赋值。</p>
</div>
</section>
<section id="creatertshaderbindingtable">
<h3>14.2 createRtShaderBindingTable<a class="headerlink" href="#creatertshaderbindingtable" title="Link to this heading">#</a></h3>
<p>新加入的未命中着色器组改变了我们着色器绑定表的结构，现在其结构如下：</p>
<figure class="align-default">
<img alt="../../_images/sbt_1.png" src="../../_images/sbt_1.png" />
</figure>
<p>因此我们需要修改 <code class="docutils literal notranslate"><span class="pre">HelloVulkan::createRtShaderBindingTable</span></code> 函数，指定我们有两个未命中着色器，其中的一个是我们新加入的，另一个是原来的。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">missCount</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span>
</pre></div>
</div>
</section>
<section id="creatertdescriptorset">
<h3>14.3 createRtDescriptorSet<a class="headerlink" href="#creatertdescriptorset" title="Link to this heading">#</a></h3>
<p>对于描述符集中的每一个资源，我们需要设置那些着色器阶段可以访问这些资源。由于阴影光线将会从最近命中着色器开始追踪，我们需要增加绑定的加速结构在 <code class="docutils literal notranslate"><span class="pre">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span></code> 的最近命中着色器阶段可以被访问：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 顶层加速结构, 被光线生成着色器和最近命中着色器使用（用于向外发射光线）</span>
<span class="n">m_rtDescSetLayoutBind</span><span class="p">.</span><span class="n">addBinding</span><span class="p">(</span><span class="n">RtxBindings</span><span class="o">::</span><span class="n">eTlas</span><span class="p">,</span><span class="w"> </span><span class="n">VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">VK_SHADER_STAGE_RAYGEN_BIT_KHR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</span><span class="p">);</span><span class="w">  </span><span class="c1">// TLAS</span>
</pre></div>
</div>
</section>
<section id="id39">
<h3>14.4 raytrace.rchit<a class="headerlink" href="#id39" title="Link to this heading">#</a></h3>
<p>现在最近命中着色器需要访问加速结构用于发射光线：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eTlas</span><span class="p">)</span><span class="w"> </span><span class="k">uniform</span><span class="w"> </span><span class="n">accelerationStructureEXT</span><span class="w"> </span><span class="n">topLevelAS</span><span class="p">;</span>
</pre></div>
</div>
<p>这些光线同样需要携带负载，其需要定义在与当前射线负载不同的位置上。在本示例中，该负载是一个简单的布尔值，用于指示是否发生了遮挡：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">rayPayloadEXT</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isShadowed</span><span class="p">;</span>
</pre></div>
</div>
<p>在着色器的 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中，移除之前简单将负载设置成 <code class="docutils literal notranslate"><span class="pre">prd.hitValue</span> <span class="pre">=</span> <span class="pre">c;</span></code> ，此时我们将会发射新的光线。为了选择阴影用的未命中着色器，我们将传递给 <code class="docutils literal notranslate"><span class="pre">traceRayEXT()</span></code> 的 <code class="docutils literal notranslate"><span class="pre">missIndex</span></code> 设置成 <code class="docutils literal notranslate"><span class="pre">1</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。负载的位置将会与 <code class="docutils literal notranslate"><span class="pre">layout(location</span> <span class="pre">=</span> <span class="pre">1)</span></code> 声明的进行匹配。注意，当我们调用 <code class="docutils literal notranslate"><span class="pre">traceRayEXT()</span></code> 时我们设置的光追位域如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gl_RayFlagsSkipClosestHitShaderKHR</span></code> ：将不会调用最近命中着色器，只会调用未命中着色器</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_RayFlagsOpaqueKHR</span></code> ：将不会调用任意命中着色器，所以所有的对象都是不透明的</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl_RayFlagsTerminateOnFirstHitKHR</span></code> ：使用第一个交点就好</p></li>
</ul>
<p>由于我们略过了阴影命中着色器组，当击中物体表面时没有代码会执行。所以我们将 <code class="docutils literal notranslate"><span class="pre">isShadowed</span></code> 负载初始化为 <code class="docutils literal notranslate"><span class="pre">true</span></code> ，并且将会依靠未命中着色器将该负载设置成 <code class="docutils literal notranslate"><span class="pre">false</span></code> 来表示没有碰到任何表面。同样我们设置的光追位域来优化光线追踪：因为此阴影光线只需要简单返回是否与表面相交，所以我们可以在获得了第一个交点时就告诉光追引擎停止继续遍历，这避免了执行最近命中着色器。</p>
<p>阴影光线只有在光源位于表面前方时才纳入考量，并且如果我们处在阴影中就不需要计算光照的高光部分（因为光源对于此渲染点是不可见的）。现在基于之前的高光计算部分与阴影相结合：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w">  </span><span class="n">specular</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// 只有表面可见时才进行阴影光线的追踪</span>
<span class="k">if</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">tMin</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mf">0.001</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">tMax</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">lightDistance</span><span class="p">;</span>
<span class="w">  </span><span class="n">vec3</span><span class="w">  </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gl_WorldRayOriginEXT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gl_WorldRayDirectionEXT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gl_HitTEXT</span><span class="p">;</span>
<span class="w">  </span><span class="n">vec3</span><span class="w">  </span><span class="n">rayDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w">  </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">gl_RayFlagsTerminateOnFirstHitEXT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">gl_RayFlagsOpaqueEXT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">gl_RayFlagsSkipClosestHitShaderEXT</span><span class="p">;</span>
<span class="w">  </span><span class="n">isShadowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="n">traceRayEXT</span><span class="p">(</span><span class="n">topLevelAS</span><span class="p">,</span><span class="w">  </span><span class="c1">// acceleration structure</span>
<span class="w">          </span><span class="n">flags</span><span class="p">,</span><span class="w">       </span><span class="c1">// rayFlags</span>
<span class="w">          </span><span class="mh">0xFF</span><span class="p">,</span><span class="w">        </span><span class="c1">// cullMask</span>
<span class="w">          </span><span class="mi">0</span><span class="p">,</span><span class="w">           </span><span class="c1">// sbtRecordOffset</span>
<span class="w">          </span><span class="mi">0</span><span class="p">,</span><span class="w">           </span><span class="c1">// sbtRecordStride</span>
<span class="w">          </span><span class="mi">1</span><span class="p">,</span><span class="w">           </span><span class="c1">// missIndex</span>
<span class="w">          </span><span class="n">origin</span><span class="p">,</span><span class="w">      </span><span class="c1">// ray origin</span>
<span class="w">          </span><span class="n">tMin</span><span class="p">,</span><span class="w">        </span><span class="c1">// ray min range</span>
<span class="w">          </span><span class="n">rayDir</span><span class="p">,</span><span class="w">      </span><span class="c1">// ray direction</span>
<span class="w">          </span><span class="n">tMax</span><span class="p">,</span><span class="w">        </span><span class="c1">// ray max range</span>
<span class="w">          </span><span class="mi">1</span><span class="w">            </span><span class="c1">// payload (location = 1)</span>
<span class="w">  </span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">isShadowed</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 高光</span>
<span class="w">    </span><span class="n">specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeSpecular</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">gl_WorldRayDirectionEXT</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最终的负载可以按照阴影光线的结果进行调整：</p>
<div class="highlight-GLSL notranslate"><div class="highlight"><pre><span></span><span class="n">prd</span><span class="p">.</span><span class="n">hitValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="n">lightIntensity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">attenuation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">diffuse</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">specular</span><span class="p">));</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/resultRaytraceShadowMedieval.png" src="../../_images/resultRaytraceShadowMedieval.png" />
</figure>
<p>最终的工程可以在 <a class="reference external" href="https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR/tree/master/ray_tracing__simple">ray_tracing__simple</a> 文件夹下找到。</p>
</section>
</section>
<section id="id40">
<h2>15 拓展延伸<a class="headerlink" href="#id40" title="Link to this heading">#</a></h2>
<p>从此时起，您可以继续创建自己的光线类型和着色器，并尝试更高级的光线跟踪算法。</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="extensions/JitterCamera.html">相机抖动抗锯齿教程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id4">教程</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id6">随机函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id7">帧序</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id8">随机并抖动</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id9">存储或更新</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id10">更新应用帧</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#ui">当 UI 发生变化时帧重置</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id11">品质</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/JitterCamera.html#id12">光线生成着色器中的多采样</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions/AnyHitShaders.html">任意命中着色器（Any Hit Shaders）教程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id4">教程</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id7">任意命中着色器</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id9">负载</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id10">将任意命中着色器加入光追管线中</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id11">配置任意命中着色器中访问的缓存</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id12">不透明标志位</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id13">光线生成着色器</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id15">最近命中着色器</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id16">场景和模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#obj">OBJ 材质</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id17">累积</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/AnyHitShaders.html#id22">修正管线</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions/Instances.html">实例化</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extensions/Instances.html#id4">教程</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Instances.html#id6">多实例</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Instances.html#id7">多物体</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Instances.html#dma">设备内存分配器 （DMA）</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Instances.html#id8">结果</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Instances.html#vma-vulkan">VMA ：Vulkan 内存分配器</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions/Reflections.html">反射</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extensions/Reflections.html#id3">教程</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Reflections.html#id5">布置场景</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Reflections.html#id6">递归反射</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Reflections.html#id8">迭代反射</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensions/Reflections.html#id14">控制递归深度</a></li>
</ul>
</li>
</ul>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
<div class="related-pages">
    <a class="next-page" href="extensions/JitterCamera.html">
        <div class="page-info">
            <div class="context">
                <span>Next</span>
            </div>
            <div class="title">相机抖动抗锯齿教程</div>
        </div>
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
    </a>
    <a class="prev-page" href="../Vulkan-GuideRayTracing.html">
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
        <div class="page-info">
            <div class="context">
                <span>Previous</span>
            </div>
            
            <div class="title">光线追踪</div>
            
        </div>
    </a>
</div>
<div class="bottom-of-page">
    <div class="left-details">
        <div class="copyright">
            Copyright &#169; 2023, FuXii
        </div>
        Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
        
        <a href="https://github.com/pradyunsg/furo">Furo</a>
        
        <div>
             <span id="busuanzi_container_site_uv" style='display:none'>site view <span
                    id="busuanzi_value_site_uv"></span></span> 
        </div>
    </div>
    <div class="right-details">
        <div class="icons">
            <a class="muted-link " href="https://github.com/FuXiii/Essentials.of.Vulkan" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
            
        </div>
        <div class="left-details">
             <span id="busuanzi_container_page_pv" style='display:none'>page view <span
                    id="busuanzi_value_page_pv"></span></span> 
        </div>
    </div>
</div>

      </footer>
    </div>
    <aside class="toc-drawer">
      

<div class="toc-sticky toc-scroll" style="width: 500px;">
    <div class="toc-title-container" style="width: 500px;">
        <span class="toc-title" style="width: 500px;">
            On this page
        </span>
    </div>
    <div class="toc-tree-container" style="width: 500px;">
        <div class="toc-tree" style="width: 500px;">
            <ul>
<li><a class="reference internal" href="#">NVIDIA Vulkan 光线追踪教程</a><ul>
<li><a class="reference internal" href="#id6">1 介绍</a></li>
<li><a class="reference internal" href="#environment-setup">2 配置环境</a><ul>
<li><a class="reference internal" href="#id8">2.1 生成解决方案</a></li>
<li><a class="reference internal" href="#id9">2.2 工具安装</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">3 编译和运行</a></li>
<li><a class="reference internal" href="#id11">4 开始步入光线追踪</a><ul>
<li><a class="reference internal" href="#main">4.1 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">5 加速结构</a><ul>
<li><a class="reference internal" href="#bottom-level-acceleration-structure">5.1 底层加速结构</a><ul>
<li><a class="reference internal" href="#raytracingbuilder-buildblas">5.1.1 帮助类细节：RaytracingBuilder::buildBlas()</a><ul>
<li><a class="reference internal" href="#cmdcreateblas">5.1.1.1 cmdCreateBlas</a></li>
<li><a class="reference internal" href="#cmdcompactblas">5.1.1.2 cmdCompactBlas</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id15">5.2 顶层加速结构</a><ul>
<li><a class="reference internal" href="#raytracingbuilder-buildtlas">5.2.1 帮助类细节：RaytracingBuilder::buildTlas()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">5.3 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#descriptor-set">6 光线追踪描述符集（Descriptor Set）</a><ul>
<li><a class="reference internal" href="#additions-to-the-scene-descriptor-set">6.1 增加场景的描述符集</a></li>
<li><a class="reference internal" href="#id20">6.2 描述符更新</a></li>
<li><a class="reference internal" href="#id21">6.3 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">7 光线追踪管线</a><ul>
<li><a class="reference internal" href="#id23">7.1 增加着色器</a></li>
<li><a class="reference internal" href="#id24">7.2 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">8 着色器绑定表</a><ul>
<li><a class="reference internal" href="#id26">8.1 句柄</a></li>
<li><a class="reference internal" href="#id29">8.2 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id30">9 光线追踪</a></li>
<li><a class="reference internal" href="#id31">10 开始追踪</a><ul>
<li><a class="reference internal" href="#id32">10.1 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33">11 相机矩阵</a><ul>
<li><a class="reference internal" href="#raytrace-rgen">11.1 光线生成（ <code class="docutils literal notranslate"><span class="pre">raytrace.rgen</span></code> ）</a></li>
<li><a class="reference internal" href="#raytrace-miss">11.2 未命中着色器（raytrace.miss）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">12 简单光照</a><ul>
<li><a class="reference internal" href="#raytrace-rchit">12.1 最近命中着色器（raytrace.rchit）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id35">13 简单材质</a><ul>
<li><a class="reference internal" href="#id36">13.1 raytrace.rchit</a></li>
<li><a class="reference internal" href="#id37">13.2 main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id38">14 阴影</a><ul>
<li><a class="reference internal" href="#createraytracingpipeline">14.1 createRaytracingPipeline</a></li>
<li><a class="reference internal" href="#creatertshaderbindingtable">14.2 createRtShaderBindingTable</a></li>
<li><a class="reference internal" href="#creatertdescriptorset">14.3 createRtDescriptorSet</a></li>
<li><a class="reference internal" href="#id39">14.4 raytrace.rchit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id40">15 拓展延伸</a></li>
</ul>
</li>
</ul>

        </div>
    </div>
</div>


    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=7d86a446"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/tabs.js?v=3ee01567"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script src="../../_static/translations.js?v=beaddf03"></script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </body>
</html>