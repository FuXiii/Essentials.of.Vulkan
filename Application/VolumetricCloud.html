<!doctype html>
<html class="no-js" lang="zh-CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="next" title="更新日志" href="../Changelog.html" /><link rel="prev" title="应用" href="index.html" />
        <link rel="canonical" href="https://github.com/FuXiii/Essentials.of.Vulkan/Application/VolumetricCloud.html" />

    <link rel="shortcut icon" href="../_static/VulkanLogo.png"/><!-- Generated with Sphinx 6.2.1 and Furo 2023.05.20 -->
        <title>体积云 - Vulkan入门精要</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Vulkan入门精要</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/Vulkan.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Vulkan入门精要</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">入门精要</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StartFromVulkanSDK.html">开始于 Vulkan SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Overview.html">纵览</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">文献翻译</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Literature/index.html">文献</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 文献</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Literature/VulkanRayTracingFinalSpecificationRelease.html">Vulkan 光线追踪最终标准发布</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Literature/Vulkan-GuideRayTracing.html">光线追踪</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Literature/NVIDIAVulkanRayTracingTutorial.html">NVIDIA Vulkan 光线追踪教程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Literature/vk_mini_path_tracer.html">Vulkan迷你路径追踪</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Literature/TheRTXShaderBindingTableThreeWays.html">RTX 着色器绑定表的三种方式</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">随笔</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../InformalEssay/index.html">Vulkan 标准</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Vulkan 标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../InformalEssay/VulkanKHRRayTracing/VulkanKHRRayTracing.html">Vulkan KHR 光线追踪标准</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Vulkan KHR 光线追踪标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../InformalEssay/VulkanKHRRayTracing/VK_KHR_acceleration_structure.html">VK_KHR_acceleration_structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../InformalEssay/VulkanKHRRayTracing/VK_KHR_ray_tracing_pipeline.html">VK_KHR_ray_tracing_pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="../InformalEssay/VulkanKHRRayTracing/VK_KHR_deferred_host_operations.html">VK_KHR_deferred_host_operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../InformalEssay/VK_KHR_buffer_device_address.html">VK_KHR_buffer_device_address</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">工程应用</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">应用</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of 应用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">体积云</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">更新日志</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Changelog.html">更新日志</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/FuXiii/Essentials.of.Vulkan/edit/main/source/Application/VolumetricCloud.md" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>体积云<a class="headerlink" href="#id1" title="此标题的永久链接">#</a></h1>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header sd-bg-muted sd-bg-text-muted">
<span class="sd-summary-icon"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-history" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M1.643 3.143L.427 1.927A.25.25 0 000 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 00.177-.427L2.715 4.215a6.5 6.5 0 11-1.18 4.458.75.75 0 10-1.493.154 8.001 8.001 0 101.6-5.684zM7.75 4a.75.75 0 01.75.75v2.992l2.028.812a.75.75 0 01-.557 1.392l-2.5-1A.75.75 0 017 8.25v-3.5A.75.75 0 017.75 4z"></path></svg></span>更新记录<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<ul class="simple">
<li><p class="sd-card-text">2023/5/19 增加该文章。从<a class="reference external" href="https://github.com/FuXiii/Turbo">Turbo</a>引擎文档中将<a class="reference external" href="https://github.com/FuXiii/Turbo/blob/master/docs/VolumetricCloud.md">VolumetricCloud</a>搬过来。</p></li>
</ul>
</div>
</details><ul class="simple">
<li><p><a class="reference external" href="https://zhuanlan.zhihu.com/p/580168048">GPU Pro 7 体积云</a>:该篇主要讲云体建模和大致思路。云体光照讲的相对较少。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Revision</span> <span class="pre">2013</span> <span class="pre">-</span> <span class="pre">Real-time</span> <span class="pre">Volumetric</span> <span class="pre">Rendering</span> <span class="pre">Course</span> <span class="pre">Notes</span></code> 翻译中，该篇主要是讲云体光照计算的，如果等不及的话可以看<a class="reference external" href="https://www.shadertoy.com/view/ldlXzM">Clouds physically-based II</a>，该示例算法与<code class="docutils literal notranslate"><span class="pre">Revision</span> <span class="pre">2013</span></code>的文章相符</p></li>
</ul>
<section id="id2">
<h2>概述<a class="headerlink" href="#id2" title="此标题的永久链接">#</a></h2>
<p>体积云（Volumetric Cloud ），使用体积数据进行绘制云的方法。有别于<code class="docutils literal notranslate"><span class="pre">广告牌</span></code>（Billboard，一种将图片展现在一张面片上的技术）和建立<code class="docutils literal notranslate"><span class="pre">三维模型</span></code>（blender，3dmax建模之类的），由于广告牌只适合离玩家很远的地方渲染云体（离近了明显效果太假），而三维建模方式云体数据量又太大，只适合一朵朵的建，不适合覆盖整个穹顶，进而现在的体积云都是基于<code class="docutils literal notranslate"><span class="pre">噪音数据</span></code>(可理解成随机数)和<a class="reference external" href="https://adrianb.io/2016/10/01/raymarching.html">光线步进</a>（Raymarch，类似于简化版的光线追踪）的方式进行计算渲染。</p>
<p>其中噪音数据用于描述云体的外形，光线步进用于穿透云体进行光照计算。
该篇文章也主要按照<code class="docutils literal notranslate"><span class="pre">云体建模</span></code>和<code class="docutils literal notranslate"><span class="pre">光照</span></code>这两部分进行讲解。</p>
</section>
<section id="id3">
<h2>0 背景<a class="headerlink" href="#id3" title="此标题的永久链接">#</a></h2>
<p>简单讲解一下云体的<code class="docutils literal notranslate"><span class="pre">噪音数据</span></code>和<code class="docutils literal notranslate"><span class="pre">光线步进</span></code></p>
<section id="id4">
<h3>0.1 噪音<a class="headerlink" href="#id4" title="此标题的永久链接">#</a></h3>
<p>噪音，生活中经常听碰到，工地的施工声，大街上的嘈杂声，老旧电视没信号的雪花屏幕等等，这些都是噪音，再直接一点的说，一个噪音就是一个随机的数。但是这些噪音的混乱程度比较高，在一些自然现象中，比如大地的起伏大多都是比较平缓连续的，密集断崖式的还是少数（相对来说），这时噪音就可以用来代表地形的起伏高度（比如<code class="docutils literal notranslate"><span class="pre">我的世界</span></code>这款游戏的地形生成）。这个时候一种不是那么混乱，而且还带有连续性特性的噪音就是我们所需要的，后来<code class="docutils literal notranslate"><span class="pre">肯·柏林</span></code>（Ken Perlin）发明<code class="docutils literal notranslate"><span class="pre">柏林</span></code>（Perlin）噪音算法，该算法生成的噪音比较自然，非常适合模拟地形、火焰之类的自然现象，后被图形学大量使用。再后来史蒂文·沃利（Steven Worley）发明了沃利（Worley）噪音，该算法生成的噪音比较像动物体内的细胞，所以也叫<code class="docutils literal notranslate"><span class="pre">细胞噪音</span></code></p>
<section id="perlin-noise">
<h4>0.1.1 柏林噪音（Perlin Noise）<a class="headerlink" href="#perlin-noise" title="此标题的永久链接">#</a></h4>
<p>柏林噪音是属于晶格噪音：有一个方形盒子（晶格），盒子内有一个随机点，盒子的八个角，每个角都存有一个随机向量和该角指向随机点的向量，这两个向量做点乘，得到一个数，之后每个角都做如此操作，会得到八个数，加权，合起来，得到一个数，此数作为噪音值。</p>
</section>
<section id="worley-noise">
<h4>0.1.2 沃利噪音 （Worley Noise）<a class="headerlink" href="#worley-noise" title="此标题的永久链接">#</a></h4>
<p>一个平面上随机散布着一些点，这些点叫特征点，走遍整个空间的每个位置，找该位置与哪个特征点最近，最近的那个距离长度作为该空间位置的噪音值。</p>
</section>
<section id="id5">
<h4>0.1.3 三维噪音纹理<a class="headerlink" href="#id5" title="此标题的永久链接">#</a></h4>
<p>最简单的噪音纹理是一维的，数学上理解就是一元函数<code class="docutils literal notranslate"><span class="pre">f(x)</span></code>，最简单的噪音就是几个振幅、频率和相位都不一样的<code class="docutils literal notranslate"><span class="pre">m×sin(ax+b)</span></code>和<code class="docutils literal notranslate"><span class="pre">n×cos(jx+k)</span></code>函数的和（注：傅里叶）。</p>
<p>常见的噪音纹理一般是二维的，用于表达一个二维平面内的随机数，而体积云是个三维物体，需要知道某个空间下云体在空间的分布，这时将二维噪音纹理提升一个维度，构建三维噪音纹理，作为云体的体积数据，用于描述云体外形。</p>
</section>
</section>
<section id="fractal">
<h3>0.2 分形（fractal）<a class="headerlink" href="#fractal" title="此标题的永久链接">#</a></h3>
<p>分形就是宏观看，是其人，细看，还是其人，无论是凑近看还是离远看外貌不变。比如，看树干是比较大的树枝，树干上的岔也是树枝，树枝上的小树枝还是树枝。还有雪花也是分形的</p>
<section id="fractal-brownian-motion-fbm">
<h4>0.2.1 分形布朗运动（Fractal Brownian Motion，简称FBM）<a class="headerlink" href="#fractal-brownian-motion-fbm" title="此标题的永久链接">#</a></h4>
<p>像树这样的分形，大树干是大树枝，树杈是略小一点的树枝，树梢是更小一点的树枝，无论远近，都是树枝，只不过是大小不同，像树这种,可以用不同大小树枝集合来描述其分形，而对于自然界噪音是使用不同频率的噪音叠加来描述其分形，比如山脉，云体，火焰等。这种不同频率噪音的叠加被称作<code class="docutils literal notranslate"><span class="pre">分形布朗运动</span></code>简称<code class="docutils literal notranslate"><span class="pre">FBM</span></code>。<code class="docutils literal notranslate"><span class="pre">分形布朗</span></code>的基本思路就是不同频率的噪音的叠加，这会导致一个非常有意思的现象，每增加一次频率并与之前低频的相加，其结果是在低频的结果上增加细节，而不会破坏低频噪音的形状，就好比揉面团，一开始是一大块，此时可以看成噪音频率很低，在面团上雕花，这时就可以看成低频的噪音加上一个高频噪音的结果，如果再加入更过高频，细节会越来越多。</p>
</section>
</section>
<section id="raymarch">
<h3>0.3 光线步进（Raymarch）<a class="headerlink" href="#raymarch" title="此标题的永久链接">#</a></h3>
<p>光线步进，并不等价于光线追踪，简单来说光线步进是光线追踪的简化版，光线步进算法是通过从某一点出发，沿着某一方向，一步步的前进，每走完一步都会在该处计算光照，一般这样计算光照的位置叫做采样点，最后将所有走过的采样点计算结果加在一起，就是此束光的光照结果。</p>
<p>最常见的光线步进在后处理阶段的片元着色器中进行（<a class="reference external" href="https://www.shadertoy.com/">ShaderToy</a>上的大部分代码都是基于此方法进行的），从相机的位置开始，向每个像素发一条射线，沿着该射线方向步进进行计算。</p>
<p>注：后处理：其实就是在相机前方放块刚好能够铺满整个视界范围的画布，并在该画布上计算每一个位置的颜色值。（一般该画布上都是已经有颜色了，后处理的意思是在此基础上在再做一些修改）</p>
</section>
</section>
<section id="id6">
<h2>1 云体建模<a class="headerlink" href="#id6" title="此标题的永久链接">#</a></h2>
<p>该章节主要讲使用噪音生成云的外形</p>
<section id="id7">
<h3>1.1 柏林-沃利噪音<a class="headerlink" href="#id7" title="此标题的永久链接">#</a></h3>
<p>在使用柏林噪音生成云体后，会明显发现这个云的形状过于平滑，而真实世界中的云上都有一朵朵类似花椰菜，西蓝花的形状的小云朵(分形)，为了营造一朵朵的这种形状，引入了沃利噪音。柏林噪音和沃利噪音相结合柏林-沃利噪音由此诞生</p>
<section id="id8">
<h4>1.1.1 柏林噪音<a class="headerlink" href="#id8" title="此标题的永久链接">#</a></h4>
<p>使用哈希散列表获得随机向量，输入<code class="docutils literal notranslate"><span class="pre">p</span></code>为方盒子八个角的坐标，<code class="docutils literal notranslate"><span class="pre">hash33</span></code>函数将会返回一个随机向量(注：生成随机向量方法还有很多，哈希只是其中一种)</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#define UI0 1597334673U</span>
<span class="cp">#define UI1 3812015801U</span>
<span class="cp">#define UI2 uvec2(UI0, UI1)</span>
<span class="cp">#define UI3 uvec3(UI0, UI1, 2798796415U)</span>
<span class="cp">#define UIF (1.0 / float(0xffffffffU))</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">hash33</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">uvec3</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uvec3</span><span class="p">(</span><span class="n">ivec3</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UI3</span><span class="p">;</span>
<span class="w">    </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UI3</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">-1.</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UIF</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>接下来我们来计算晶格噪音值，还记得柏林噪音是属于晶格噪音的一种吗。</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//生成晶格噪音值</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">gradientNoise</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="p">){</span>
</pre></div>
</div>
<p>首先通过将传入的噪音采样点<code class="docutils literal notranslate"><span class="pre">x</span></code>向下取整，确定晶格的起点</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>之后再取噪音采样点<code class="docutils literal notranslate"><span class="pre">x</span></code>的小数部分作为晶格内的随机点，这样采样点就不会跑出边长为1的正方体外，这与下面生成边长为1的正方体相对应</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fract</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>进行5次插值，<a class="reference external" href="https://iquilezles.org/articles/morenoise/">iq的文章</a>中大致好像是偏导的泰勒展开，具体没细看，一般高阶插值都是为了获得更高精度的结果</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">6.</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">15.</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">10.</span><span class="p">);</span>
</pre></div>
</div>
<p>获得晶格八个角的随机向量，可以看到晶格是边长为1的正方体</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">ga</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">gb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">gd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">ge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">gf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">gg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">gh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">),</span><span class="w"> </span><span class="n">freq</span><span class="p">));</span>
</pre></div>
</div>
<p>方格对应的角的随机向量与角到晶格内采样点向量做点乘</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">ga</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">gb</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">gd</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">ve</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">ge</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">gf</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">gh</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">));</span>
</pre></div>
</div>
<p>加权插值，返回其结果</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">return</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">vb</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">va</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">vc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">va</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ve</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">va</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">va</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vb</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vd</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">va</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ve</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">va</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vb</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ve</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vf</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">va</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vb</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vd</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ve</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vf</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vh</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fbm">
<h4>1.1.2 FBM算法<a class="headerlink" href="#fbm" title="此标题的永久链接">#</a></h4>
<p>在真正进入下一节<code class="docutils literal notranslate"><span class="pre">柏林FBM噪音</span></code>之前，想让我们来看看FBM的一般性描述。最原始的FBM就是不同频率的噪音叠加，根据<a class="reference external" href="https://iquilezles.org/articles/fbm/">iq的文章</a>描述，其中在数学上有个正相关，负相关的特点，当正相关时结果会更大，负相关时结果会更小，控制这种特性的系数叫做<code class="docutils literal notranslate"><span class="pre">赫斯特指数</span></code>(Hurst Exponent)，简写为<code class="docutils literal notranslate"><span class="pre">H</span></code>，该系数在[0,1]范围内，从视觉上看，该系数用于控制噪音的“烈度”或“平滑度”。每当一个更高频叠加时，一般叫这种叠加操称为“增加一个八度”（Octave）。如下图为<code class="docutils literal notranslate"><span class="pre">赫斯特指数</span></code>影响示意图，具体可查看<code class="docutils literal notranslate"><span class="pre">Turbo</span></code>生成的<code class="docutils literal notranslate"><span class="pre">PerlinWorleyNoiseTest</span></code>示例程序。</p>
<p><img alt="Worley_Point" src="../_images/Hurst_Exponent.gif" /></p>
<p>声明<code class="docutils literal notranslate"><span class="pre">FBM</span></code>函数，其中<code class="docutils literal notranslate"><span class="pre">x</span></code>为<code class="docutils literal notranslate"><span class="pre">N</span></code>维空间的一个采样点，<code class="docutils literal notranslate"><span class="pre">H</span></code>为赫斯特指数。</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">fbm</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vecN</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span><span class="w">   </span><span class="c1">//一开始的噪音初值为0</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//进行噪音叠加循环，其中numOctaves为要增加几个八度</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">numOctaves</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//每次增加2倍的频率(不一定只能使用2，也可以是其他数)</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="c1">//使用赫斯特指数进行调整</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">H</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="c1">//进行高频采样叠加</span>
<span class="w">        </span><span class="n">t</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">noise</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//返回叠加结果</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id9">
<h4>1.1.3 柏林FBM噪音<a class="headerlink" href="#id9" title="此标题的永久链接">#</a></h4>
<p>好了，现在我们已经知道<code class="docutils literal notranslate"><span class="pre">FBM</span></code>咋算了，现在来看看<code class="docutils literal notranslate"><span class="pre">柏林FBM</span></code>算法吧</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//柏林FBM，其中p为采样点坐标，freq为频率，octaves为要增加的八度</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">perlinfbm</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">octaves</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//exp2(x)表示2的x次方，该项为赫斯特指数</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp2</span><span class="p">(</span><span class="mf">-.85</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//一开始的赫斯特指数影响系数为1</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">amp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//一开始的噪音值为0</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">noise</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//进行噪音叠加循环，其中octaves为要增加几个八度</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">octaves</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//采样晶格噪音，并乘上赫斯特指数影响系数，并进行噪音叠加</span>
<span class="w">        </span><span class="n">noise</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">amp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gradientNoise</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//提高频率</span>
<span class="w">        </span><span class="n">freq</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mf">2.</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//更新影响系数</span>
<span class="w">        </span><span class="n">amp</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">G</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//返回叠加结果</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">noise</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id10">
<h4>1.1.4 沃利噪音<a class="headerlink" href="#id10" title="此标题的永久链接">#</a></h4>
<p>之前介绍的沃利噪音是在一个二维平面内进行的，现在将二维提升至三维，大致思路都差不多，一个空间内散落着很多特征点，空间中某一点的噪音值为该点到离其最近的特征点的距离，遍历空间中的所有位置计算该点的噪音，即为三维下的沃利噪音。</p>
<p>为了简化问题，一般会把空间限制在一个正方体空间中，之后横竖从中间平分切开，像二阶魔方一样，这样每条边有3个点（算上没切开之前的角），每个面有9个点，有3个面，一共27个点。如下如所示。<br />
<img alt="Worley_Point" src="../_images/Worly_Point.png" /><br />
我们将会在这27个点上，每一个点附近生成一个特征点，之后每一个噪音采样点都与这27个点作比较，寻找离得最近的那个特征点与采样点之间的距离，作为该采样点的噪音值。</p>
<p>如下<code class="docutils literal notranslate"><span class="pre">worleyNoise</span></code>沃利噪音函数，其中<code class="docutils literal notranslate"><span class="pre">uv</span></code>采样点，<code class="docutils literal notranslate"><span class="pre">freq</span></code>为频率</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">worleyNoise</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//同柏林噪音一样，采样点向下取整，唯一不同的是这个id点是在盒子的中心的</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">floor</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//同柏林噪音一样，取小数点部分作为采样点，限制采样点范围</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fract</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//一开始的最小距离大一点，之后用于比较更新</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">minDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10000.</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//如下三个循环就是分别遍历正方体上的27个点</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">1.</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">1.</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.</span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">1.</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">z</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">vec3</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
<span class="w">                </span><span class="c1">//id + offset就是以id为原点，计算周遭27个点的坐标(下文统称红点)</span>
<span class="w">                </span><span class="c1">//在红点处调用hash33(...)，其实就是在算出一个特征点</span>
<span class="w">                </span><span class="c1">//每个红点都有一个特征点</span>
<span class="w">                </span><span class="n">vec3</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash33</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">freq</span><span class="p">)))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">.5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">.5</span><span class="p">;</span>
<span class="w">                </span><span class="c1">//h+offset其实就是算的是相对p点特征点的位置，应为p是最终的采样点</span>
<span class="w">                </span><span class="n">h</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">                </span><span class="c1">//计算采样点和特征点的向量，主要是为了算距离</span>
<span class="w">                </span><span class="n">vec3</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">                </span><span class="c1">//其中向量自身的点乘其结果为自身向量长度的平方，这里不开根号的原因是应为开根号和开平方运算，导数都是大于0的，单调递增，平方最大也就意味着开根号也最大，当然，这里开根号也是可以的，只不多平方算的更快</span>
<span class="w">                </span><span class="c1">//更新较小的那个值</span>
<span class="w">                </span><span class="n">minDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">minDist</span><span class="p">,</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 这里1-minDist意思是将结果反过来，从纹理上来说就是黑的变成白的，白的变成黑的，由于原始的沃利噪音细胞部分是黑色的，这不是我们想要的，我们想要细胞部分用于模拟云的花椰菜的形状，结果反过来更加易于计算。</span>
<span class="w">    </span><span class="c1">//返回最小值</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">minDist</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id11">
<h4>1.1.5 沃利FBM噪音<a class="headerlink" href="#id11" title="此标题的永久链接">#</a></h4>
<p>沃利FBM噪音一样，不同频率叠加，唯一不同的是有个权重，权重和为<code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">worleyFbm</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>
<span class="w">    </span><span class="n">worleyNoise</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">.625</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="c1">//原频率×权重</span>
<span class="w">    </span><span class="n">worleyNoise</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">.25</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="c1">//二倍频率×权重</span>
<span class="w">    </span><span class="n">worleyNoise</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">.125</span><span class="p">;</span><span class="w"> </span><span class="c1">//四倍频率×权重</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id12">
<h3>1.2 柏林-沃利噪音实现<a class="headerlink" href="#id12" title="此标题的永久链接">#</a></h3>
<section id="remap">
<h4>1.2.1 重映射函数（Remap）<a class="headerlink" href="#remap" title="此标题的永久链接">#</a></h4>
<p>在介绍<code class="docutils literal notranslate"><span class="pre">柏林-沃利噪音</span></code>实现之前，先来看看重映射函数，这个相对比较简单。</p>
<p>前提条件：首先定义域<code class="docutils literal notranslate"><span class="pre">X</span></code>（定义域有范围限制，不能是无穷）内某点<code class="docutils literal notranslate"><span class="pre">x</span></code>，定义域<code class="docutils literal notranslate"><span class="pre">X</span></code>范围长度为<code class="docutils literal notranslate"><span class="pre">lx</span></code>。有另一个定义域范围<code class="docutils literal notranslate"><span class="pre">Y</span></code>，定义域<code class="docutils literal notranslate"><span class="pre">Y</span></code>范围长度为<code class="docutils literal notranslate"><span class="pre">ly</span></code></p>
<p>大致思路如下：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x'</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">÷</span> <span class="pre">lx</span></code>得到一个[0,1]的数，其结果为<code class="docutils literal notranslate"><span class="pre">x</span></code>在<code class="docutils literal notranslate"><span class="pre">lx</span></code>上的长度占比<code class="docutils literal notranslate"><span class="pre">x'</span></code></p></li>
<li><p>使用<code class="docutils literal notranslate"><span class="pre">y'</span> <span class="pre">=</span> <span class="pre">ly</span> <span class="pre">×</span> <span class="pre">x'</span></code>得到<code class="docutils literal notranslate"><span class="pre">x</span></code>相对于在<code class="docutils literal notranslate"><span class="pre">ly</span></code>范围映射的位置</p></li>
<li><p>使用<code class="docutils literal notranslate"><span class="pre">Y</span></code>定义域的最小值<code class="docutils literal notranslate"><span class="pre">Ymin</span></code>与<code class="docutils literal notranslate"><span class="pre">y'</span></code>相加<code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">Ymin</span> <span class="pre">+</span> <span class="pre">y'</span></code>，返回<code class="docutils literal notranslate"><span class="pre">result</span></code>即为重映射结果</p></li>
</ol>
<p>代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">remap</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">xMin</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">xMax</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">yMin</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">yMax</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(((</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xMin</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">xMax</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xMin</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">yMax</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">yMin</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yMin</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id13">
<h4>1.2.2 柏林-沃利三维噪音纹理<a class="headerlink" href="#id13" title="此标题的永久链接">#</a></h4>
<p>我们已经知道柏林噪音、沃利噪音及其相对应的FBM是咋回事了，现在就将柏林噪音与沃利噪音相结合。来生成分辨率为<code class="docutils literal notranslate"><span class="pre">128×128×128</span></code>，像素格式为<code class="docutils literal notranslate"><span class="pre">R8G8B8A8</span></code>（每个分量8位）的三维纹理。其中每个分量存储的数据对于如下：</p>
<ul class="simple">
<li><p>R分量：存储柏林-沃利FBM噪音值</p></li>
<li><p>G分量：单倍频率的沃利FBM噪音值</p></li>
<li><p>B分量：双倍频率的沃利FBM噪音值</p></li>
<li><p>A分量：四倍频率的沃利FBM噪音值</p></li>
</ul>
<p>如下<code class="docutils literal notranslate"><span class="pre">PerlinWorley</span></code>函数为计算柏林-沃利噪音，其中<code class="docutils literal notranslate"><span class="pre">uv</span></code>是三维纹理采样坐标，每个轴分量的范围为<code class="docutils literal notranslate"><span class="pre">[0,1]</span></code>，该函数返回坐标为<code class="docutils literal notranslate"><span class="pre">uv</span></code>点的三维纹理像素颜色。</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec4</span><span class="w"> </span><span class="nf">PerlinWorley</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//声明要返回的颜色值</span>
<span class="w">    </span><span class="n">vec4</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//计算获得uv点的柏林FBM噪音值。由于perlinfbm(...)返回的值范围为[-1,1]，而颜色范围为[0,1]，所以需要使用mix(1,perlinFBM,0.5)函数将噪音映射到[0,1]</span>
<span class="w">    </span><span class="c1">//等价于：float perlin_fbm = (perlinfbm(uv, 4., 7)+1)/2;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">perlin_fbm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mix</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="n">perlinfbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="mf">4.</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//这里乘以2再减去1，按照GPU Pro 7的说法是让柏林FBM更具有云的蓬松感</span>
<span class="w">    </span><span class="n">perlin_fbm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">perlin_fbm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//G、B、A分量存储不同频率的沃利FBM噪音</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">worleyFbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="p">);</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">worleyFbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.</span><span class="p">);</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">worleyFbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//柏林-沃利就是柏林FBM噪音在沃利FBM噪音上的重映射，并存储在R分量上，这样两者就结合在一起了。</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">remap</span><span class="p">(</span><span class="n">pfbm</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">.</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//返回结果</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如此遍历整个三维噪音纹理的每个像素，即可获得三维柏林-沃利噪音纹理。</p>
</section>
</section>
<section id="id14">
<h3>1.3 三维沃利噪音纹理<a class="headerlink" href="#id14" title="此标题的永久链接">#</a></h3>
<p>使用柏林-沃利噪音，已经可以描述云体了，但只能说描述了云体的大致形状。如下图所示：<br />
<img alt="base_cloud" src="../_images/base_colud.png" /></p>
<p>而云一般没有这么圆润，一般都会有毛毛絮样的边缘，如下图所示：<br />
<img alt="base_cloud" src="../_images/detail_cloud.png" /></p>
<p>为了达到这样的细节，没错，需要在云层的边缘再叠一层高频噪音，已达到絮状的感觉，这时就用到了<code class="docutils literal notranslate"><span class="pre">三维沃利噪音纹理</span></code>。三维柏林-沃利噪音我们已经见过了，三维沃利噪音也就没啥了。三维沃利噪音纹理，分辨率大小为32×32×32，每个像素格式是R8G8B8(RGB三个分量，每个分量8位)，其中：</p>
<ul class="simple">
<li><p>R分量：单倍频率的沃利FBM噪音值（非绝对，可适当提高频率）</p></li>
<li><p>G分量：双倍频率的沃利FBM噪音值（非绝对，可适当提高频率）</p></li>
<li><p>B分量：四倍频率的沃利FBM噪音值（非绝对，可适当提高频率）</p></li>
</ul>
<p>代码大致如下：</p>
<p>其中<code class="docutils literal notranslate"><span class="pre">uv</span></code>为采样点</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">WorleyFBM3DNoise</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="c1">//非绝对，可适当提高频率</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">worleyFbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="p">);</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">worleyFbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.</span><span class="p">);</span>
<span class="w">    </span><span class="n">color</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">worleyFbm</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">4.</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如此遍历整个三维噪音纹理的每个像素，即可获得三维沃利噪音纹理。</p>
</section>
</section>
<section id="id15">
<h2>2 光线步进与采样<a class="headerlink" href="#id15" title="此标题的永久链接">#</a></h2>
<p>现在我们已经通过三维噪音纹理生成了云体的体积数据，接下来将会一步步的由简入繁的通过使用光线步进对三维噪音纹理进行采样来渲染云体。</p>
<section id="id16">
<h3>2.1 光线步进<a class="headerlink" href="#id16" title="此标题的永久链接">#</a></h3>
<section id="post-processing">
<h4>2.1.1 后处理（Post Processing）<a class="headerlink" href="#post-processing" title="此标题的永久链接">#</a></h4>
<p>为什么要讲后处理，因为光线步进是<code class="docutils literal notranslate"><span class="pre">后处理</span></code>的一种。<br />
什么是“后”处理，指的是在某一阶段后进行的处理，所谓的某一阶段，最常见的是在一帧的画面渲染完成之后，在这张画面上再做其他的处理，这时一般称为<code class="docutils literal notranslate"><span class="pre">后处理</span></code>，而后处理的实现方式非常简单，在相机的面前（近截平面）上放上一片刚好铺满视界的面片，这是顶点着色器的工作，之后将之前绘制完的图片当成一张采样纹理贴在面片上，这是片元着色器的工作，这样片元着色器就可以遍历每一个纹理坐标进行采样，而这些坐标刚好和屏幕像素一一对应，以此就可以在绘制完图像后再进行一些后处理的加工了。<br />
常见的后处理比如<code class="docutils literal notranslate"><span class="pre">泛光(Bloom)</span></code>、<code class="docutils literal notranslate"><span class="pre">HDR</span></code>、<code class="docutils literal notranslate"><span class="pre">动态模糊</span></code>和<code class="docutils literal notranslate"><span class="pre">光线步进</span></code>等。</p>
</section>
<section id="id17">
<h4>2.1.2 光线步进原理<a class="headerlink" href="#id17" title="此标题的永久链接">#</a></h4>
<section id="id18">
<h5>2.1.2.1 光线<a class="headerlink" href="#id18" title="此标题的永久链接">#</a></h5>
<p>光线步进，是从一个起点出发，向某个方向，前进某个距离。如果以相机位置为起点，向每个像素发射一条光线，这样跟着每根光线进入场景与场景进行交互计算，我们最终可以计算出该像素的颜色信息。而后处理会遍历每一个像素，这正好满足我们的需求和直觉。</p>
<p><img alt="ray from camera" src="../_images/ray_from_camera.png" /></p>
<p>为了计算出这些射线，我们已知如下参数（CPU传递给GPU的）：</p>
<ol class="arabic simple">
<li><p>相机的世界坐标：cameraPos</p></li>
<li><p>相机看向的方向：forwardDir</p></li>
<li><p>相机到近截平面的距离: near</p></li>
<li><p>相机的视场角：fov</p></li>
<li><p>近截平面(或是视界窗口)的横纵比或纵横比: aspect</p></li>
</ol>
<p>注：计算光线步进的射线方向，有很多取巧的方式（比如插值等），这里将会使用最通俗易懂的那个方式计算（通俗易懂有时并不是最优解），有关取巧的方式将会在后文讲解。</p>
<p>如下示意图所示：</p>
<p><img alt="camera corrdinate" src="../_images/camera_coordinate.png" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">眼睛图标</span></code>处为相机起点，相机的世界坐标：cameraPos</p></li>
<li><p>橘色向量为相机看向的方向：forwardDir（注：下文对于forwardDir都是单位向量）</p></li>
<li><p>橘色向量虚线部分的长度为近截平面的长度（AB的长度）：near</p></li>
<li><p>底部紫色弧线为相机水平视场角（这里我们使用水平的，当然您也可以使用纵向的）：fov</p></li>
<li><p>近截平面上侧的紫色双向箭头为进阶平面的宽度（用于计算aspect）：width</p></li>
<li><p>近截平面左侧的紫色双向箭头为进阶平面的高度（用于计算aspect）：height</p></li>
</ul>
<p>为了计算出每个向外发射的光线向量，我们只需要知道每个<code class="docutils literal notranslate"><span class="pre">像素的世界坐标</span></code>和<code class="docutils literal notranslate"><span class="pre">相机的世界坐标</span></code>，将<code class="docutils literal notranslate"><span class="pre">像素的世界坐标</span></code>减去<code class="docutils literal notranslate"><span class="pre">相机的世界坐标</span></code>就是光线的向量了。</p>
<p><span class="math notranslate nohighlight">\(rayDir=pixelWorldPos-cameraWorldPos\)</span></p>
<p>而<code class="docutils literal notranslate"><span class="pre">像素的世界坐标</span></code>为：从<code class="docutils literal notranslate"><span class="pre">相机的世界坐标A</span></code>点出发走到<code class="docutils literal notranslate"><span class="pre">B（近截面中心点）</span></code>点，再从<code class="docutils literal notranslate"><span class="pre">B</span></code>点走向<code class="docutils literal notranslate"><span class="pre">近截平面上像素相对于相机的坐标</span></code>（世界坐标系下的）。</p>
<p><span class="math notranslate nohighlight">\(pixelWorldPos=\vec{AB}+ \vec{pixelRelativeCameraWorldPos}\)</span></p>
<p><span class="math notranslate nohighlight">\(\vec{AB}=cameraPos+forwardDir \times \mid near \mid\)</span></p>
<p>而<code class="docutils literal notranslate"><span class="pre">近截平面上像素相对于相机的坐标</span></code>意思是，以相机坐标为起点，以相机<code class="docutils literal notranslate"><span class="pre">向前</span></code>、<code class="docutils literal notranslate"><span class="pre">向上</span></code>和<code class="docutils literal notranslate"><span class="pre">向右</span></code>的三个向量作为正交基(三个向量，两两垂直)，表示的像素坐标。</p>
<p>如下图为从相机位置看向近截平面的示意图：</p>
<p><img alt="camera relative pos" src="../_images/camera_relative_pos.png" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cameraRightDir</span></code>是相机向右的世界坐标向量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cameraUpDir</span></code>是相机向上的世界坐标向量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code>为像素点<code class="docutils literal notranslate"><span class="pre">p</span></code>的横坐标</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h</span></code>为像素点<code class="docutils literal notranslate"><span class="pre">p</span></code>的纵坐标</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>点坐标为<code class="docutils literal notranslate"><span class="pre">近截平面上像素相对于相机的坐标</span></code>，即<code class="docutils literal notranslate"><span class="pre">pixelRelativeCameraWorldPos</span></code></p></li>
</ul>
<p>则<code class="docutils literal notranslate"><span class="pre">pixelRelativeCameraWorldPos</span></code>计算公式为：</p>
<p><span class="math notranslate nohighlight">\(\vec{pixelRelativeCameraWorldPos}=\vec{camerRightDir} \times w +\vec{camerUpDir} \times h\)</span></p>
<p>我们目前手头只有一个<code class="docutils literal notranslate"><span class="pre">相机看向的方向：forwardDir</span></code>，如何才能求出<code class="docutils literal notranslate"><span class="pre">相机向右：cameraRightDir</span></code>和<code class="docutils literal notranslate"><span class="pre">相机向上：cameraUpDir</span></code>呢？答案是:使用<code class="docutils literal notranslate"><span class="pre">叉乘</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">叉乘</span></code>可以计算出与两个向量都垂直的那个向量。</p>
<p>首先相机向前的向量与一个虚向上的向量做叉乘，这个虚向量一般为<code class="docutils literal notranslate"><span class="pre">upDir(0,1,0)</span></code></p>
<p><span class="math notranslate nohighlight">\(cameraRightDir=forwardDir \times upDir\)</span></p>
<p>之后<code class="docutils literal notranslate"><span class="pre">相机看向的方向：forwardDir</span></code>再与<code class="docutils literal notranslate"><span class="pre">相机向右：cameraRightDir</span></code>做叉乘，就可算出<code class="docutils literal notranslate"><span class="pre">相机向上：cameraUpDir</span></code></p>
<p><span class="math notranslate nohighlight">\(cameraUpDir=cameraRightDir \times forwardDir\)</span></p>
<p>这样相机的<code class="docutils literal notranslate"><span class="pre">向前</span></code>、<code class="docutils literal notranslate"><span class="pre">向上</span></code>和<code class="docutils literal notranslate"><span class="pre">向右</span></code>的三个正交基都得到了。</p>
<p>接下来，原式中还有<code class="docutils literal notranslate"><span class="pre">h</span></code>和<code class="docutils literal notranslate"><span class="pre">w</span></code>两个坐标参数，该如何计算呢？这就需要用到<code class="docutils literal notranslate"><span class="pre">fov</span></code>、<code class="docutils literal notranslate"><span class="pre">near</span></code>、<code class="docutils literal notranslate"><span class="pre">aspect</span></code>和<code class="docutils literal notranslate"><span class="pre">NDC</span></code>了</p>
<p>在计算<code class="docutils literal notranslate"><span class="pre">h</span></code>和<code class="docutils literal notranslate"><span class="pre">w</span></code>之前我们先来介绍一下<code class="docutils literal notranslate"><span class="pre">归一化设备坐标系（Normalized</span> <span class="pre">Device</span> <span class="pre">Coordinates）</span></code>简称<code class="docutils literal notranslate"><span class="pre">NDC</span></code>，简单来说NDC是坐标范围被限制在了在[-1,1]内的坐标空间，一般用于坐标映射。当在屏幕上的映射时NDC一般理解成二维的，NDC空间的（0,0）点代表窗口（视界）中心，（1,1）点代表窗口右上角，（-1，-1）代表左下角，以此类推。</p>
<p>如下图所示：</p>
<p><img alt="ndc" src="../_images/ndc.png" /></p>
<p>而对于构建这个坐标系非常的简单，由于在片元着色器中对传入纹理的采样坐标<code class="docutils literal notranslate"><span class="pre">uv</span></code>正好遍历整个视界上的所有像素。而且<code class="docutils literal notranslate"><span class="pre">uv</span></code>的每个分量的范围都在[0,1]之内，只要进行乘2减1的操作即可映射到NDC坐标系中。</p>
<p><span class="math notranslate nohighlight">\(NDCp=(fragUV\times 2)-1\)</span></p>
<p>这样我们就将近截平面上的点都映射到了[-1,1]的NDC空间中。之后只要对NDC空间坐标进行横向和纵向的缩放（近截面的一半宽和一半高）就可以很轻松的计算出像近截平面上像素的坐标。</p>
<p><span class="math notranslate nohighlight">\(p.w=NDCp.NDCw\times(\frac{width}{2})\)</span></p>
<p><span class="math notranslate nohighlight">\(p.h=NDCp.NDCw\times(\frac{height}{2})\)</span></p>
<p>而对于近截面的宽和高，如下图所示：</p>
<p><img alt="camera pixel pos" src="../_images/camera_pixel_pos.png" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">halfWidth</span></code>为半宽</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">halfHeight</span></code>为半高</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">near</span></code>为相机到近截平面的距离</p></li>
</ul>
<p>这样<code class="docutils literal notranslate"><span class="pre">halfWidth</span></code>为：</p>
<p><span class="math notranslate nohighlight">\(halfWidth=near\times tan(\frac{fov}{2})\)</span></p>
<p>而我们已经知道了<code class="docutils literal notranslate"><span class="pre">aspect</span></code>（CPU传入GPU的）</p>
<p><span class="math notranslate nohighlight">\(aspect=\frac{height}{height}\)</span></p>
<p>所以<code class="docutils literal notranslate"><span class="pre">halfHeight</span></code>为：</p>
<p><span class="math notranslate nohighlight">\(halfHeight=halfWidth\times aspect\)</span></p>
<p>至此，使用片元着色器遍历所有的像素即可算出所有像素的光线方向<code class="docutils literal notranslate"><span class="pre">rayDir</span></code></p>
<p>大致代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">layout</span><span class="p">(</span><span class="n">push_constant</span><span class="p">)</span><span class="w"> </span><span class="n">uniform</span><span class="w"> </span><span class="n">my_push_constants_t</span><span class="c1">//CPU传入GPU的数据</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">resolutionX</span><span class="p">;</span><span class="c1">//窗口分辨率宽</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">resolutionY</span><span class="p">;</span><span class="c1">//窗口分辨率高</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cameraPosX</span><span class="p">;</span><span class="c1">//相机位置世界坐标的x分量</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cameraPosY</span><span class="p">;</span><span class="c1">//相机位置世界坐标的y分量</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cameraPosZ</span><span class="p">;</span><span class="c1">//相机位置世界坐标的z分量</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lookForwardDirX</span><span class="p">;</span><span class="c1">//相机看向的向量在世界坐标系下的x分量</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lookForwardDirY</span><span class="p">;</span><span class="c1">//相机看向的向量在世界坐标系下的y分量</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lookForwardDirZ</span><span class="p">;</span><span class="c1">//相机看向的向量在世界坐标系下的z分量</span>
<span class="p">}</span><span class="n">my_push_constants</span><span class="p">;</span>

<span class="cp">#define PI 3.1415926</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">iTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">time</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec2</span><span class="w"> </span><span class="n">iResolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">resolutionX</span><span class="p">,</span><span class="w"> </span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">resolutionY</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec2</span><span class="w"> </span><span class="n">fragCoord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iResolution</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iResolution</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">cameraPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">cameraPosX</span><span class="p">,</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">cameraPosY</span><span class="p">,</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">cameraPosZ</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">lookForwardDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">lookForwardDirX</span><span class="p">,</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">lookForwardDirY</span><span class="p">,</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">lookForwardDirZ</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">forwardDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">lookForwardDirX</span><span class="p">,</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">lookForwardDirY</span><span class="p">,</span><span class="n">my_push_constants</span><span class="p">.</span><span class="n">lookForwardDirZ</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">upDir</span><span class="o">=</span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//虚的向上向量</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">rightDir</span><span class="o">=</span><span class="n">cross</span><span class="p">(</span><span class="n">forwardDir</span><span class="p">,</span><span class="n">upDir</span><span class="p">);</span><span class="c1">//计算相机向右的向量</span>
<span class="w">    </span><span class="n">upDir</span><span class="o">=</span><span class="n">cross</span><span class="p">(</span><span class="n">rightDir</span><span class="p">,</span><span class="n">forwardDir</span><span class="p">);</span><span class="c1">//计算相机向上的向量</span>

<span class="w">    </span><span class="n">forwardDir</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">forwardDir</span><span class="p">);</span><span class="c1">//归一化</span>
<span class="w">    </span><span class="n">rightDir</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">rightDir</span><span class="p">);</span><span class="c1">//归一化</span>
<span class="w">    </span><span class="n">upDir</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">upDir</span><span class="p">);</span><span class="c1">//归一化</span>

<span class="w">    </span><span class="n">vec2</span><span class="w"> </span><span class="n">screen_ndc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">2-1</span><span class="p">;</span><span class="c1">//将uv映射到归一化设备坐标系（Normalized Device Corrdinate&lt;NDC&gt;）:[-1,1]</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="c1">//近截平面的距离</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">aspect</span><span class="o">=</span><span class="w"> </span><span class="n">iResolution</span><span class="p">.</span><span class="n">y</span><span class="o">/</span><span class="n">iResolution</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="c1">//视界的高宽比：aspect=height/width</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">horizontalFov</span><span class="o">=</span><span class="w"> </span><span class="n">PI</span><span class="o">/</span><span class="mf">3.0</span><span class="p">;</span><span class="c1">//fov为60度</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">screenHalfWidth</span><span class="o">=</span><span class="n">near</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">horizontalFov</span><span class="o">/</span><span class="mf">2.0</span><span class="p">);</span><span class="c1">//计算近截平面宽度的一半</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">screenHalfHeight</span><span class="o">=</span><span class="n">screenHalfWidth</span><span class="o">*</span><span class="n">aspect</span><span class="p">;</span><span class="c1">//计算近截平面高度的一半</span>

<span class="w">    </span><span class="c1">//从相机位置出发</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">pixel_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cameraPos</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//向前移动近截平面near的长度，到近截平面上</span>
<span class="w">    </span><span class="n">pixel_pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">forwardDir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">near</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//在近截平面上根据像素坐标偏移、NDC坐标和对应方向向量做偏移</span>
<span class="w">    </span><span class="n">pixel_pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rightDir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">screen_ndc</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">screenHalfWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">upDir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">screen_ndc</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">screenHalfHeight</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//射线方向=像素位置-摄像机位置</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">rayDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pixel_pos</span><span class="o">-</span><span class="n">cameraPos</span><span class="p">;</span>
<span class="w">    </span><span class="n">rayDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">rayDir</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//从camerPos为起点，向rayDir方向进行步进循环</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RayMarch</span><span class="p">(</span><span class="n">cameraPos</span><span class="p">,</span><span class="n">rayDir</span><span class="p">);</span>
<span class="w">    </span><span class="n">outColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>具体的示例可参考<code class="docutils literal notranslate"><span class="pre">Turbo</span></code>引擎的<code class="docutils literal notranslate"><span class="pre">RaymarchingTest</span></code>示例</p>
<p><img alt="base_ray_marching" src="../_images/base_ray_marching.gif" /></p>
<section id="id19">
<h6>2.1.2.1.1 其他光线算法<a class="headerlink" href="#id19" title="此标题的永久链接">#</a></h6>
<p>有一个非常巧妙的方法来简化计算，就是使用顶点着色器传入片元着色器中，在光栅化阶段GPU设备会进行插值的特性。
当将在顶点着色器中传入近截平面的四个角的坐标等数据时，只需要顺便在顶点属性中增加每个顶点对应的射线方向（在CPU端计算，只需要算一个角即可，剩下三个就是对称，对称再对称），这样传入GPU的顶点属性就包括了每个顶点（每个角）的射线向量，之后直接将传入的顶点着色器的射线向量传入片元着色器中得到的对应向量数据就是该像素的光线方向向量。</p>
<p>大致代码如下</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//CPU</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VertexData</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">rayDir</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">vec3</span><span class="w"> </span><span class="n">corner0_ray_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cal_ray</span><span class="p">(...);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">corner1_ray_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symmetric</span><span class="p">(</span><span class="n">corner0_ray_dir</span><span class="p">,...);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">corner2_ray_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symmetric</span><span class="p">(</span><span class="n">corner0_ray_dir</span><span class="p">,...);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">corner3_ray_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symmetric</span><span class="p">(</span><span class="n">corner0_ray_dir</span><span class="p">,...);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">VertexData</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vertex_datas</span><span class="p">;</span>
<span class="n">vertex_datas</span><span class="p">.</span><span class="n">push_back</span><span class="p">({...,</span><span class="n">corner0_ray_dir</span><span class="p">});</span>
<span class="n">vertex_datas</span><span class="p">.</span><span class="n">push_back</span><span class="p">({...,</span><span class="n">corner1_ray_dir</span><span class="p">});</span>
<span class="n">vertex_datas</span><span class="p">.</span><span class="n">push_back</span><span class="p">({...,</span><span class="n">corner2_ray_dir</span><span class="p">});</span>
<span class="n">vertex_datas</span><span class="p">.</span><span class="n">push_back</span><span class="p">({...,</span><span class="n">corner3_ray_dir</span><span class="p">});</span>

<span class="n">context</span><span class="p">.</span><span class="n">bindVertexBuffer</span><span class="p">(</span><span class="n">vertex_datas</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//GPU</span>
<span class="c1">//vertex shader</span>
<span class="n">layout</span><span class="p">(...)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(...)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(...)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">rayDir</span><span class="p">;</span>

<span class="n">layout</span><span class="p">(...)</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">RayDir</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">VertexShader</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">RayDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rayDir</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//fragment shader</span>
<span class="n">layout</span><span class="p">(...)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">RayDir</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FragmentShader</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//每个像素的射线向量</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">pixel_ray_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RayDir</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id20">
<h5>2.1.2.2 步进循环<a class="headerlink" href="#id20" title="此标题的永久链接">#</a></h5>
<p>现在光线方向<code class="docutils literal notranslate"><span class="pre">rayDir</span></code>有了，光线起点<code class="docutils literal notranslate"><span class="pre">cameraPos</span></code>也有了。接下来就可以进入光线步进循环了。</p>
<p>步进循环本质上并不复杂，基本思路就是沿着光线方向向前走，每走一次就是一次步进循环。</p>
<p>大致代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">SomeResult</span><span class="w"> </span><span class="nf">RayMarch</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="n">vec3</span><span class="w"> </span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">SomeResult</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxstep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_STEP_COUNT</span><span class="p">;</span><span class="c1">//最大走几步</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STEP_LENGTH</span><span class="p">;</span><span class="w"> </span><span class="c1">//一步迈多远</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="c1">//走了多远</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxstep</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 从原点origin，向dir方向，走distance这么长的距离</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="c1">//...在p点做一些事情，比如采样之类的，并累积结果</span>
<span class="w">       </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">do_something_at_point</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//继续向前迈一步</span>
<span class="w">        </span><span class="n">distance</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">step</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//返回结果</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><img alt="camera pixel pos" src="../_images/raymarching.png" /></p>
<p>当然步进循环不一定非要是这样的，根据不同的需求，步进循环可以多种多样。</p>
<p>但是有一个最常用的步进循环，就是使用包围盒。包围盒一般会使用一个四方体盒子，在这个盒子内部进行光线步进循环。</p>
<p>还有一种比较常见的是使用一个包围球进行步进循环。在体积云渲染中，为了模拟云层蔓延到地平线，使用了两个球心相同，半径不同的两个包围球来模拟地球大气层的基本形状，并在其中进行光线步进循环。此种包围体我们后面也会介绍。</p>
<p><img alt="camera pixel pos" src="../_images/bounding_sphere.png" /></p>
</section>
</section>
<hr class="docutils" />
<section id="id21">
<h4>2.1.3 包围盒<a class="headerlink" href="#id21" title="此标题的永久链接">#</a></h4>
<p>包围盒就是个四方体，光线将会在包围盒内部进行步进。随之而来的问题就是，如何描述该包围盒呢？光线在包围盒内进行步进，那在盒子内部步进的起点和终点在哪呢？</p>
<section id="id22">
<h5>2.1.3.1 描述包围盒<a class="headerlink" href="#id22" title="此标题的永久链接">#</a></h5>
<ul>
<li><p>包围盒是个四方体，必然会有长、宽、高。</p>
<ul>
<li><p>对于描述四方体的长、宽、高，则使用从四方体中心点为起点，以斜对角线上的一个角为终点的向量<code class="docutils literal notranslate"><span class="pre">halfDiagonal</span></code>“半斜向量”，该向量的每个分量分别作为包围盒的半长<code class="docutils literal notranslate"><span class="pre">halfStrip</span></code>、半宽<code class="docutils literal notranslate"><span class="pre">halfWidth</span></code>、半高<code class="docutils literal notranslate"><span class="pre">halfHeight</span></code>。</p>
<p>注：这里<code class="docutils literal notranslate"><span class="pre">长</span></code>起名叫<code class="docutils literal notranslate"><span class="pre">strip</span></code>，是为了和着色器内置函数<code class="docutils literal notranslate"><span class="pre">length()</span></code>作区分，和示例代码中<code class="docutils literal notranslate"><span class="pre">长</span></code>命名<code class="docutils literal notranslate"><span class="pre">strip</span></code>保持一致</p>
</li>
</ul>
</li>
<li><p>盒子会有位置<code class="docutils literal notranslate"><span class="pre">position</span></code></p></li>
<li><p>盒子会有姿态，会有一个向量描述其朝向<code class="docutils literal notranslate"><span class="pre">forward</span></code></p></li>
</ul>
<p><img alt="camera pixel pos" src="../_images/bounding_box.png" /></p>
<p>这样，我们就可以描述一个包围盒了。</p>
<p>代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">BoundingBox</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">forwardDir</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">halfDiagonalVector</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="id23">
<h5>2.1.3.2 包围盒中步进的起点和终点<a class="headerlink" href="#id23" title="此标题的永久链接">#</a></h5>
<p>首先能想到的是，起点和终点会在光线与盒子的交点处，求交点，最终回到了，如何求射线与平面的交点问题</p>
<blockquote>
<div><p>射线与平面求交</p>
</div></blockquote>
<ul class="simple">
<li><p>射线：一个起点，一个方向</p></li>
<li><p>平面：一个平面上的点，一个平面法线（点法式）</p></li>
</ul>
<p>如下图所示：<br />
<img alt="camera pixel pos" src="../_images/ray_surface_intersect.png" /></p>
<ul class="simple">
<li><p>射线：<code class="docutils literal notranslate"><span class="pre">o</span></code>点为射线起点<code class="docutils literal notranslate"><span class="pre">rayOrigin</span></code>,向量 <span class="math notranslate nohighlight">\(\vec{r}\)</span> 为射线方向<code class="docutils literal notranslate"><span class="pre">rayDir</span></code>。</p></li>
<li><p>平面：<code class="docutils literal notranslate"><span class="pre">p</span></code>点为平面上一点<code class="docutils literal notranslate"><span class="pre">point</span></code>,向量 <span class="math notranslate nohighlight">\(\vec{n}\)</span> 为平面法线<code class="docutils literal notranslate"><span class="pre">normal</span></code>。</p></li>
<li><p>交点：<code class="docutils literal notranslate"><span class="pre">i</span></code>点为平面与射线的交点</p></li>
</ul>
<p>首先刨除当 <span class="math notranslate nohighlight">\(\vec{r}\)</span> 和 <span class="math notranslate nohighlight">\(\vec{n}\)</span>垂直的情况，也就是射线方向平行于平面，将永远不会有交点</p>
<p>由于交点<code class="docutils literal notranslate"><span class="pre">i</span></code>在平面上，所以可知 <span class="math notranslate nohighlight">\(\vec{pi}\)</span> 与 <span class="math notranslate nohighlight">\(\vec{n}\)</span> 垂直，这样可知：<br />
① <span class="math notranslate nohighlight">\(\vec{pi}* \vec{n}=0\)</span> 注：点乘</p>
<p>又因为点<code class="docutils literal notranslate"><span class="pre">i</span></code>在过射线，加入射线从<code class="docutils literal notranslate"><span class="pre">o</span></code>点出发，沿着向量 <span class="math notranslate nohighlight">\(\vec{r}\)</span> 走了 <span class="math notranslate nohighlight">\(l\)</span> 距离到达<code class="docutils literal notranslate"><span class="pre">i</span></code>点，这样可知：<br />
② <span class="math notranslate nohighlight">\(i=p+\vec{r}* l\)</span></p>
<p>这样①和②式子联立：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}
\left\{
\begin{array}{c}
    \vec{pi}*\vec{n}=0 \\
    i=p+\vec{r}* l \\
\end{array}
\right.
\end{split}\]</div>
</div>
<p>首先将②式展开：<br />
<span class="math notranslate nohighlight">\(i=(o_x+r_x l, o_y+r_y l,o_z+r_z l)\)</span></p>
<p>再将 <span class="math notranslate nohighlight">\(\vec{pi}\)</span> 展开<br />
<span class="math notranslate nohighlight">\(\vec{pi}=(i_x-p_x, i_y-p_y, i_z-p_z)\)</span></p>
<p>其中<br />
<span class="math notranslate nohighlight">\(i_x=o_x+r_x l\)</span><br />
<span class="math notranslate nohighlight">\(i_y=o_y+r_y l\)</span><br />
<span class="math notranslate nohighlight">\(i_z=o_z+r_z l\)</span></p>
<p>这样 <span class="math notranslate nohighlight">\(\vec{pi}\)</span> 可展开成③式<br />
③ <span class="math notranslate nohighlight">\(\vec{pi}=(o_x+r_x l-p_x, o_y+r_y l-p_y, o_z+r_z l-p_z)\)</span></p>
<p>之后③再与 <span class="math notranslate nohighlight">\(\vec{n}\)</span> 求点乘等于零进行展开：<br />
<span class="math notranslate nohighlight">\(\vec{pi}*\vec{n}=(o_x+r_x l-p_x)\times n_x+(o_y+r_y l-p_y)\times n_y+(o_z+r_z l-p_z)\times n_z=0\)</span></p>
<p>最终整理得：</p>
<p><span class="math notranslate nohighlight">\(l=\frac{\vec{p}*\vec{n}-\vec{o}*\vec{n}}{\vec{r}*\vec{n}}\)</span> 注：<span class="math notranslate nohighlight">\(\vec{p}\)</span> 为<code class="docutils literal notranslate"><span class="pre">p</span></code>点坐标，<span class="math notranslate nohighlight">\(\vec{o}\)</span> 为<code class="docutils literal notranslate"><span class="pre">o</span></code>点坐标，<code class="docutils literal notranslate"><span class="pre">*</span></code>为点乘</p>
<p>知道了 <span class="math notranslate nohighlight">\(l\)</span> 就可以由②式求出交点 <span class="math notranslate nohighlight">\(i\)</span> 了。</p>
<p>代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//结构体：点法式平面</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Surface</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">point</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">normal</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">rayOrigin</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">rayDir</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">surfacePoint</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">surfaceNormal</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//如果射线方向和平面平行（与平面法线垂直），则永远没有交点</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">rayDir</span><span class="p">,</span><span class="w"> </span><span class="n">surfaceNormal</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">ray_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">rayDir</span><span class="p">);</span>
<span class="w">    </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">surfacePoint</span><span class="p">,</span><span class="w"> </span><span class="n">surface_normal</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">rayOrigin</span><span class="p">,</span><span class="w"> </span><span class="n">surface_normal</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">ray_dir</span><span class="p">,</span><span class="w"> </span><span class="n">surface_normal</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>好了，现在我们能够求出任意平面与射线的交点了，又有个问题，平面无限大，交点可以遍布整个平面，而包围盒的面只是一个平面的很小一部分，该如何判断交点是否在包围盒对应平面内呢？</p>
<p>对于这个问题，可以换个问法：空间中任意一点，如何判断此点是否在包围盒内（包括包围盒面上的点，也算在包围盒）？</p>
<blockquote>
<div><p>点是否在包围盒内</p>
</div></blockquote>
<p>这个问题其实很好解决，我们有包围盒的位置和向前的向量，使用向前的向量就可以构建包围盒的正交基（注：同前文计算相机的正交基原理一样），有了正交基，计算以包围盒位置为起点，空间中任一点为终点，计算出一个向量，该向量分别对包围盒的正交基做投影，这样就可以知道该向量在每个轴投影的长，宽，高，只要其中一个分量大于对应的长度或宽度或高度，则该点不在包围盒内，反之则位于包围盒内。</p>
<p>首先计算包围盒的正交基（原理同前文的相机正交基，这里就不再赘述）：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//结构体：包围盒的正交基</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BoudingBoxOrthogonalBasis</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">forward</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">up</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//获得包围盒的正交基</span>
<span class="n">BoudingBoxOrthogonalBasis</span><span class="w"> </span><span class="nf">GetBoundingBoxOrthogonalBasis</span><span class="p">(</span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BoudingBoxOrthogonalBasis</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">.</span><span class="n">forwardDir</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cross</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span><span class="w"> </span><span class="n">up</span><span class="p">);</span>
<span class="w">    </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cross</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">forward</span><span class="p">);</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">forward</span><span class="p">);</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">up</span><span class="p">);</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>之后计算包围盒的长宽高，方便后续计算：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//结构体：包围盒的尺寸（长宽高）</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BoundingBoxSize</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">strip</span><span class="p">;</span><span class="w"> </span><span class="c1">// length（length名称和GLSL的length(...)函数重名了，导致报错，改成strip）</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//获得包围盒的长宽高</span>
<span class="n">BoundingBoxSize</span><span class="w"> </span><span class="nf">GetBoundingBoxSize</span><span class="p">(</span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BoundingBoxSize</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">half_diagonal_vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">.</span><span class="n">halfDiagonalVector</span><span class="p">;</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">strip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">half_diagonal_vector</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">half_diagonal_vector</span><span class="p">.</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">half_diagonal_vector</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>之后判断点是否在包围盒内</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsPointInBoundingBox</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//包围盒的位置</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//包围盒到Point点的向量</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_to_point_vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//获得包围盒的正交基</span>
<span class="w">    </span><span class="n">BoudingBoxOrthogonalBasis</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxOrthogonalBasis</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//获得包围盒的长、宽、高</span>
<span class="w">    </span><span class="n">BoundingBoxSize</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxSize</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="p">.</span><span class="n">forward</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//目标向量分别向正交基的每个基向量做投影</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">project_bounding_box_forward_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">bounding_box_to_point_vector</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_forward</span><span class="p">));</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">project_bounding_box_up_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">bounding_box_to_point_vector</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_up</span><span class="p">));</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">project_bounding_box_right_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">bounding_box_to_point_vector</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_right</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//计算包围盒半长用于比较</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">bounding_box_half_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">bounding_box_half_height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">bounding_box_half_strip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">strip</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//注意：这里是降噪的关键，GPU浮点计算精度太高，不进行精度降低会有大量噪点</span>
<span class="w">    </span><span class="c1">//没有降噪：https://www.bilibili.com/video/BV1MG4y1Z7jy/?spm_id_from=333.999.0.0</span>
<span class="w">    </span><span class="c1">//降噪矫正：https://www.bilibili.com/video/BV1224y117Nt/?spm_id_from=333.999.0.0</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">little_compensate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0005</span><span class="p">;</span>
<span class="w">    </span><span class="n">bounding_box_half_width</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">little_compensate</span><span class="p">;</span>
<span class="w">    </span><span class="n">bounding_box_half_height</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">little_compensate</span><span class="p">;</span>
<span class="w">    </span><span class="n">bounding_box_half_strip</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">little_compensate</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//判断是否超出范围，超出了，则返回false</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">project_bounding_box_forward_length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bounding_box_half_width</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">project_bounding_box_up_length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bounding_box_half_height</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">project_bounding_box_right_length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bounding_box_half_strip</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//在盒子内返回true</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在求平面上交点有了，求点是否在平面范围内也有了，接下来就整合在一起，进行射线与包围盒求交</p>
<blockquote>
<div><p>射线与包围盒交点</p>
</div></blockquote>
<p>首先是获取包围盒六个面的表，基本思想就是沿着包围盒的正交基的每个轴计算每个面的点和法线。</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//结构体：包围盒的六个面</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BoudingBoxSurfaces</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Surface</span><span class="w"> </span><span class="n">positiveForwardSurface</span><span class="p">;</span>
<span class="w">    </span><span class="n">Surface</span><span class="w"> </span><span class="n">negativeForwardSurface</span><span class="p">;</span>

<span class="w">    </span><span class="n">Surface</span><span class="w"> </span><span class="n">positiveUpSurface</span><span class="p">;</span>
<span class="w">    </span><span class="n">Surface</span><span class="w"> </span><span class="n">negativeUpSurface</span><span class="p">;</span>

<span class="w">    </span><span class="n">Surface</span><span class="w"> </span><span class="n">positiveRightSurface</span><span class="p">;</span>
<span class="w">    </span><span class="n">Surface</span><span class="w"> </span><span class="n">negativeRightSurface</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//获得包围盒的六个面</span>
<span class="n">BoudingBoxSurfaces</span><span class="w"> </span><span class="nf">GetBoundingBoxSurfaces</span><span class="p">(</span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BoudingBoxSurfaces</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">    </span><span class="n">BoudingBoxOrthogonalBasis</span><span class="w"> </span><span class="n">bouding_box_orthogonal_basis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxOrthogonalBasis</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">    </span><span class="n">BoundingBoxSize</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxSize</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">strip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">strip</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bouding_box_orthogonal_basis</span><span class="p">.</span><span class="n">forward</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bouding_box_orthogonal_basis</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bouding_box_orthogonal_basis</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_forward_surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">forward</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_forward_surface_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">positive_forward_surface_normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_forward_surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">positive_forward_surface_normal</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_forward_surface_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">negative_forward_surface_normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_up_surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_up_surface_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">positive_up_surface_normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_up_surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">positive_up_surface_normal</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_up_surface_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">negative_up_surface_normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_right_surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_right_surface_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">positive_right_surface_normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">strip</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_right_surface_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">positive_right_surface_normal</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_right_surface_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">negative_right_surface_normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">strip</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">positiveForwardSurface</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positive_forward_surface_point</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">positiveForwardSurface</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positive_forward_surface_normal</span><span class="p">;</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">negativeForwardSurface</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">negative_forward_surface_point</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">negativeForwardSurface</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">negative_forward_surface_normal</span><span class="p">;</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">positiveUpSurface</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positive_up_surface_point</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">positiveUpSurface</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positive_up_surface_normal</span><span class="p">;</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">negativeUpSurface</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">negative_up_surface_point</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">negativeUpSurface</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">negative_up_surface_normal</span><span class="p">;</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">positiveRightSurface</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positive_right_surface_point</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">positiveRightSurface</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positive_right_surface_normal</span><span class="p">;</span>

<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">negativeRightSurface</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">negative_right_surface_point</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">negativeRightSurface</span><span class="p">.</span><span class="n">normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">negative_right_surface_normal</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在六个面有了，对这六个面，每个面进行求交运算得出交点，之后判断该交点是否属于包围盒内部，属于包围盒内部的话则保留并进行之后的运算，如果不属于包围盒范围则直接返回，结束计算。</p>
<p>我们的最终目的是求出一条射线在包围盒内步进的启点和终点。</p>
<p>而一条直线与包围盒求交有三种情况</p>
<ol class="arabic simple">
<li><p>没有交点：此种情况直接结束计算</p></li>
<li><p>有一个交点，这种情况只会发生在包围盒的边缘：此种情况直接结束计算。</p></li>
<li><p>有两个交点，而有两个交点的情况又分三种</p></li>
</ol>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}
两个交点
\left\{
\begin{array}{c}
    两个交点都在相机前方 \\
    一个点在相机后方，一个点在相机前方 \\
    两个点都在相机后方 \\
\end{array}
\right.
\end{split}\]</div>
</div>
<p>如下图为相机在包围盒外你，面对包围盒</p>
<p><img alt="camera pixel pos" src="../_images/intersect_case_out_box_forward.png" /></p>
<ul class="simple">
<li><p>A点为起点，B点为终点，为两个交点情况,此时La，Lb均为正数</p></li>
<li><p>C为一个交点情况，Lc为正数，此种情况直接结束计算并返回</p></li>
</ul>
<p>如下图相机在包围盒内</p>
<p><img alt="camera pixel pos" src="../_images/intersect_case_in_box.png" /></p>
<p>其中A，B两点为交点，相交于A点的交点由于其La是负值，说明在相机背后，如果交点到相机的距离量为负值，则将负值的那个交点丢弃，换成射线的起点C作为与包围盒的起点，点B作为终点。</p>
<p>如下图相机在包围盒外，背对包围盒</p>
<p><img alt="camera pixel pos" src="../_images/intersect_case_out_box_backward.png" /></p>
<p>此时A，B两个交点都在相机背后。La和Lb的长度都为负数，此时表示没有交点，直接结束计算即可。</p>
<p>代码大致如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//结构体：射线与包围盒交点信息</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BoundingBoxIntersections</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">firstInterectionPos</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">secondInterectionPos</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">//光线与包围盒求交，并返回所有交点</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">BoundingBoxIntersect</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">BoundingBoxIntersections</span><span class="w"> </span><span class="n">intersections</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//获取包围盒的六个面</span>
<span class="w">    </span><span class="n">BoudingBoxSurfaces</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxSurfaces</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//计算六个面，每个面是否相交，相交的话将返回交点到射线起点的距离</span>
<span class="w">    </span><span class="c1">//注意：这个返回的距离有正，负的区别</span>
<span class="w">    </span><span class="c1">//正数表示交点在相机前方，负数表示交点在相机后方</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ray_origin_to_positive_forward_surface_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_positive_forward_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="p">.</span><span class="n">positiveForwardSurface</span><span class="p">,</span><span class="w"> </span><span class="n">ray_origin_to_positive_forward_surface_distance</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ray_origin_to_negative_forward_surface_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_negative_forward_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="p">.</span><span class="n">negativeForwardSurface</span><span class="p">,</span><span class="w"> </span><span class="n">ray_origin_to_negative_forward_surface_distance</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ray_origin_to_positive_up_surface_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_positive_up_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="p">.</span><span class="n">positiveUpSurface</span><span class="p">,</span><span class="w"> </span><span class="n">ray_origin_to_positive_up_surface_distance</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ray_origin_to_negative_up_surface_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_negative_up_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="p">.</span><span class="n">negativeUpSurface</span><span class="p">,</span><span class="w"> </span><span class="n">ray_origin_to_negative_up_surface_distance</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ray_origin_to_positive_right_surface_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_positive_right_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="p">.</span><span class="n">positiveRightSurface</span><span class="p">,</span><span class="w"> </span><span class="n">ray_origin_to_positive_right_surface_distance</span><span class="p">);</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ray_origin_to_negative_right_surface_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_negative_right_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalRaySurafaceIntersectDistance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box_surface</span><span class="p">.</span><span class="n">negativeRightSurface</span><span class="p">,</span><span class="w"> </span><span class="n">ray_origin_to_negative_right_surface_distance</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//查看是否有交点</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_forward_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_forward_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//计算交点位置</span>
<span class="w">        </span><span class="n">positive_forward_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ray_origin_to_positive_forward_surface_distance</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//查看交点是否在包围盒范围内</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_point_in_bounding_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsPointInBoundingBox</span><span class="p">(</span><span class="n">positive_forward_surface_intersection</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_point_in_bounding_box</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//如果不在包围盒内部，说明没相交，将相交状态置成false</span>
<span class="w">            </span><span class="n">is_positive_forward_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//下同 略</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_forward_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_forward_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">negative_forward_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ray_origin_to_negative_forward_surface_distance</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_point_in_bounding_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsPointInBoundingBox</span><span class="p">(</span><span class="n">negative_forward_surface_intersection</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_point_in_bounding_box</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">is_negative_forward_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_up_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_up_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">positive_up_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ray_origin_to_positive_up_surface_distance</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_point_in_bounding_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsPointInBoundingBox</span><span class="p">(</span><span class="n">positive_up_surface_intersection</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_point_in_bounding_box</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">is_positive_up_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_up_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_up_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">negative_up_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ray_origin_to_negative_up_surface_distance</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_point_in_bounding_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsPointInBoundingBox</span><span class="p">(</span><span class="n">negative_up_surface_intersection</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_point_in_bounding_box</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">is_negative_up_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">positive_right_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_right_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">positive_right_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ray_origin_to_positive_right_surface_distance</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_point_in_bounding_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsPointInBoundingBox</span><span class="p">(</span><span class="n">positive_right_surface_intersection</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_point_in_bounding_box</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">is_positive_right_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">negative_right_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_right_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">negative_right_surface_intersection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ray_origin_to_negative_right_surface_distance</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_point_in_bounding_box</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsPointInBoundingBox</span><span class="p">(</span><span class="n">negative_right_surface_intersection</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_point_in_bounding_box</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">is_negative_right_surface_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//统计交点个数</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_forward_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_forward_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_up_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_up_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_right_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_right_surface_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersection_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//如果没有交点，直接返回，结束计算</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">intersection_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//如果交点个数为1，说明在包围盒边缘相交，直接返回，结束计算</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">intersection_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//如果有两个交点</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">intersection_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//统计两个交点到射线起点的距离量</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span><span class="n">uint</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_forward_surface_intersect</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ray_origin_to_positive_forward_surface_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_forward_surface_intersect</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ray_origin_to_negative_forward_surface_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_up_surface_intersect</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ray_origin_to_positive_up_surface_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_up_surface_intersect</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ray_origin_to_negative_up_surface_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_positive_right_surface_intersect</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ray_origin_to_positive_right_surface_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_negative_right_surface_intersect</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ray_origin_to_negative_right_surface_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">//得到距离量之间的最小值，和最大值。</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">min_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">max_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">origin_to_surface_distance</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">//如果两个距离量都大于零，说明交点在相机前方</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">min_distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">max_distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">intersections</span><span class="p">.</span><span class="n">firstInterectionPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">min_distance</span><span class="p">;</span>
<span class="w">            </span><span class="n">intersections</span><span class="p">.</span><span class="n">secondInterectionPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">max_distance</span><span class="p">;</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">//如果一个小于零，一个大于零，说明相机在包围盒内部，将起点设置成射线起点</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">min_distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">max_distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">intersections</span><span class="p">.</span><span class="n">firstInterectionPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="p">;</span>
<span class="w">            </span><span class="n">intersections</span><span class="p">.</span><span class="n">secondInterectionPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">max_distance</span><span class="p">;</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>至此，我们就计算出基于包围盒的光线步进的起点和终点了<code class="docutils literal notranslate"><span class="pre">BoundingBoxIntersections</span></code>，接下来就在包围盒内进行光线步进即可。<br />
详情可参考<code class="docutils literal notranslate"><span class="pre">Turbo</span></code>引擎的<code class="docutils literal notranslate"><span class="pre">RayMarchingBoundingBoxTest</span></code>示例。</p>
<p><img alt="camera pixel pos" src="../_images/ray_marching_bounding_box.gif" /></p>
</section>
</section>
<section id="id24">
<h4>2.1.4 包围盒内光线步进<a class="headerlink" href="#id24" title="此标题的永久链接">#</a></h4>
<p>现在我们已经知道了光线步进循环要计算的起点和终点，现在我们就可以在其包围盒中进行光线步进计算了。</p>
<p>大致代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">RayMarchingBoundingBox</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">//声明返回结果</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">BoundingBoxIntersections</span><span class="w"> </span><span class="n">intersections</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//判断是否相交并获取交点intersections</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BoundingBoxIntersect</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">,</span><span class="w"> </span><span class="n">intersections</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//如果有交点，进行光线步进循环</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//开始位置</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">start_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersections</span><span class="p">.</span><span class="n">firstInterectionPos</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//结束位置</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">end_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersections</span><span class="p">.</span><span class="n">secondInterectionPos</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//最大步数，该值可根据性能调整</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">max_step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//计算迈一步需要多长</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">end_pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_pos</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">max_step</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//起始位置设置成开始位置</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pos</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//开始包围盒内的光线步进循环</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_step</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//计算当前采样点位置</span>
<span class="w">            </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">;</span>

<span class="w">            </span><span class="c1">//&lt;待定，用于在采样点处做计算&gt;</span>
<span class="w">            </span><span class="c1">//...</span>
<span class="w">            </span><span class="c1">//&lt;/待定，用于在采样点处做计算&gt;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>光线步进的重头戏就在<code class="docutils literal notranslate"><span class="pre">&lt;待定，用于在采样点处做计算&gt;</span></code>标签之间，这之间是在步进采样点<code class="docutils literal notranslate"><span class="pre">point</span></code>上做的一系列计算。</p>
<p>在这里我们目前主要是使用<code class="docutils literal notranslate"><span class="pre">point</span></code>到之前生成的三维噪音纹理中采样，而对于三维噪音纹理采样，采样点的范围为[0,1]，所以需要将<code class="docutils literal notranslate"><span class="pre">point</span></code>点坐标映射到[0,1]范围内。而映射算法也很简单，获得<code class="docutils literal notranslate"><span class="pre">point</span></code>对应于包围盒各正交基轴，投影的长宽高，与包围盒的长宽高分别相除即可。为了方便计算我们使用包围盒的右下角为采样坐标系坐标原点，包围盒<code class="docutils literal notranslate"><span class="pre">forward</span></code>的相反向量作为为采样坐标系的<code class="docutils literal notranslate"><span class="pre">z</span></code>轴，包围盒<code class="docutils literal notranslate"><span class="pre">right</span></code>的相反向量作为为采样坐标系的<code class="docutils literal notranslate"><span class="pre">x</span></code>轴，包围盒<code class="docutils literal notranslate"><span class="pre">up</span></code>的量作为为采样坐标系的<code class="docutils literal notranslate"><span class="pre">y</span></code>轴。如下图所示。</p>
<p><img alt="camera pixel pos" src="../_images/bounding_box_sample_space.png" /></p>
<p>代码大致如下</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// 获取盒子内点相对三维噪音纹理采样点</span>
<span class="n">vec3</span><span class="w"> </span><span class="nf">GetSamplePointPosition</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">BoundingBoxSize</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxSize</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>
<span class="w">    </span><span class="n">BoudingBoxOrthogonalBasis</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetBoundingBoxOrthogonalBasis</span><span class="p">(</span><span class="n">boundingBox</span><span class="p">);</span>

<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="p">.</span><span class="n">forward</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">bounding_box_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_orthogonal_basis</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//计算包围盒左下角位置，作为纹理采样的原点</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">lower_right_corner_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounding_box_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bounding_box_forward</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bounding_box_up</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bounding_box_right</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">strip</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//计算包围盒左下角到采样点的向量lower_right_corner_to_point</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">lower_right_corner_to_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lower_right_corner_pos</span><span class="p">;</span>

<span class="w">    </span><span class="c1">//计算采样空间的坐标轴</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">lower_right_corner_strip_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">bounding_box_right</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">));</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">lower_right_corner_up_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">bounding_box_up</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">lower_right_corner_width_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">bounding_box_forward</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">-1</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//计算lower_right_corner_to_point向量到每个采样空间各个正交基的轴的长度，与之前计算点是否在包围盒内原理相同</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">project_strip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">lower_right_corner_to_point</span><span class="p">,</span><span class="w"> </span><span class="n">lower_right_corner_strip_dir</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">project_height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">lower_right_corner_to_point</span><span class="p">,</span><span class="w"> </span><span class="n">lower_right_corner_up_dir</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">project_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">lower_right_corner_to_point</span><span class="p">,</span><span class="w"> </span><span class="n">lower_right_corner_width_dir</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//分别除以长、宽、高对应对应长度将采样点分为映射到[0,1]</span>
<span class="w">    </span><span class="c1">//注：非绝对[0,1]，其实这里映射到[0,1]的限制很宽松，可以跑出[0,1]范围</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="n">project_strip</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">strip</span><span class="p">,</span><span class="w"> </span><span class="n">project_height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">project_width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bounding_box_size</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样就可以计算出盒子中一点的三维纹理采样坐标了。</p>
<p>如果将之前的<code class="docutils literal notranslate"><span class="pre">&lt;待定，用于在采样点处做计算&gt;</span></code>之间的代码改成如下：</p>
<p>将采样点坐标作为颜色值输出</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">sample_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSamplePointPosition</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="n">sample_point</span><span class="p">;</span>
</pre></div>
</div>
<p>将会得到如下结果：</p>
<p>注：色块抖动是<code class="docutils literal notranslate"><span class="pre">GIF</span></code>转换对录像处理了的结果</p>
<p><img alt="camera pixel pos" src="../_images/ray_marching_bounding_box_sample_space.gif" /></p>
<p>现在光线步进循环有了，采样点也有了，接下来就是对噪音纹理进行采样了</p>
<section id="id25">
<h5>2.1.4.1 包围盒内三维纹理采样<a class="headerlink" href="#id25" title="此标题的永久链接">#</a></h5>
<p>我们目前主要是对之前计算的柏林-沃利噪音进行采样。<br />
将<code class="docutils literal notranslate"><span class="pre">&lt;待定，用于在采样点处做计算&gt;</span></code>之间的代码改成如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//外部传入计算好的柏林-沃利三维噪音</span>
<span class="n">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">uniform</span><span class="w"> </span><span class="n">texture3D</span><span class="w"> </span><span class="n">perlinWorleyNoise</span><span class="p">;</span>
<span class="c1">//外部传入的三维纹理采样器</span>
<span class="n">layout</span><span class="p">(</span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">uniform</span><span class="w"> </span><span class="n">sampler</span><span class="w"> </span><span class="n">mySampler</span><span class="p">;</span>

<span class="c1">//计算采样坐标</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">sample_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSamplePointPosition</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
<span class="c1">//进行采样</span>
<span class="n">vec4</span><span class="w"> </span><span class="n">fbm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">sampler3D</span><span class="p">(</span><span class="n">perlinWorleyNoise</span><span class="p">,</span><span class="w"> </span><span class="n">mySampler</span><span class="p">),</span><span class="w"> </span><span class="n">sample_point</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="c1">//其中</span>
<span class="c1">//fbm.x为柏林-沃利噪音值</span>
<span class="c1">//fbm.yzw分别为不同频率的沃利噪音</span>
<span class="kt">float</span><span class="w"> </span><span class="n">perlin_worley</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fbm</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">worleys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fbm</span><span class="p">.</span><span class="n">yzw</span><span class="p">;</span>

<span class="c1">//叠加FBM</span>
<span class="kt">float</span><span class="w"> </span><span class="n">worly_fbm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worleys</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.625</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">worleys</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.125</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">worleys</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cloud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remap</span><span class="p">(</span><span class="n">perlin_worley</span><span class="p">,</span><span class="w"> </span><span class="n">worly_fbm</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="c1">//计算云的基础形状</span>
<span class="c1">//coverage 为外部传给着色器的范围在[0,1]，用于控制云体覆盖率</span>
<span class="n">cloud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remap</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">coverage</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
</pre></div>
</div>
<p>渲染结果如下：</p>
<p><img alt="camera pixel pos" src="../_images/ray_marching_bounding_box_sample_3d_noise.gif" /></p>
<p>你会发现会有生硬的一圈圈的条纹状结果，之所以会出现这种现象是因为采样步长都是定长，这就会导致上一步和下一步之间的过渡数据被完全忽略，为了解决此问题，只需要在采样点临域内随机做个位移即可，宏观上看就是采样点随机“抖动”。（还有一种方案是“抖动”射线的起点或者是射线的方向，无论是什么方式，最终都是随机偏移采样点）</p>
<p>我们使用之前的<code class="docutils literal notranslate"><span class="pre">hash(...)</span></code>函数生成一个随机值，以此来抖动采样点。</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">//使用hash(...)函数抖动采样点</span>
<span class="c1">//其中vec3(12.256, 2.646, 6.356)随便写的，也可以是其他的</span>
<span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">12.256</span><span class="p">,</span><span class="w"> </span><span class="mf">2.646</span><span class="p">,</span><span class="w"> </span><span class="mf">6.356</span><span class="p">)));</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">sample_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSamplePointPosition</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>
</pre></div>
</div>
<p>渲染结果如下：</p>
<p><img alt="camera pixel pos" src="../_images/ray_marching_bounding_box_sample_3d_noise_erase_strip.gif" /></p>
<p>完整渲染代码如下：</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="nf">RayMarchingBoundingBox</span><span class="p">(</span><span class="n">vec3</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">BoundingBox</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">coverage</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">vec3</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">BoundingBoxIntersections</span><span class="w"> </span><span class="n">intersections</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_intersect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BoundingBoxIntersect</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">dir</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">,</span><span class="w"> </span><span class="n">intersections</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_intersect</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">start_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersections</span><span class="p">.</span><span class="n">firstInterectionPos</span><span class="p">;</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">end_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersections</span><span class="p">.</span><span class="n">secondInterectionPos</span><span class="p">;</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">max_step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">end_pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_pos</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">max_step</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//光衰系数</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//辐射亮度</span>
<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">radiance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">vec3</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pos</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_step</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">12.256</span><span class="p">,</span><span class="w"> </span><span class="mf">2.646</span><span class="p">,</span><span class="w"> </span><span class="mf">6.356</span><span class="p">)));</span>
<span class="w">            </span><span class="n">vec3</span><span class="w"> </span><span class="n">sample_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSamplePointPosition</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">boundingBox</span><span class="p">);</span>

<span class="w">            </span><span class="n">vec4</span><span class="w"> </span><span class="n">fbm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texture</span><span class="p">(</span><span class="n">sampler3D</span><span class="p">(</span><span class="n">perlinWorleyNoise</span><span class="p">,</span><span class="w"> </span><span class="n">mySampler</span><span class="p">),</span><span class="w"> </span><span class="n">sample_point</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">perlin_worley</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fbm</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="w">            </span><span class="n">vec3</span><span class="w"> </span><span class="n">worleys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fbm</span><span class="p">.</span><span class="n">yzw</span><span class="p">;</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">worly_fbm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worleys</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.625</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">worleys</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.125</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">worleys</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">cloud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remap</span><span class="p">(</span><span class="n">perlin_worley</span><span class="p">,</span><span class="w"> </span><span class="n">worly_fbm</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>
<span class="w">            </span><span class="n">cloud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remap</span><span class="p">(</span><span class="n">cloud</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">coverage</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// 魔法函数，用于简化计算光衰</span>
<span class="w">            </span><span class="n">T</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">cloud</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">step</span><span class="p">);</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">radiance</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cloud</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>完整工程请参考<code class="docutils literal notranslate"><span class="pre">Turbo</span></code>的<code class="docutils literal notranslate"><span class="pre">RayMarchingPerlinWorleyNoise</span></code>示例</p>
</section>
</section>
</section>
</section>
<section id="id26">
<h2>3 光照<a class="headerlink" href="#id26" title="此标题的永久链接">#</a></h2>
<p><em>注：该章节主要来源于<a class="reference download internal" download="" href="../_downloads/2297190ab023a1b516144a9c371f0d18/volumePaper.pdf"><span class="xref download myst">Production Volume Rendering SIGGRAPH 2017 Course</span></a></em></p>
<section id="id27">
<h3>3.1 介绍<a class="headerlink" href="#id27" title="此标题的永久链接">#</a></h3>
<p>上一次<code class="docutils literal notranslate"><span class="pre">SIGGRAPH</span></code>体渲染<code class="docutils literal notranslate"><span class="pre">production</span> <span class="pre">volume</span> <span class="pre">rendering</span></code>课程在2011年举办，之后的一年（Wrenninge 2012）与该课程同名的书籍出版，总结并详细说明了体渲染相关知识。就在轻描淡写间，该领域飞速发展：仅仅六年时间，整个领域发生了翻天覆地的变化，之前提出的技术和方法几乎被完全取代。多亏了技术的进步和设备计算性能的提升，光线追踪取代了扫描线算法作为影视领域的佼佼者。之前曾作为光追的简化版的光线步进，现在在其上运用追踪算法已经稀疏平常，在使用体积缓存和运动模糊技术来预计算光照和多通道技术已成为历史。随之而来的出现了一系列巧妙的符合物理特性的光线传输模型，并达成了一系列的“圣杯”式的技术突破：适用于区域光、多级散射和精确的运动模糊等等效果在短短五年的时间里就应用在无误差的体积渲染中。</p>
<p>对于体渲染研究任然散发着它独有的挑战性，这往往会让光追开发者和研究者望而生畏（怎儿一个“坑”字了得~），体渲染比任何一个几何体渲染都要复杂昂贵。然而使用混合多种方法来解决此难题并不是非常直观，而使用相对较快方法（追踪之类的）虽然无偏、低开销但是方差较大。较慢的方式也许会有偏或是需要一些高开销的步骤，但是有低方差甚至结果无噪音的优良特性。对于追踪进入场景的一束光线，事实上没有最好的方法解决该问题，与此同时对于大量数据描述巨大的体积体意味着传统的运动模糊并不能适用，而且场景的规模和复杂程度千差万别：比如一个复杂的爆炸运算也许会伴随着一个简单的大气计算，而这对于渲染器来如何更有效率的渲染尤为重要。</p>
<p>该课程将会接着上一次课程结尾处开始讲起，不仅解释最近的基础理论，而且会展示实现细节。本文作者有两款商业产品经验（<code class="docutils literal notranslate"><span class="pre">RenderMan</span></code>和<code class="docutils literal notranslate"><span class="pre">Arnold</span></code>）和一个先进的专用渲染器（<code class="docutils literal notranslate"><span class="pre">Hyperion</span></code>），本次将会讲解其中的很多细节。本课程将基于光线追踪进行体渲染讲解，包括所有在未来的电影工作中需要的方方面面，体渲染的基本理论也会进行讲解，将会带领大家理解不同条件下的体渲染，总结优点和缺点为将来的合理使用做储备。有关最近发展的运动模糊，缩减方差，追踪和解决场景复杂度也会进行讲解。</p>
<section id="id28">
<h4>3.1.1 符号对照表<a class="headerlink" href="#id28" title="此标题的永久链接">#</a></h4>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>符号</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(x\)</span></p></td>
<td><p>位置</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(t\)</span></p></td>
<td><p>射线前进距离</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(w\)</span></p></td>
<td><p>射线方向</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(x_t\)</span></p></td>
<td><p>射线方向上某一位置： <span class="math notranslate nohighlight">\(x_t=x+tw\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\sigma_a(x)\)</span></p></td>
<td><p>吸收系数（<code class="docutils literal notranslate"><span class="pre">Absorption</span> <span class="pre">coefficient</span></code>）</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\sigma_s(x)\)</span></p></td>
<td><p>散射系数 (<code class="docutils literal notranslate"><span class="pre">Scattering</span> <span class="pre">coefficient</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\sigma_t(x)\)</span></p></td>
<td><p>消亡系数 (<code class="docutils literal notranslate"><span class="pre">Extinction</span> <span class="pre">coefficient</span></code>，有时也叫消光系数) <span class="math notranslate nohighlight">\(=\sigma_a(x)+\sigma_s(x)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\alpha(x)\)</span></p></td>
<td><p>单散射反照率（<code class="docutils literal notranslate"><span class="pre">Single</span> <span class="pre">scattering</span> <span class="pre">albedo</span></code>） <span class="math notranslate nohighlight">\(=\sigma_s(x)/\sigma_t(x)\)</span> <em>注：在2016年的<code class="docutils literal notranslate"><span class="pre">Physically</span> <span class="pre">Based</span> <span class="pre">Sky,</span> <span class="pre">Atmosphere</span> <span class="pre">and</span> <span class="pre">Cloud</span> <span class="pre">Rendering</span> <span class="pre">in</span> <span class="pre">Frostbite</span></code>的文章中第<code class="docutils literal notranslate"><span class="pre">2.2</span> <span class="pre">Albedo</span></code>中描述为  <span class="math notranslate nohighlight">\(\rho\)</span></em></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(f_p(x,w,w')\)</span></p></td>
<td><p>相函数（<code class="docutils literal notranslate"><span class="pre">Phase</span> <span class="pre">function</span></code>）</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(d\)</span></p></td>
<td><p>体积积分中的射线长度或域： <span class="math notranslate nohighlight">\(0 &lt; t &lt; d\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\xi,\zeta\)</span></p></td>
<td><p>随机数</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(L(x,w)\)</span></p></td>
<td><p>沿 <span class="math notranslate nohighlight">\(w\)</span> 方向在 <span class="math notranslate nohighlight">\(x\)</span> 位置处的辐射亮度（<code class="docutils literal notranslate"><span class="pre">Radiance</span></code>）<em>注：在2016年的<code class="docutils literal notranslate"><span class="pre">Physically</span> <span class="pre">Based</span> <span class="pre">Sky,</span> <span class="pre">Atmosphere</span> <span class="pre">and</span> <span class="pre">Cloud</span> <span class="pre">Rendering</span> <span class="pre">in</span> <span class="pre">Frostbite</span></code>的文章中作者称 <span class="math notranslate nohighlight">\(L(x,w)\)</span> 为光亮度（<code class="docutils literal notranslate"><span class="pre">luminance</span></code>），此处有冲突。辐射亮度（以瓦特作为研究单元）和光亮度（以流明作为研究单元）是两个不同的物理量</em></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(L_d(x_d,w)\)</span></p></td>
<td><p>入射边界的辐射亮度</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(L_e(x,w)\)</span></p></td>
<td><p>发射的辐射亮度</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(L_s(x,w)\)</span></p></td>
<td><p>沿 <span class="math notranslate nohighlight">\(w\)</span> 方向在 <span class="math notranslate nohighlight">\(x\)</span> 位置处的外散射辐射亮度</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="id29">
<h3>3.2 体渲染理论<a class="headerlink" href="#id29" title="此标题的永久链接">#</a></h3>
<section id="id30">
<h4>3.2.1 体积特性<a class="headerlink" href="#id30" title="此标题的永久链接">#</a></h4>
<p>场景中的“体”以常规思维来说，是一群粒子的集合，比如从原子到分子再到任意大小粒子，再到星系之间辐射亮度传输。由于粒子的平均密度相对较低，而这和粒子与粒子之间的平均距离相比，粒子的大小就显得微不足道了。这是能够进行独立统计的先决条件。这通常发生在任何气态介质中，但这并不适用于像沙子和雪这样的致密粒状介质，这种情况下将会打破之前的先决条件。</p>
<p>如果有光子穿过体积体，将会于体积体中的粒子进行碰撞最终照亮该体积体。这些穿过体积体进行碰撞的光子将会为辐射亮度做出贡献。由于不可能去描述体积体中的每一个粒子，所以使用一种碰撞概率场来描述体积体，这表现为粒子碰撞都是随机的。</p>
<p>光子在体积体中发生碰撞的可能性使用系数 <span class="math notranslate nohighlight">\(\sigma(x)\)</span> 进行描述，表示在体积体中穿过每单位距离下的碰撞概率密度。碰撞系数的物理单位与长度成反比（这句话不知道是不是这个意思，原文： <code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">physical</span> <span class="pre">unit</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">collision</span> <span class="pre">coefficient</span> <span class="pre">is</span> <span class="pre">inverse</span> <span class="pre">length</span></code>）。另一种方式是使用平均自由程（<code class="docutils literal notranslate"><span class="pre">mean</span> <span class="pre">free</span> <span class="pre">path</span></code>，<em>百度百科：在一定的条件下，一个气体分子在连续两次碰撞之间可能通过的各段自由程的平均值，微粒的平均自由程是指微粒与其他微粒碰撞所通过的平均距离。用符号 <span class="math notranslate nohighlight">\(\lambda\)</span> 表示，单位为米</em>）来评估该系数，用于表示两次碰撞之间的平均距离。通常我们认为该系数是一个与位置有关的函数并随着光谱做适当变化。</p>
<p>体积体的特性是通过吸收系数，散射系数，相函数和自发光共同决定的：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">吸收</span></code><br />
通过 <span class="math notranslate nohighlight">\(\sigma_a(x)\)</span> 系数进行表达，用于描述当光子与体积体在我们感兴趣的区域时消失，进而被吸收的碰撞。从物理的角度来说，当发生碰撞时，光子的能量被转化成粒子的内部能量，比如使粒子在分子层面发生位移，震动或者是转化成了更常见的热能。</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">散射</span></code><br />
通过相函数可以用于定义一个散射碰撞 <span class="math notranslate nohighlight">\(\sigma_s(x)\)</span> 散射出去光子的不同方向，光子在发生散射时其携带的辐射亮度不会发生变化，只有自发光和吸收会改变辐射亮度</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">相函数</span></code><br />
相函数 <span class="math notranslate nohighlight">\(f_p(x,w,w')\)</span> 用于描述散射的角度分布并且通常作为与 <span class="math notranslate nohighlight">\(\theta\)</span> 有关的一元函数，其中 <span class="math notranslate nohighlight">\(\theta\)</span> 夹在 <span class="math notranslate nohighlight">\(w\)</span> 与 <span class="math notranslate nohighlight">\(w'\)</span> 之间的。并且需要在球面上进行归一化：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\int_{S^2}f_p(x,w,w')d\theta=1\tag{1}\]</div>
</div>
<p>如果不满足归一化，则会导致散射碰撞的辐射亮度浮动导致不正确。相函数有一个重要特性，与<code class="docutils literal notranslate"><span class="pre">BSDF</span></code>（双向散射分布函数<code class="docutils literal notranslate"><span class="pre">Bidirectional</span> <span class="pre">scattering</span> <span class="pre">distribution</span> <span class="pre">function</span></code>）类似，具有相互性（可逆性）。我们需要在不改变相函数值的情况下能够相互转化方向。在表面渲染中相函数与<code class="docutils literal notranslate"><span class="pre">BSDF</span></code>功能一样，并且能够像3.3.6章节那样作为<code class="docutils literal notranslate"><span class="pre">BSDF</span></code>的一种抽象来使用。对于入射光如果在任意方向上发生的散射概率是等可能的（均匀散射），则称该体积体为各向同性（<code class="docutils literal notranslate"><span class="pre">isotropic</span></code>，观察角度在变而观察到的结果不变），对应得相函数为：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f_p(x,\theta)=\frac{1}{4\pi}\tag{2}\]</div>
</div>
<p>对于各向异性（<code class="docutils literal notranslate"><span class="pre">Anisotropic</span></code>，观察角度在变而观察到的结果也在变化）的体积体可以使用米氏方案（<code class="docutils literal notranslate"><span class="pre">Mie</span> <span class="pre">solution</span></code>）到麦克斯韦方程组（<code class="docutils literal notranslate"><span class="pre">Maxwell’s</span> <span class="pre">equations</span></code>）来得到更精确的结果（米氏散射<code class="docutils literal notranslate"><span class="pre">Mie</span> <span class="pre">scattering</span></code>，相函数的一种），或者使用瑞利散射（<code class="docutils literal notranslate"><span class="pre">Rayleigh</span></code>，米氏散射的近似）来等到近似解。由于米氏散射计算非常复杂，在真正生产中，我们往往更多使用亨尼-格林斯坦相函数（<code class="docutils literal notranslate"><span class="pre">Henyey-Greenstein</span> <span class="pre">phase</span> <span class="pre">function</span></code>，1941年由亨尼和格林斯坦提出）：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f_p(x,\theta)=\frac{1}{4\pi}\frac{1-g^2}{({1+g^2-2gcos\theta})^{\frac{3}{2}}}\tag{3}\]</div>
</div>
<p>其中 <span class="math notranslate nohighlight">\(-1 &lt; g &lt; 1\)</span> ，参数 <span class="math notranslate nohighlight">\(g\)</span> 可以认为是散射方向的平均余弦，并且用于控制该相函数的对称性，当 <span class="math notranslate nohighlight">\(g&lt;0\)</span> 时为向后散射，当   <span class="math notranslate nohighlight">\(g=0\)</span> 时为各向同性散射，当 <span class="math notranslate nohighlight">\(g&gt;0\)</span> 时为向前散射。多个系数与该相函数进行组合可以得到复杂相函数的近似解。该相函数还有可以轻松且完美的进行重要性采样的特点</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">自发光</span></code>
以体积的方式在体积体中发射辐射，如果不这样的话，得到的结果将更像是一个光源发出光后的结果。发射出来的辐射亮度使用 <span class="math notranslate nohighlight">\(L_e(x,w)\)</span> 进行表达，其发射出来的辐射与非体积光源一样会被吸收和散射。如果一个体积体不进行自发光，<span class="math notranslate nohighlight">\(L_e(x,w)\)</span> 简单赋成 <span class="math notranslate nohighlight">\(0\)</span> 即可，在真实世界中，体积体并不能直接向外自发光，并且 <span class="math notranslate nohighlight">\(L_e(x,w)\)</span> 在任意 <span class="math notranslate nohighlight">\(w\)</span> 方向上都是一样的（各向同性）</p>
</div></blockquote>
<section id="extinction-single-scattering-albedo">
<h5>3.2.1.1 参数化消亡（<code class="docutils literal notranslate"><span class="pre">Extinction</span></code>）和单散射反照率（<code class="docutils literal notranslate"><span class="pre">Single</span> <span class="pre">Scattering</span> <span class="pre">Albedo</span></code>）<a class="headerlink" href="#extinction-single-scattering-albedo" title="此标题的永久链接">#</a></h5>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">消亡</span></code><br />
在很多情况下，我们期望吸收系数和散射系数进行不同的参数化。我们可以定义消亡系数为吸收系数与散射系数的和： <span class="math notranslate nohighlight">\(\sigma_t=\sigma_a+\sigma_s\)</span> （有时也被叫做衰减系数（<code class="docutils literal notranslate"><span class="pre">attenuation</span> <span class="pre">coefficient</span></code>），通常可以用密度来代替）。消亡系数定义了由于吸收和散射导致的辐射净损失。换句话说，消亡碰撞是即发生吸收也发生散射的碰撞，并且我们需要确保散射出去的辐射与<code class="docutils literal notranslate"><span class="pre">单散射反照率</span></code>在光照积分公式中正确调制。</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">单散射反照率</span></code><br />
单散射反照率对应公式为:<br />
$<span class="math notranslate nohighlight">\(\alpha=\frac{\sigma_s}{\sigma_t}\)</span><span class="math notranslate nohighlight">\(
其是在消亡系数的基础上更进一步描述体积体的特性， \)</span>\alpha<span class="math notranslate nohighlight">\( 与表面反照率（常见叫漫反射）相似，两者都是评估反射总量，用于确认散射的辐射量。当 \)</span>\alpha=0<span class="math notranslate nohighlight">\( 时表示所有的辐射都被吸收了（像烧煤的黑烟），当 \)</span>\alpha=1$ 时表示没有辐射被吸收，这样就能得到一个无损散射（比如天空中的云彩）</p>
<p>实际上当通过体素或者程序性函数来控制消亡时，使用一个不变的反照率常量就已经可以得到不错的消亡和单散射参数化，并得到不错的体积体结果。这些参数可以在任何计算或存储中进行改变。</p>
</div></blockquote>
</section>
</section>
<section id="id31">
<h4>3.2.2 体积中的光线传输<a class="headerlink" href="#id31" title="此标题的永久链接">#</a></h4>
<section id="radiative-transfer-equation">
<h5>3.2.2.1 辐射传输方程（<code class="docutils literal notranslate"><span class="pre">Radiative</span> <span class="pre">Transfer</span> <span class="pre">Equation</span></code>）<a class="headerlink" href="#radiative-transfer-equation" title="此标题的永久链接">#</a></h5>
<p>辐射传输方程用于定义辐射在体积中的分布，或者简称<code class="docutils literal notranslate"><span class="pre">RTE</span></code>。用于描述包括任何几何边缘和光源在体积中沿着 <span class="math notranslate nohighlight">\(w\)</span> 方向，位于 <span class="math notranslate nohighlight">\(x\)</span> 点位置处的均衡辐射场（<code class="docutils literal notranslate"><span class="pre">equilibrium</span> <span class="pre">radiance</span> <span class="pre">field</span></code>） <span class="math notranslate nohighlight">\(L(x,w)\)</span></p>
<p>接下来，我们根据该<code class="docutils literal notranslate"><span class="pre">RTE</span></code>方程的组成结构进行讲解，最终构成整个方程：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">吸收</span></code></p>
<div align=center><img src="../_static/absorption.png" width=40%></div>
<p>对于一条经典辐射束 <span class="math notranslate nohighlight">\(L(x,w)\)</span> ，在 <span class="math notranslate nohighlight">\(x\)</span> 位置处沿着 <span class="math notranslate nohighlight">\(w\)</span> 方向前进，在 <span class="math notranslate nohighlight">\(w\)</span> 方向的导数（方向导数，表达式为：<span class="math notranslate nohighlight">\(w\cdot\nabla\)</span> ，其中 <span class="math notranslate nohighlight">\(\nabla\)</span> 为梯度，<span class="math notranslate nohighlight">\(\cdot\)</span> 为向量点乘 ）与该点处的辐射强度成比例，这个比例系数就是之前介绍的吸收系数 <span class="math notranslate nohighlight">\(\sigma_a\)</span> ：
$<span class="math notranslate nohighlight">\((w\cdot\nabla)L=-\sigma_a(x)L(x,w)\tag{4}\)</span>$
如上就是三维朗伯-比尔定律微分公式，用于描述由于吸收而减少的辐射亮度</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">外散射</span></code>（<code class="docutils literal notranslate"><span class="pre">Out-Scattering</span></code>）</p>
<div align=center><img src="../_static/out_scattering.png" width=40%></div>
<p>对于一条经典辐射束 <span class="math notranslate nohighlight">\(L(x,w)\)</span> ，也会由于外散射，将原本在 <span class="math notranslate nohighlight">\(w\)</span> 方向的辐射向外散射到其他方向，导致辐射亮度的减少。外散射不会将整个辐射亮度都损失掉，只会在原先的 <span class="math notranslate nohighlight">\(w\)</span> 方向上损失，损失的辐射会分布到其他方向或位置上，与吸收一样，外散射损失的辐射也与辐射亮度 <span class="math notranslate nohighlight">\(L(x,w)\)</span> 成比例，也就是对应的散射系数 <span class="math notranslate nohighlight">\(\sigma_s(x)\)</span> ：
$<span class="math notranslate nohighlight">\((w\cdot\nabla)L(x,w)=-\sigma_s(x)L(x,w)\tag{5}\)</span>$</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">自发光</span></code></p>
<div align=center><img src="../_static/emission.png" width=40%></div>
<p>自发光是一个相对独立的部分， <span class="math notranslate nohighlight">\(L_e(x,w)\)</span> 用于定义额外增加到 <span class="math notranslate nohighlight">\(L(x,w)\)</span> 上的辐射亮度</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[(w\cdot\nabla)L=-\sigma_a(x)L_e(x,w)\tag{6}\]</div>
</div>
<p>请注意像<code class="docutils literal notranslate"><span class="pre">PBRT</span></code>（<code class="docutils literal notranslate"><span class="pre">Physically</span> <span class="pre">Based</span> <span class="pre">Rendering:</span> <span class="pre">From</span> <span class="pre">Theory</span> <span class="pre">to</span> <span class="pre">Implementation</span></code>）之类的很多文章对于自发光的处理有些许不同，这些文章中的自发光并没有使用到吸收系数 <span class="math notranslate nohighlight">\(\sigma_a(x)\)</span> ，为了传输方程的统一性和正确性，我们需要在自发光 <span class="math notranslate nohighlight">\(L_e(x,w)\)</span> 设置该吸收系数，这对接下来的推导很重要。</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">内散射</span></code>（<code class="docutils literal notranslate"><span class="pre">In-Scattering</span></code>）</p>
<div align=center><img src="../_static/in_scattering.png" width=40%></div>
<p>内散射是由于点 <span class="math notranslate nohighlight">\(x\)</span> 位置处所有其他方向出去的 <span class="math notranslate nohighlight">\(w'\)</span> 的外散射又回到了该点，导致原本的辐射束上的辐射亮度得到增加。
$<span class="math notranslate nohighlight">\((w\cdot\nabla)L(x,w)=\sigma_s(x)\int_{S^2}f_p(x,w,w')L(x,w')dw'\tag{7}\)</span><span class="math notranslate nohighlight">\(
其中 \)</span>S^2<span class="math notranslate nohighlight">\( 代表 \)</span>x<span class="math notranslate nohighlight">\( 点四周的一个球邻域，其中 \)</span>\sigma_s(x)<span class="math notranslate nohighlight">\( 用于评估四周所有方向进入的辐射散射，这与 \)</span>5<span class="math notranslate nohighlight">\( 式中的 \)</span>\sigma_s(x)$ 相似。辐射束基本上会吸收从所有其他方向散射到其自身原本方向上的所有辐射。</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">整合辐射传输方程</span></code><br />
我们将每个部分进行啊相加，就得到了最终的辐射传输方程，由于吸收和外散射有一部分可以合并成消亡系数 <span class="math notranslate nohighlight">\(\sigma_t(x)\)</span> ，所以最终的辐射传输方程如下:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[辐射亮度=吸收+外散射+自发光+内散射\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[(w\cdot\nabla)L(x,w)=\frac{-\sigma_a(x)L(x,w)}{吸收}\frac{-\sigma_s(x)L(x,w)}{外散射}\frac{+\sigma_a(x)L_e(x,w)}{自发光}\frac{+\sigma_s(x)\int_{S^2}f_p(x,w,w')L(x,w')dw'}{内散射}\]</div>
</div>
<p>其中，吸收和外散射可以合并成 <span class="math notranslate nohighlight">\(\sigma_t(x)\)</span>， <span class="math notranslate nohighlight">\(\sigma_t(x) = \sigma_a(x)+\sigma_s(x)\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{-\sigma_a(x)L(x,w)}{吸收}\frac{-\sigma_s(x)L(x,w)}{外散射}=\frac{-[\sigma_a(x)+\sigma_s(x)]L(x,w)}{吸收与外散射合并}=\frac{-\sigma_t(x)L(x,w)}{消亡}\]</div>
</div>
<p>得出最终的辐射传输方程：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[(w\cdot\nabla)L(x,w)=-\sigma_t(x)L(x,w)+\sigma_a(x)L_e(x,w)+\sigma_s(x)\int_{S^2}f_p(x,w,w')L(x,w')dw'\tag{8}\]</div>
</div>
</div></blockquote>
</section>
<section id="volume-rendering-equation">
<h5>3.2.2.2 体渲染方程（<code class="docutils literal notranslate"><span class="pre">Volume</span> <span class="pre">Rendering</span> <span class="pre">Equation</span></code>）<a class="headerlink" href="#volume-rendering-equation" title="此标题的永久链接">#</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">RTE</span></code>方程使用梯度 <span class="math notranslate nohighlight">\((w\cdot\nabla)\)</span> 来表述向前传输的辐射亮度分布，换句话说就是用于描述辐射束向前传播时发生了什么。<code class="docutils literal notranslate"><span class="pre">RTE</span></code>可以直接使用有限元的方式比如辐射度方法，更多见于有限元方法，而不是光追中的设置，体渲染方程可以描述这种现象（这句话不知道说的啥意思，原文<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">RTE</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">directly</span> <span class="pre">used</span> <span class="pre">in</span> <span class="pre">finite</span> <span class="pre">element</span> <span class="pre">methods</span> <span class="pre">such</span> <span class="pre">as</span> <span class="pre">radiosity</span> <span class="pre">(Cohen</span> <span class="pre">et</span> <span class="pre">al.</span> <span class="pre">1993)</span> <span class="pre">and</span> <span class="pre">more</span> <span class="pre">generally</span> <span class="pre">in</span> <span class="pre">finite</span> <span class="pre">element</span> <span class="pre">methods,</span> <span class="pre">but</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">a</span> <span class="pre">path</span> <span class="pre">tracing</span> <span class="pre">setting,</span> <span class="pre">The</span> <span class="pre">volume</span> <span class="pre">rendering</span> <span class="pre">equation</span> <span class="pre">can</span> <span class="pre">provide</span> <span class="pre">this</span> <span class="pre">formulation</span></code>），为了简化符号，将内散射简写成：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[L_s(x,w)=\int_{S^2}f_p(x,w,w')L(x,w')dw'\tag{9}\]</div>
</div>
<p>我们在<code class="docutils literal notranslate"><span class="pre">RTE</span></code>两边进行积分，将式<code class="docutils literal notranslate"><span class="pre">8</span></code>左侧的梯度 <span class="math notranslate nohighlight">\((w\cdot\nabla)\)</span> 以积分的形式挪到右侧，这样就得到了 <span class="math notranslate nohighlight">\(L(x,w)\)</span> 的显式方程，该方程就是体渲染方程，简称<code class="docutils literal notranslate"><span class="pre">VRE</span></code></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[L(x,w)=\int_{t=0}^{d}e^{-\int_{s=0}^{t}\sigma_t(x_s)ds}[\sigma_a(x_t)L_e(x_t,w)+\sigma_s(x_t)L_s(x_t,w)+L_d(x_d,w)]dt\tag{10}\]</div>
</div>
<p>为了表述该式，我们沿着辐射束的反方向进行积分参数化，向前的射线使用参数 <span class="math notranslate nohighlight">\(t\)</span> 和参数 <span class="math notranslate nohighlight">\(s\)</span> 来描述，使用参数 <span class="math notranslate nohighlight">\(d\)</span> 来表示射线走到了边缘尽头（可能是一个表面或是一个潜在的其他体积体），式<code class="docutils literal notranslate"><span class="pre">10</span></code>中沿着 <span class="math notranslate nohighlight">\(ds\)</span> 和 <span class="math notranslate nohighlight">\(dt\)</span> 的位置为 <span class="math notranslate nohighlight">\(x_t=x-tw\)</span> 和 <span class="math notranslate nohighlight">\(x_s=x-sw\)</span> ，在射线结尾处的入射辐射亮度使用 <span class="math notranslate nohighlight">\(L_d(x_d,w)\)</span> 来描述。选择使用沿着辐射束的反方向进行参数化也是符合积分形式的。相较于<code class="docutils literal notranslate"><span class="pre">RTE</span></code>使用梯度来描述辐射的向前传输，而<code class="docutils literal notranslate"><span class="pre">VRE</span></code>用于描述辐射是从哪里来的，逆着来，并且根据积分来积累所有的相关分布值，同时也确保了 <span class="math notranslate nohighlight">\(w\)</span> 方向总是指向辐射流的方向。在很多文章描述中，比如<code class="docutils literal notranslate"><span class="pre">PBRT</span></code>(<code class="docutils literal notranslate"><span class="pre">Physically</span> <span class="pre">Based</span> <span class="pre">Rendering:</span> <span class="pre">From</span> <span class="pre">Theory</span> <span class="pre">to</span> <span class="pre">Implementation</span></code>)需要明确指出方向性，并且需要关注与方向有关的符号描述，这在数学表达式上多少增加了复杂性。</p>
<p>为了更好的结构，我们将指数积分使用 <span class="math notranslate nohighlight">\(T(x)\)</span> 来表示：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[T(x)=e^{-\int_{s=0}^{t}\sigma_t(x_s)ds}\tag{11}\]</div>
</div>
<p>该式<code class="docutils literal notranslate"><span class="pre">11</span></code>表示，从起点 <span class="math notranslate nohighlight">\(x\)</span> 到使用射线参数化 <span class="math notranslate nohighlight">\(t\)</span> (目前来看 <span class="math notranslate nohighlight">\(t\)</span> 应该表示长度 )所描述的射线位置 <span class="math notranslate nohighlight">\(x_t=x-tw\)</span> 之间的透射率（<code class="docutils literal notranslate"><span class="pre">transmittance</span></code>），透射率 <span class="math notranslate nohighlight">\(T(x)\)</span> 用于描述点 <span class="math notranslate nohighlight">\(x\)</span> 和 <span class="math notranslate nohighlight">\(x_t\)</span> 之间由于吸收和外散射所导致的净损失因子。此外，式<code class="docutils literal notranslate"><span class="pre">10</span></code>最右侧的 <span class="math notranslate nohighlight">\(L_d(x_d,w)\)</span> 与 <span class="math notranslate nohighlight">\(t\)</span> 没有关系。为了式子紧凑，更好的适配路径追踪的需求，将其积分后提出来：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[L(x,w)=\int_{t=0}^{d}T(x)\big[\sigma_a(x_t)L_e(x_t,w)+\sigma_s(x_t)L_s(x_t,w)\big]dt+T_d(x)L_d(x_d,w)\tag{12}\]</div>
</div>
<p>辐射束射线上任何一个点经由透射率的吸收后都会损失一部分并最终反映到 <span class="math notranslate nohighlight">\(L(x,w)\)</span> 中，下图就是展示<code class="docutils literal notranslate"><span class="pre">VRE</span></code>通过式<code class="docutils literal notranslate"><span class="pre">12</span></code>进行表述的示意图，<code class="docutils literal notranslate"><span class="pre">VRE</span></code>可以认为是渲染方程的推广，将其推广成一种体积结构，使用近乎是无穷密度的表面和复杂的相函数进行描述。</p>
<div align=center><img src="../_static/vre.png"></div>
<p>在蒙特卡洛（<code class="docutils literal notranslate"><span class="pre">Monte</span> <span class="pre">Carlo</span></code>）中主要有两种随机方法用于求解<code class="docutils literal notranslate"><span class="pre">RTE</span></code>，在接下来的章节中，我们使用每种方法专用的<code class="docutils literal notranslate"><span class="pre">VRE</span></code>进行讲解。</p>
</section>
</section>
<section id="id32">
<h4>3.2.3 追踪方式<a class="headerlink" href="#id32" title="此标题的永久链接">#</a></h4>
<p>当追踪的采样点处发生辐射碰撞后，使用俄罗斯轮盘赌法（<code class="docutils literal notranslate"><span class="pre">Russian</span> <span class="pre">roulette</span></code>）和拒绝采样法（<code class="docutils literal notranslate"><span class="pre">rejection</span> <span class="pre">sampling</span></code>）来评估，而不是同时遍历计算所有的碰撞。去追踪模拟光子（在计算机图形学领域中）是如何在体积体中碰撞反弹的，特别是模拟吸收和散射碰撞。将其数字化计算，我们不允许辐射束分散自身，我们只选择那些我们需要的碰撞类型进行建模。</p>
<p>在这些假设前提下，对应的问题也就变成了：采样光子在不同碰撞类型之间的自由路径的距离，用于模拟这之间的物理过程。</p>
<section id="closed-form-tracking">
<h5>3.2.3.1 最近式追踪（<code class="docutils literal notranslate"><span class="pre">Closed-form</span> <span class="pre">Tracking</span></code>）<a class="headerlink" href="#closed-form-tracking" title="此标题的永久链接">#</a></h5>
<p>在较简单的体积体中，例如按照常数，多项式或者是指数变化的消亡，对于自由路径，可以使用你变换采样法（<code class="docutils literal notranslate"><span class="pre">inverse</span> <span class="pre">transform</span> <span class="pre">sampling</span></code>）进行采样，乌拉姆（<code class="docutils literal notranslate"><span class="pre">Ulam</span></code>）是第一个将其应用在蒙特卡洛积分上的。在渲染中，对于均质（<code class="docutils literal notranslate"><span class="pre">homogeneous</span></code>）的体积体非常重要，我们之后将会对其进行讨论。</p>
<p>为了简化的目的，我们可以通过单位化透射率方程<code class="docutils literal notranslate"><span class="pre">11</span></code>式得到一个概率密度函数。如果相对应的分布函数（<code class="docutils literal notranslate"><span class="pre">cumulative</span> <span class="pre">distribution</span> <span class="pre">function</span></code>，也叫累积分布函数）是可逆（<code class="docutils literal notranslate"><span class="pre">analytically</span> <span class="pre">invertible</span></code>）的，则自由路径 <span class="math notranslate nohighlight">\(t'\)</span> 可以使用一个随机数 <span class="math notranslate nohighlight">\(\xi\)</span> 进行分析采样，对于一个同质的体积体其对应的 <span class="math notranslate nohighlight">\(\sigma_t\)</span> 在空间上是不会变化的，随之透射率为：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[T(t)=e^{-\sigma_t t}\tag{13}\]</div>
</div>
<p>这就是朗伯-比尔定律（也叫比尔定律）：辐射消亡成指数变化。对于追踪，我们关注于创建一个可以为自由搏击估计器（<code class="docutils literal notranslate"><span class="pre">free-fight</span> <span class="pre">estimator</span></code>）两倍的透射率估计（<code class="docutils literal notranslate"><span class="pre">这句话不知所云啊</span></code>）。我们想要去采样并生成由一个光子通过由固定透射率定义的体积体所走过的距离。问题被分解为通过对指数函数的重要性采样，进而产生自由路径距离 <span class="math notranslate nohighlight">\(t'\)</span> 。概率密度函数是通过归一化透射率积分函数得到的：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[p(t)=\sigma_t e^{-\sigma_t t}\tag{14}\]</div>
</div>
<p>我们可以进行完美的重要性采样通过使用：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[t'= \frac{-ln(1-\xi)}{\sigma_t}\tag{15}\]</div>
</div>
<p>由于是使用的基本指数概率密度函数进行的完美采样所以不会有显示蒙特卡洛权重影响（产生的权重为1），并且我们将 <span class="math notranslate nohighlight">\(t'\)</span> 解释为光子前进的距离。通过式<code class="docutils literal notranslate"><span class="pre">14</span></code>的概率密度函数，对于式<code class="docutils literal notranslate"><span class="pre">11</span></code>的透射率函数有一个随机形式的代替式，并最终与式<code class="docutils literal notranslate"><span class="pre">10</span></code>的体渲染方程相结合：直接将体渲染方程使用式<code class="docutils literal notranslate"><span class="pre">14</span></code>进行相应的替换就得到了同质体积体的体渲染方程（比如具有一些不变的系数等）：</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[L(x,w)=\int_{t=0}^{d}p(t)\big[\frac{\sigma_a}{\sigma_t}L_e(x_t,w)+\frac{\sigma_s}{\sigma_t}L_s(x_t,w)\big]dt\]</div>
</div>
</section>
</section>
</section>
</section>
<section id="id33">
<h2>4 问题<a class="headerlink" href="#id33" title="此标题的永久链接">#</a></h2>
<p>人非生而知之者，孰能无惑 •ᴗ•</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sigma_t(x)\)</span> 消亡系数为 <span class="math notranslate nohighlight">\(\sigma_a+\sigma_s\)</span>，其中的 <span class="math notranslate nohighlight">\(\sigma_s\)</span> 是一般散射的散射还是外散射的意思？消亡意味着能量的减少，在自发光，外散射，内散射，吸收四种情况中只有吸收和外散射会导致出射的能量减少，自发光和内散射都会导致出射的能量增加。（相关问题<code class="docutils literal notranslate"><span class="pre">Physically</span> <span class="pre">Based</span> <span class="pre">Sky,</span> <span class="pre">Atmosphere</span> <span class="pre">and</span> <span class="pre">Cloud</span> <span class="pre">Rendering</span> <span class="pre">in</span> <span class="pre">Frostbite</span></code>等文章中有相关提及，但都不明确）</p></li>
<li><p><span class="math notranslate nohighlight">\(\sigma_{a/s/t}(x)\)</span> 吸收，散射，消亡系数为与 <span class="math notranslate nohighlight">\(x\)</span> 有关的函数，但很多时候都直接使用密度，一个常数，是为了简化计算吗？不简化的话函数应该是什么样的？</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="id34">
<h2>未完待续<a class="headerlink" href="#id34" title="此标题的永久链接">#</a></h2>
</section>
</section>

        </article>
      </div>
      <footer>
        
<div class="related-pages">
    <a class="next-page" href="../Changelog.html">
        <div class="page-info">
            <div class="context">
                <span>Next</span>
            </div>
            <div class="title">更新日志</div>
        </div>
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
    </a>
    <a class="prev-page" href="index.html">
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
        <div class="page-info">
            <div class="context">
                <span>Previous</span>
            </div>
            
            <div class="title">应用</div>
            
        </div>
    </a>
</div>
<div class="bottom-of-page">
    <div class="left-details">
        <div class="copyright">
            Copyright &#169; 2023, FuXii
        </div>
        Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
        
        <a href="https://github.com/pradyunsg/furo">Furo</a>
        
        <div>
             <span id="busuanzi_container_site_uv" style='display:none'>site view <span id="busuanzi_value_site_uv"></span></span> 
        </div>
    </div>
    <div class="right-details">
        <div class="icons">
            <a class="muted-link " href="https://github.com/FuXiii/Essentials.of.Vulkan" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
            
        </div>
        <div class="left-details">
             <span id="busuanzi_container_page_pv" style='display:none'>page view <span id="busuanzi_value_page_pv"></span></span> 
        </div>
    </div>
</div>

      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">体积云</a><ul>
<li><a class="reference internal" href="#id2">概述</a></li>
<li><a class="reference internal" href="#id3">0 背景</a><ul>
<li><a class="reference internal" href="#id4">0.1 噪音</a><ul>
<li><a class="reference internal" href="#perlin-noise">0.1.1 柏林噪音（Perlin Noise）</a></li>
<li><a class="reference internal" href="#worley-noise">0.1.2 沃利噪音 （Worley Noise）</a></li>
<li><a class="reference internal" href="#id5">0.1.3 三维噪音纹理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fractal">0.2 分形（fractal）</a><ul>
<li><a class="reference internal" href="#fractal-brownian-motion-fbm">0.2.1 分形布朗运动（Fractal Brownian Motion，简称FBM）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#raymarch">0.3 光线步进（Raymarch）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">1 云体建模</a><ul>
<li><a class="reference internal" href="#id7">1.1 柏林-沃利噪音</a><ul>
<li><a class="reference internal" href="#id8">1.1.1 柏林噪音</a></li>
<li><a class="reference internal" href="#fbm">1.1.2 FBM算法</a></li>
<li><a class="reference internal" href="#id9">1.1.3 柏林FBM噪音</a></li>
<li><a class="reference internal" href="#id10">1.1.4 沃利噪音</a></li>
<li><a class="reference internal" href="#id11">1.1.5 沃利FBM噪音</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">1.2 柏林-沃利噪音实现</a><ul>
<li><a class="reference internal" href="#remap">1.2.1 重映射函数（Remap）</a></li>
<li><a class="reference internal" href="#id13">1.2.2 柏林-沃利三维噪音纹理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">1.3 三维沃利噪音纹理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">2 光线步进与采样</a><ul>
<li><a class="reference internal" href="#id16">2.1 光线步进</a><ul>
<li><a class="reference internal" href="#post-processing">2.1.1 后处理（Post Processing）</a></li>
<li><a class="reference internal" href="#id17">2.1.2 光线步进原理</a><ul>
<li><a class="reference internal" href="#id18">2.1.2.1 光线</a><ul>
<li><a class="reference internal" href="#id19">2.1.2.1.1 其他光线算法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id20">2.1.2.2 步进循环</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21">2.1.3 包围盒</a><ul>
<li><a class="reference internal" href="#id22">2.1.3.1 描述包围盒</a></li>
<li><a class="reference internal" href="#id23">2.1.3.2 包围盒中步进的起点和终点</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id24">2.1.4 包围盒内光线步进</a><ul>
<li><a class="reference internal" href="#id25">2.1.4.1 包围盒内三维纹理采样</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id26">3 光照</a><ul>
<li><a class="reference internal" href="#id27">3.1 介绍</a><ul>
<li><a class="reference internal" href="#id28">3.1.1 符号对照表</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id29">3.2 体渲染理论</a><ul>
<li><a class="reference internal" href="#id30">3.2.1 体积特性</a><ul>
<li><a class="reference internal" href="#extinction-single-scattering-albedo">3.2.1.1 参数化消亡（<code class="docutils literal notranslate"><span class="pre">Extinction</span></code>）和单散射反照率（<code class="docutils literal notranslate"><span class="pre">Single</span> <span class="pre">Scattering</span> <span class="pre">Albedo</span></code>）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id31">3.2.2 体积中的光线传输</a><ul>
<li><a class="reference internal" href="#radiative-transfer-equation">3.2.2.1 辐射传输方程（<code class="docutils literal notranslate"><span class="pre">Radiative</span> <span class="pre">Transfer</span> <span class="pre">Equation</span></code>）</a></li>
<li><a class="reference internal" href="#volume-rendering-equation">3.2.2.2 体渲染方程（<code class="docutils literal notranslate"><span class="pre">Volume</span> <span class="pre">Rendering</span> <span class="pre">Equation</span></code>）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id32">3.2.3 追踪方式</a><ul>
<li><a class="reference internal" href="#closed-form-tracking">3.2.3.1 最近式追踪（<code class="docutils literal notranslate"><span class="pre">Closed-form</span> <span class="pre">Tracking</span></code>）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id33">4 问题</a></li>
<li><a class="reference internal" href="#id34">未完待续</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </body>
</html>