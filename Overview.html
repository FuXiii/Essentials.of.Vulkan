<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="genindex.html" /><link rel="search" title="搜索" href="search.html" /><link rel="next" title="最初之物 VkInstance" href="Instance.html" /><link rel="prev" title="环境配置" href="EnvironmentalConfig.html" />
        <link rel="canonical" href="https://github.com/FuXiii/Essentials.of.Vulkan/Overview.html" />

    <link rel="shortcut icon" href="_static/VulkanLogo.png"/><!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>纵览 - Vulkan入门精要</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b20cc3f5" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom_sidebar_drawer.css?v=32ac55f0" />
    <link rel="stylesheet" type="text/css" href="_static/css/custom_content.css?v=f312dc1c" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Vulkan入门精要</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
<div class="sidebar-sticky" ><a class="sidebar-brand" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/Vulkan.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Vulkan入门精要</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">入门精要</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="StartFromVulkanSDK.html">开始于 Vulkan SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="EnvironmentalConfig.html">环境配置</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">纵览</a></li>
<li class="toctree-l1"><a class="reference internal" href="Instance.html">最初之物 VkInstance</a></li>
<li class="toctree-l1"><a class="reference internal" href="PhysicalDevice.html">物理设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="DeviceQueue.html">设备队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicDevice.html">逻辑设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">内存</a></li>
<li class="toctree-l1"><a class="reference internal" href="Resource.html">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="ResourceAndMemory.html">资源与内存</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">文献翻译</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="Literature/index.html">文献</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 文献</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Literature/VulkanRayTracingFinalSpecificationRelease.html">Vulkan 光线追踪最终标准发布</a></li>
<li class="toctree-l2"><a class="reference internal" href="Literature/Vulkan-GuideRayTracing.html">光线追踪</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/NVIDIAVulkanRayTracingTutorial.html">NVIDIA Vulkan 光线追踪教程</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of NVIDIA Vulkan 光线追踪教程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/JitterCamera.html">相机抖动抗锯齿教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/AnyHitShaders.html">任意命中着色器（Any Hit Shaders）教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Instances.html">实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Reflections.html">反射</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/MultipleClosestHitShaders.html">多重最近命中着色器</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Animation.html">动态更新</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/IntersectionShader.html">相交着色器</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/CallableShaders.html">可调用着色器</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/RayQuery.html">光线查询</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/glTFScene.html">glTF 场景</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Literature/vk_mini_path_tracer.html">Vulkan迷你路径追踪</a></li>
<li class="toctree-l2"><a class="reference internal" href="Literature/TheRTXShaderBindingTableThreeWays.html">RTX 着色器绑定表的三种方式</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">随笔</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="InformalEssay/index.html">Vulkan 标准</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Vulkan 标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VulkanKHRRayTracing.html">Vulkan KHR 光线追踪标准</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Vulkan KHR 光线追踪标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_acceleration_structure.html">VK_KHR_acceleration_structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_ray_tracing_pipeline.html">VK_KHR_ray_tracing_pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_deferred_host_operations.html">VK_KHR_deferred_host_operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/ShaderBindingTable.html">着色器绑定表</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="InformalEssay/VK_KHR_buffer_device_address.html">VK_KHR_buffer_device_address</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="InformalEssay/VulkanForAndroid.html">Android 平台适配</a></li>
<li class="toctree-l1"><a class="reference internal" href="InformalEssay/VSCode.html">Visual Studio Code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">工程应用</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="Application/index.html">应用</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 应用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Application/VolumetricCloud.html">体积云</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUImGui.html">WebGPU ImGui</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUHelloTriangle.html">WebGPU Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUShaderCompiler.html">WebGPU Shader Compiler</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">更新日志</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Changelog.html">更新日志</a></li>
</ul>

</div>
</div>

</div>

    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/FuXiii/Essentials.of.Vulkan/edit/main/source/Overview.rst" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="id1">
<h1>纵览<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header sd-bg-muted sd-bg-text-muted">
<span class="sd-summary-icon"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-history" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M1.643 3.143L.427 1.927A.25.25 0 000 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 00.177-.427L2.715 4.215a6.5 6.5 0 11-1.18 4.458.75.75 0 10-1.493.154 8.001 8.001 0 101.6-5.684zM7.75 4a.75.75 0 01.75.75v2.992l2.028.812a.75.75 0 01-.557 1.392l-2.5-1A.75.75 0 017 8.25v-3.5A.75.75 0 017.75 4z"></path></svg></span>更新记录<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<ul class="simple">
<li><p class="sd-card-text">2023/5/15 增加该文章</p></li>
<li><p class="sd-card-text">2023/5/16 将 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 章节的内容移动至单独 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 文章中</p></li>
<li><p class="sd-card-text">2023/6/23 更新该文档</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">能为我们做什么</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">接口</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">最初之物</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 增加 <code class="docutils literal notranslate"><span class="pre">创建</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 更新 <code class="docutils literal notranslate"><span class="pre">创建</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">VkApplicationInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">获取支持的</span> <span class="pre">Vulkan</span> <span class="pre">版本</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">获取支持的</span> <span class="pre">Vulkan</span> <span class="pre">版本</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的接口</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">获取物理硬件设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节并增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 声明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/27 更新 <code class="docutils literal notranslate"><span class="pre">获取物理硬件设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/27 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节，增加全局函数的条目</p></li>
<li><p class="sd-card-text">2023/6/27 增加 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">获取物理设备属性</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 更新 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceType</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">句柄</span></code> 描述</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">设备队列</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 更新 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">稀疏</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列信息</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFlagBits</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 更新 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的静态库</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">逻辑设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">创建逻辑设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 更新 <code class="docutils literal notranslate"><span class="pre">获取设备队列（族）信息</span></code> 章节。修改 <code class="docutils literal notranslate"><span class="pre">例程</span></code> 的错误</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列（族）信息</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Device</span> <span class="pre">域函数</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数特殊性</span></code> 说明，修正分类说明，删除 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">内存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">内存分类</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">分配内存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节中的 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数特殊性</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/9 更新 <code class="docutils literal notranslate"><span class="pre">分配内存</span></code> 章节更名为 <code class="docutils literal notranslate"><span class="pre">分配缓存</span></code></p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 修正 <code class="docutils literal notranslate"><span class="pre">内存分类</span></code> 章节中的一些错误，优化调理，增加新的说明。</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span> <span class="pre">结构图</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/10 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数例程</p></li>
<li><p class="sd-card-text">2023/10/3 将 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存</span></code> 章节重命名为 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存信息</span></code></p></li>
<li><p class="sd-card-text">2023/10/3 更新 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">堆</span></code> 说明。</p></li>
<li><p class="sd-card-text">2023/10/3 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节，更新 <code class="docutils literal notranslate"><span class="pre">队列族</span></code> 说明图示。</p></li>
<li><p class="sd-card-text">2023/10/3 更新 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span> <span class="pre">结构图</span></code> 章节，更新说明图示。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 章节中的说明。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">分配缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存信息</span></code> 章节。将 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 更改为 <code class="docutils literal notranslate"><span class="pre">内存</span></code> 。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">VkAllocationCallbacks*</span> <span class="pre">pAllocator</span></code> 说明。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">内存管理</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/6 更新 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节。修正 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap::size</span></code> 单位讲解错误。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">回收内存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/12 增加开头 <code class="docutils literal notranslate"><span class="pre">篇幅</span></code> 注意事项。</p></li>
<li><p class="sd-card-text">2023/10/12 增加 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/12 增加 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 更新 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 更新 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceSize</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkBufferUsageFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkSharingMode</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">VkImageType</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">VkExtent3D</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkSampleCountFlagBits</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageTiling</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageUsageFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkFormat</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageLayout</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span> <span class="pre">其他参数和综述</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">VkImageLayout</span></code> 章节。修正一些语句不通顺的地方。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">VkImageUsageFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span> <span class="pre">其他参数和综述</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">综述</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/22 增加 <code class="docutils literal notranslate"><span class="pre">资源与内存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/22 增加 <code class="docutils literal notranslate"><span class="pre">vkGetBufferMemoryRequirements</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/22 增加 <code class="docutils literal notranslate"><span class="pre">vkGetImageMemoryRequirements</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/22 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/22 增加 <code class="docutils literal notranslate"><span class="pre">memoryTypeBits</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/2 更新 <code class="docutils literal notranslate"><span class="pre">篇幅</span></code> 说明。</p></li>
<li><p class="sd-card-text">2024/1/2 更新 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节。修正一些用词。</p></li>
<li><p class="sd-card-text">2024/1/2 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的句柄</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/2 增加 <code class="docutils literal notranslate"><span class="pre">Dispatchable</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/2 增加 <code class="docutils literal notranslate"><span class="pre">Non-dispatchable</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/3 增加 <code class="docutils literal notranslate"><span class="pre">句柄的使用</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/3 更新 <code class="docutils literal notranslate"><span class="pre">Non-dispatchable</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/3 增加 <code class="docutils literal notranslate"><span class="pre">句柄初始化</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/3 更新 <code class="docutils literal notranslate"><span class="pre">篇幅</span></code> 章节。去掉分章计划。</p></li>
<li><p class="sd-card-text">2024/1/3 增加 <code class="docutils literal notranslate"><span class="pre">资源与内存的绑定</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/3 增加 <code class="docutils literal notranslate"><span class="pre">vkBindBufferMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/3 增加 <code class="docutils literal notranslate"><span class="pre">vkBindImageMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/4 更新 <code class="docutils literal notranslate"><span class="pre">vkBindBufferMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/4 更新 <code class="docutils literal notranslate"><span class="pre">vkBindImageMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/4 增加 <code class="docutils literal notranslate"><span class="pre">数据传输</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/4 增加 <code class="docutils literal notranslate"><span class="pre">通过CPU向内存中传输数据</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/4 增加 <code class="docutils literal notranslate"><span class="pre">vkMapMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/4 增加 <code class="docutils literal notranslate"><span class="pre">vkUnmapMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/5 更新 <code class="docutils literal notranslate"><span class="pre">通过GPU向内存中传输数据</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 更新 <code class="docutils literal notranslate"><span class="pre">通过GPU向内存中传输数据</span></code> 章节。增加对 <code class="docutils literal notranslate"><span class="pre">srcBuffer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dstBuffer</span></code> 的基本要求说明。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">图片视图</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateImageView</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">VkImageViewCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">VkImageViewType</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">VkImageSubresourceRange</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">VkImageAspectFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">解析范围</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">VkComponentMapping</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/6 增加 <code class="docutils literal notranslate"><span class="pre">VkComponentSwizzle</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/8 增加 <code class="docutils literal notranslate"><span class="pre">指令</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/8 增加 <code class="docutils literal notranslate"><span class="pre">指令缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/9 更新 <code class="docutils literal notranslate"><span class="pre">指令缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/9 增加 <code class="docutils literal notranslate"><span class="pre">指令缓存池</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/9 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateCommandPool</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/9 增加 <code class="docutils literal notranslate"><span class="pre">VkCommandPoolCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/9 增加 <code class="docutils literal notranslate"><span class="pre">VkCommandPoolCreateFlagBits</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/10 增加 <code class="docutils literal notranslate"><span class="pre">分配指令缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/10 增加 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferAllocateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/10 增加 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferLevel</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/10 增加 <code class="docutils literal notranslate"><span class="pre">指令记录</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/14 更新 <code class="docutils literal notranslate"><span class="pre">指令记录</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/14 增加 <code class="docutils literal notranslate"><span class="pre">vkBeginCommandBuffer</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/14 更新 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferLevel</span></code> 章节。增加对 <code class="docutils literal notranslate"><span class="pre">一级</span></code> 和 <code class="docutils literal notranslate"><span class="pre">二级</span></code> 说明。</p></li>
<li><p class="sd-card-text">2024/1/14 增加 <code class="docutils literal notranslate"><span class="pre">开启指令缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/14 更新 <code class="docutils literal notranslate"><span class="pre">通过GPU向内存中传输数据</span></code> 章节。增加 <code class="docutils literal notranslate"><span class="pre">开启指令缓存指令记录</span></code> 和 <code class="docutils literal notranslate"><span class="pre">结束指令缓存指令记录</span></code> 。</p></li>
<li><p class="sd-card-text">2024/1/14 增加 <code class="docutils literal notranslate"><span class="pre">结束指令缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/14 增加 <code class="docutils literal notranslate"><span class="pre">vkEndCommandBuffer</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/14 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">能为我们做什么</span></code> 章节。修改该文档的 <code class="docutils literal notranslate"><span class="pre">纵览目标</span></code>。</p></li>
<li><p class="sd-card-text">2024/1/20 更新代码中中文符号修改成英文符号。</p></li>
<li><p class="sd-card-text">2024/1/20 更新 <code class="docutils literal notranslate"><span class="pre">指令推送</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">vkQueueSubmit</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">VkSubmitInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">等待指令缓存执行完成</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">vkDeviceWaitIdle</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">vkQueueWaitIdle</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">栏栅</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateFence</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">VkFenceCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">等待栏栅</span></code> 章节。</p></li>
<li><p class="sd-card-text">2024/1/20 增加 <code class="docutils literal notranslate"><span class="pre">vkWaitForFences</span></code> 章节。</p></li>
</ul>
</div>
</details><p>由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 比较复杂，为了更好的入门 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，还是大致过一遍 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的核心思路，这对以后的学习很有帮助。</p>
<div class="caution admonition">
<p class="admonition-title">篇幅</p>
<p>该 <code class="docutils literal notranslate"><span class="pre">纵览</span></code> 章节会比较长。但也推荐您通读一遍。之后会分章节进行精讲。</p>
</div>
<section id="vulkan">
<h2>Vulkan 能为我们做什么<a class="headerlink" href="#vulkan" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 最主要的任务就是为我们提供了 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 并行计算的接口。是的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 仅仅只是规定了一套接口，其并没有接口的具体实现，而实现是需要硬件厂商自己适配实现，所以市面上并不是所有硬件设备都支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 。像 <code class="docutils literal notranslate"><span class="pre">NVIDIA</span></code> 、 <code class="docutils literal notranslate"><span class="pre">AMD</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Intel</span></code> 等国际大厂基本提供了完整的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code>
核心标准接口。而像国产的后起之秀 <a class="reference external" href="https://www.mthreads.com/">摩尔线程</a> 也在努力适配 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准（ <span class="sd-sphinx-override sd-badge sd-bg-warning sd-bg-text-warning">景嘉微你要加油啊</span>）。由于标准的实现都是自家的，所以每家厂商都可以根据自家设备的特点进行优化和扩展，这样在提供 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心功能的基础上也推出了自家的扩展功能，而扩展功能往往是该设备的卖点（比如硬件实时光线追踪扩展功能）。</p>
<p>而在使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 时，相比于标准，我们往往更关注于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 所提供的功能，主要的功能如下：</p>
<ul class="simple">
<li><p>光栅化渲染</p></li>
<li><p>实时光线追踪</p></li>
<li><p>视频编解码</p></li>
<li><p>（通用）并行计算</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">光栅化渲染</span></code> 应该是最主要的功能了（同时也是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的核心功能）。</p>
<p>该章节主要以所有功能通用开发流程为核心进行纵览。</p>
</section>
<section id="id3">
<h2>Vulkan 的句柄<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有 <code class="docutils literal notranslate"><span class="pre">对象</span></code> 都是以 <code class="docutils literal notranslate"><span class="pre">句柄</span></code> 的形式呈现的。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中有两种句柄：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Dispatchable</span> 可调度句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Non-dispatchable</span> 不可调度句柄。</p></li>
</ul>
<section id="dispatchable">
<h3>Dispatchable<a class="headerlink" href="#dispatchable" title="Link to this heading">#</a></h3>
<p>可调度句柄有如下特点：</p>
<ul class="simple">
<li><p>拥有具体类型定义的指针。</p></li>
<li><p>在生命周期内，其句柄值是唯一的。</p></li>
</ul>
<p>在 <code class="docutils literal notranslate"><span class="pre">vulkan_core.h</span></code> 的头文件中使用 <code class="docutils literal notranslate"><span class="pre">VK_DEFINE_HANDLE(object)</span></code> 宏来定义，该宏的定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄就是使用该宏定义的可调度句柄：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkInstance</span><span class="p">)</span>
<span class="c1">// 等价于如下定义</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstance_T</span><span class="o">*</span><span class="w"> </span><span class="n">VkInstance</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="non-dispatchable">
<h3>Non-dispatchable<a class="headerlink" href="#non-dispatchable" title="Link to this heading">#</a></h3>
<p>不可调度句柄有如下特点：</p>
<ul class="simple">
<li><p>是一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位整形。</p></li>
<li><p>具体存储的数据是驱动内部自定义的。</p></li>
<li><p>句柄本身可能用于存储对象数据，所以句柄值不是唯一的（但这不影响该句柄的销毁）</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">是一个64位整形</span> 也不绝对，其说明如下。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">句柄值不是唯一的</span> 如果设备激活 <code class="docutils literal notranslate"><span class="pre">privateData</span></code> 特性了的话，不可调度的句柄在生命周期内，其句柄值是唯一的。</p></li>
</ul>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">vulkan_core.h</span></code> 的头文件中使用 <code class="docutils literal notranslate"><span class="pre">VK_DEFINE_NON_DISPATCHABLE_HANDLE(object)</span></code> 宏来定义，该宏的定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef VK_USE_64_BIT_PTR_DEFINES</span>
<span class="w">   </span><span class="cp">#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)</span>
<span class="w">      </span><span class="cp">#define VK_USE_64_BIT_PTR_DEFINES 1</span>
<span class="w">   </span><span class="cp">#else</span>
<span class="w">      </span><span class="cp">#define VK_USE_64_BIT_PTR_DEFINES 0</span>
<span class="w">   </span><span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE</span>
<span class="w">   </span><span class="cp">#if (VK_USE_64_BIT_PTR_DEFINES==1)</span>
<span class="w">      </span><span class="cp">#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;</span>
<span class="w">   </span><span class="cp">#else</span>
<span class="w">      </span><span class="cp">#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;</span>
<span class="w">   </span><span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>通过上面的代码我们可以知道， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 会先确认当前平台是否支持 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位的指针，如果支持则 <code class="docutils literal notranslate"><span class="pre">不可调度句柄</span></code> 定义与 <code class="docutils literal notranslate"><span class="pre">可调度句柄</span></code> 定义相同。否则使用 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位整形表示该句柄。</p>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkBuffer</span></code> 句柄就是使用该宏定义的不可调度句柄：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkBuffer</span><span class="p">)</span>
<span class="c1">// 等价于如下定义</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkBuffer_T</span><span class="o">*</span><span class="w"> </span><span class="n">VkBuffer</span><span class="p">;</span><span class="w"> </span><span class="c1">// 支持64位指针</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">VkBuffer</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不支持64位指针</span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>句柄的使用<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中已经声明了一系列的句柄类型供我们使用：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkInstance</span><span class="p">)</span>
<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkPhysicalDevice</span><span class="p">)</span>
<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkDevice</span><span class="p">)</span>
<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkQueue</span><span class="p">)</span>
<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkCommandBuffer</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkBuffer</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkImage</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkSemaphore</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkFence</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkDeviceMemory</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkEvent</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkQueryPool</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkBufferView</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkImageView</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkShaderModule</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkPipelineCache</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkPipelineLayout</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkPipeline</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkRenderPass</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkDescriptorSetLayout</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkSampler</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkDescriptorSet</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkDescriptorPool</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkFramebuffer</span><span class="p">)</span>
<span class="n">VK_DEFINE_NON_DISPATCHABLE_HANDLE</span><span class="p">(</span><span class="n">VkCommandPool</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此处为核心句柄， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 还有很多其他用于扩展功能的句柄。</p>
</div>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的句柄有明确的子父级关系，也就是 <code class="docutils literal notranslate"><span class="pre">B</span></code> 句柄是由 <code class="docutils literal notranslate"><span class="pre">A</span></code> 句柄创建出来的，因此 <code class="docutils literal notranslate"><span class="pre">A</span></code> 为 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的父句柄。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 要求子句柄仅能被自己的父句柄使用。比如 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄就是 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 的父句柄。</p>
</div>
<p>如此，我们就可以使用这些已经声明好的句柄了，比如声明一个 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span>
<span class="c1">//等价于</span>
<span class="n">VkInstance_T</span><span class="o">*</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="id5">
<h3>句柄初始化<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>不同编译器对于没有明确初始值变量默认值策略不同，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 声明了 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 宏定义用于明确句柄的初始值。其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE</span>
<span class="w">    </span><span class="cp">#if (VK_USE_64_BIT_PTR_DEFINES==1)</span>
<span class="w">        </span><span class="cp">#if (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)) || (defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG &gt;= 201103L))</span>
<span class="w">            </span><span class="cp">#define VK_NULL_HANDLE nullptr</span>
<span class="w">        </span><span class="cp">#else</span>
<span class="w">            </span><span class="cp">#define VK_NULL_HANDLE ((void*)0)</span>
<span class="w">        </span><span class="cp">#endif</span>
<span class="w">    </span><span class="cp">#else</span>
<span class="w">        </span><span class="cp">#define VK_NULL_HANDLE 0ULL</span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef VK_NULL_HANDLE</span>
<span class="w">    </span><span class="cp">#define VK_NULL_HANDLE 0</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>可以看到 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 要么是个明确的空指针，要么就是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。如此，我们就可以初始化句柄了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="id6">
<h2>Vulkan 的接口<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的接口，也就是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数，最开始是使用 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言发布的，有些繁琐，后来推出了 <code class="docutils literal notranslate"><span class="pre">C++</span></code> 版本的接口，现在 <code class="docutils literal notranslate"><span class="pre">Python</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Java</span></code> 和 <code class="docutils literal notranslate"><span class="pre">C#</span></code> 等高级语言也陆续支持开发 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的家族也在慢慢壮大。</p>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>本教程主要是用最原始的 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言版本进行讲解。</p>
</div>
</section>
<section id="id7">
<h2>获取 Vulkan 接口<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 只是一套标准，具体的实现都在硬件驱动中，为了能够使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 驱动硬件设备，我们需要获取驱动中 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准实现的接口。</p>
<section id="id8">
<h3>加载 Vulkan 动态库<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中提供了 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 用于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准接口函数的获取。根据前文介绍我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 对应着 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库，所以我们第一步就是加载 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库。</p>
<div class="note admonition">
<p class="admonition-title">Vulkan 的动态库</p>
<p><code class="docutils literal notranslate"><span class="pre">Windows</span></code> 操作系统上 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库为 <code class="docutils literal notranslate"><span class="pre">vulkan-1.dll</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 上的为 <code class="docutils literal notranslate"><span class="pre">libvulkan.so.1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">libvulkan.so</span></code> 。</p>
</div>
<div class="hint admonition">
<p class="admonition-title">Vulkan 的静态库</p>
<p>为什么不是用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的静态库呢？最主要的原因来源于 <a class="reference external" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderApplicationInterface.md#static-linking">Vulkan Loader 的 Static Linking</a> 文档：</p>
<blockquote>
<div><p>In previous versions of the loader, it was possible to statically link the loader. This was removed and is no longer possible. The decision to remove static linking was because of changes to the driver which made older applications that statically linked unable to find newer drivers.</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 之前的版本中，是可以静态链接 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 的。这将会在不久的将来移除。这是由于之前静态链接的老程序无法找到新的驱动。</p>
</div></blockquote>
<p>此外静态链接有如下问题：</p>
<ul class="simple">
<li><p>除非重编译链接原工程否则永远得不到新 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 内容</p></li>
<li><p>包含的两个库可能会链接了不同版本的 <code class="docutils literal notranslate"><span class="pre">Loader</span></code></p></li>
</ul>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-0">
Windows 加载</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Windows.h&gt;</span>

<span class="n">HMODULE</span><span class="w"> </span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">&quot;vulkan-1.dll&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-1">
Linux 加载</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dlfcn.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libvulkan.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RTLD_NOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTLD_LOCAL</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">library</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libvulkan.so&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RTLD_NOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTLD_LOCAL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id9">
<h3>Vulkan 函数分类<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>之后我们就可以从加载的动态库中获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的函数了，但是在获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数前我们需要先介绍一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中函数的分类：</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Instance 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 进行交互。主要是获取一些与设备不相关与环境相关的函数。</dt><dd><ul>
<li><dl class="simple">
<dt><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">全局函数</span> 在 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数中有几个函数为全局函数。所谓全局函数是指任何驱动都需要实现的接口，并且用户可直接无条件获取其实现。全局函数如下：</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceExtensionProperties</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceLayerProperties</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">PhysicalDevice 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 进行交互。主要是一些获取硬件设备相关信息的函数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Device 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 进行交互。主要是获取一些与硬件设备相关的功能函数。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">PhysicalDevice 域函数特殊性</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 文档中 <a class="reference external" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#_extending_physical_device_core_functionality">4.1.1 Extending Physical Device Core Functionality</a> 中有相关 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 的描述。</p>
<blockquote>
<div><p>当物理设备支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本等于或高于对应函数发布时的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本的话，用户可以使用对应函数。换句话就是，如果在创建 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境时（创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 时）使用了较低版本，但是物理设备支持的版本高于此版本（ <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> ），并且 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 在物理设备支持的高版本中被定义并实现，则可以获取高版本的 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 使用。</p>
</div></blockquote>
<p>一般可以认为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span></code> 域函数为特殊的 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数。</p>
</div>
<div class="note admonition">
<p class="admonition-title">vkGetInstanceProcAddr 和 Device 域函数</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中并没有禁止用户使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 获得 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数，但这是不推荐的，当有多个硬件设备时会造成模棱两可的函数获取。比如电脑上插着两个显卡，一个是摩尔线程的，一个是景嘉微的，这两个设备都支持绘制函数 <code class="docutils literal notranslate"><span class="pre">vkCmdDraw</span></code> 函数 ，但是到底获取的是哪个设备的实现是由 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 定义的，用户并不能知道返回的函数是哪个设备的实现。</p>
</div>
</section>
<section id="vkgetinstanceprocaddr">
<h3>vkGetInstanceProcAddr<a class="headerlink" href="#vkgetinstanceprocaddr" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中获取 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数，提供了统一的 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数获取接口，如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">VKAPI_PTR</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_vkVoidFunction</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">PFN_vkVoidFunction</span><span class="w"> </span><span class="nf">vkGetInstanceProcAddr</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pName</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">instance</span> 获取 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 兼容的函数接口，或是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 用于获取不依赖任何 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的函数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pName</span> 获取的接口函数名称。</p></li>
</ul>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数之后就可以使用该函数获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数了。</p>
<div class="note admonition">
<p class="admonition-title">获取全局函数</p>
<p>获取全局函数时 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code></p>
</div>
<div class="note admonition">
<p class="admonition-title">PFN_{函数名}</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中，所有的接口函数都有对应的函数指针声明，命名规则为 <code class="docutils literal notranslate"><span class="pre">PFN_{函数名}</span></code> 。</p>
</div>
<div class="note admonition">
<p class="admonition-title">PFN_vkVoidFunction 与 vkGetInstanceProcAddr</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型函数指针。但是我们想获得 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中如 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 这样的函数指针，该指针并不是 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型的，而是 <code class="docutils literal notranslate"><span class="pre">PFN_vkCreateInstance</span></code> 类型的，如何从 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型获得 <code class="docutils literal notranslate"><span class="pre">PFN_vkCreateInstance</span></code> 类型呢？
在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中规定直接使用强制类型转换即可。下文有示例。</p>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-2" name="sd-tab-set-1" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-2">
Windows 获取</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="w"> </span><span class="n">vkGetInstanceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetInstanceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-3" name="sd-tab-set-1" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-3">
Linux 获取</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="w"> </span><span class="n">vkGetInstanceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetInstanceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>之后就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 获取 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域的函数了。比如获取 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数接口：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkCreateInstance</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateInstance</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">VK_NULL_HANDLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateInstance&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">VK_NULL_HANDLE</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 被定义为空或无效句柄，一般被声明为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 、 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于获取 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span></code> 域函数和 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数将会在后文有所体现。</p>
</div>
<div class="note admonition">
<p class="admonition-title">句柄</p>
<p>英文为 <code class="docutils literal notranslate"><span class="pre">Handle</span></code> ，一般认为句柄与唯一识别号作用相同，一个句柄代表一个具体对象，函数作用在句柄上，内部是在修改句柄背后对应的那个对象。</p>
</div>
</section>
</section>
<section id="vulkan-vkinstance">
<h2>Vulkan 最初之物 VkInstance<a class="headerlink" href="#vulkan-vkinstance" title="Link to this heading">#</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中首先要创建的就是 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 对象。该对象包含了用户设置的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境信息，包括使用的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的版本信息等，用于初始化 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境，并构建出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 这个繁杂的系统根基。 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;</span>

<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkInstance</span><span class="p">)</span>
</pre></div>
</div>
<p>从 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 定义可知为一个句柄，该句柄为一个结构体指针。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有的对象都是一个句柄。</p>
<p>如上 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 声明等价于:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstance_T</span><span class="o">*</span><span class="w"> </span><span class="n">VkInstance</span><span class="p">;</span>
</pre></div>
</div>
<p>也就是说 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 在底层其实是作为一个类型为 <code class="docutils literal notranslate"><span class="pre">VkInstance_T</span></code> 的指针在使用。</p>
<div class="note admonition">
<p class="admonition-title">Vulkan 中的句柄</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中并不是所有的句柄都是指针类型，也有可能是一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位的无符号整形，具体是什么类型与平台相关。但用户并不需要关心句柄的底层表达， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中对所有的句柄都做了分别进行了声明，这样用户只需要使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供的句柄声明即可。
比如声明一个未初始化的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄（对象）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
</pre></div>
</div>
</div>
<section id="vkinstance">
<h3>创建 VkInstance<a class="headerlink" href="#vkinstance" title="Link to this heading">#</a></h3>
<section id="vkcreateinstance">
<h4>vkCreateInstance<a class="headerlink" href="#vkcreateinstance" title="Link to this heading">#</a></h4>
<p>我们通过之前获取到的 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 。相关声明如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateInstance</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="w">                 </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkInstance</span><span class="o">*</span><span class="w">                                 </span><span class="n">pInstance</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 指向 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 数据结构对象，用于控制 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的创建。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pInstance</span> 创建的目标 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 结果。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 属于全局函数。</p>
</div>
<div class="note admonition">
<p class="admonition-title">pAllocator</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中创建句柄是需要设置内存分配器的，也就是 <code class="docutils literal notranslate"><span class="pre">pAllocator</span></code> ，这对于统计内存使用情况和自定义内存分配非常重要，如果没有自定义分配器的话也可以是直接传 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> ，这将会使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 内置的分配器进行分配。</p>
</div>
<p>如果创建成功将会返回 <code class="docutils literal notranslate"><span class="pre">VkResult::VK_SUCCESS</span></code> 枚举值，否则将返回错误结果枚举值。</p>
<div class="note admonition">
<p class="admonition-title">VK_SUCCESS</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中返回的大多数结果值来说，成功基本都是 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> ，否则就是失败（有极个别返回其他结果也可以算作成功，遇到再说）。还有一点需要注意的是， <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 的枚举值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_SUCCESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="n">VkResult</span><span class="p">;</span>
</pre></div>
</div>
<p>也就是，不应该出现如下判断：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="c1">// 如果此时 result 为 VK_SUCCESS ，而 VK_SUCCESS 的枚举值为 0 ，会导致判定不满足条件。</span>
<span class="p">...</span>
</pre></div>
</div>
<p>而正确的做法为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
</section>
<section id="vkinstancecreateinfo">
<h4>VkInstanceCreateInfo<a class="headerlink" href="#vkinstancecreateinfo" title="Link to this heading">#</a></h4>
<p>来看一下 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 的定义：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstanceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkInstanceCreateFlags</span><span class="w">       </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkApplicationInfo</span><span class="o">*</span><span class="w">    </span><span class="n">pApplicationInfo</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">enabledLayerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">          </span><span class="n">ppEnabledLayerNames</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">enabledExtensionCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">          </span><span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkInstanceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 是 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateFlagBits</span></code> 所表示的位域值，用于设置 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的行为。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApplicationInfo</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向应用信息结构体，用于  <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的细节设置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledLayerCount</span> 激活的 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledLayerNames</span> 指向数量为 <code class="docutils literal notranslate"><span class="pre">enabledLayerCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 字符串数组，用于设置要激活的 <code class="docutils literal notranslate"><span class="pre">layer</span></code>。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 激活 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 扩展的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 指向数量为 <code class="docutils literal notranslate"><span class="pre">enabledExtensionCount</span></code> 的扩展字符串数组，用于设置要激活的 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 扩展。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">sType 与 pNext</p>
<p>初次学习 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 时会有个疑问： <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 已经是一个结构体了为什么还有使用 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 再指定一遍结构体类型呢？而且 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 成员，为什么？</p>
<p>这就不得不说明一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的扩展模块了。随着时代的发展，类似于 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 结构体中的数据可能并不满足于技术背景，需要进行扩展，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 引入了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员，而 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span></code> 类型，这也就是说 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 可以
指向任意一个类型对象的数据地址。由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员，这样每个结构体都可以使用 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指向下一个 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的结构体，这样一个接着一个将结构体进行串链就形成了一个扩展链。</p>
<div class="mermaid">
            flowchart LR
   subgraph VkInstanceCreateInfo
      direction TB
         VkInstanceCreateInfo_sType[&quot;sType = VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO&quot;]
         VkInstanceCreateInfo_pNext[&quot;pNext&quot;]
         %%VkInstanceCreateInfo_sType-.-&gt;VkInstanceCreateInfo_pNext
   end

   subgraph VulkanSomeStructureA[&quot;Vulkan某个结构体类型A&quot;]
      direction TB
         VulkanSomeStructureA_sType[&quot;sType = VkStructureType::某个结构体A类型&quot;]
         VulkanSomeStructureA_pNext[&quot;pNext&quot;]
         %%VulkanSomeStructureA_sType-.-&gt;VulkanSomeStructureA_pNext
   end

   subgraph VulkanSomeStructureB[&quot;Vulkan某个结构体类型B&quot;]
      direction TB
         VulkanSomeStructureB_sType[&quot;sType = VkStructureType::某个结构体B类型&quot;]
         VulkanSomeStructureB_pNext[&quot;pNext&quot;]
         %%VulkanSomeStructureB_sType-.-&gt;VulkanSomeStructureB_pNext
   end

   VkInstanceCreateInfo_pNext--&gt;VulkanSomeStructureA
   VulkanSomeStructureA_pNext--&gt;VulkanSomeStructureB
   VulkanSomeStructureB_pNext--&gt;a2[&quot;...&quot;]
        </div><p>这样驱动就可以根据 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指针链遍历所有的结构体数据了，但是有一个问题 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 只是个 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 指针，驱动在获取到 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指向的地址时并不知道这个地址应该按照哪种结构体类型进行解析，这时 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 的作用就体现出来了，驱动获取该地址下的 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 的数据，这样驱动就知道如何解析此块地址了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 驱动内部可能的实现</span>

<span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">某个结构体的地址</span><span class="p">;</span>
<span class="n">VkStructureType</span><span class="w"> </span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_MAX_ENUM</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sType</span><span class="p">,</span><span class="w"> </span><span class="n">pNext</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">VkStructureType</span><span class="p">));</span>

<span class="k">switch</span><span class="p">(</span><span class="n">sType</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">case</span><span class="w"> </span><span class="no">VkStructureType</span><span class="o">::</span><span class="no">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">:</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="w"> </span><span class="n">instance_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="p">)(</span><span class="n">pNext</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">break</span><span class="p">;</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="vkapplicationinfo">
<h4>VkApplicationInfo<a class="headerlink" href="#vkapplicationinfo" title="Link to this heading">#</a></h4>
<p>目前我们只需要关注 <code class="docutils literal notranslate"><span class="pre">VkApplicationInfo</span></code> 就好，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkApplicationInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">    </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">        </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">        </span><span class="n">pApplicationName</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">applicationVersion</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">        </span><span class="n">pEngineName</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">engineVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">apiVersion</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkApplicationInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须`是 ``VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO`</span> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApplicationName</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向一个以空字符为结尾的 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> 字符串，用于表示用户自定义应用名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">applicationVersion</span> 一个无符号整型，用于用户自定义应用版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pEngineName</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向一个以空字符为结尾的 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> 字符串，用于表示用户自定义引擎名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">engineVersion</span> 一个无符号整型，用于用户自定义引擎版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">apiVersion</span> 应用打算使用的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的最高版本，并且忽略 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">patch</span></code> 版本。</p></li>
</ul>
<p>如果设备驱动只支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 而用户设置的 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本高于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 的话， <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">VK_ERROR_INCOMPATIBLE_DRIVER</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo::pApplicationInfo</span></code> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的话，等价于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">VK_MAKE_API_VERSION(0,1,0,0)</span></code> 也就是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 版本。</p>
</div>
<p>这里我们主要关注 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 参数，这是一个非常重要的参数。该参数指定的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本决定了应用可以使用该版本及以前的版本功能，并不能使用高于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本功能。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 如何组成 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本的，已在 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan的版本</span></code> 中有讲解。</p>
</div>
<p>现在我们就可以创建一个最简单的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 版本的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkApplicationInfo</span><span class="w"> </span><span class="n">application_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_APPLICATION_INFO</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pApplicationName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">applicationVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pEngineName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">engineVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">apiVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_MAKE_API_VERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="n">VkInstanceCreateInfo</span><span class="w"> </span><span class="n">instance_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">pApplicationInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">application_info</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">enabledLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instance</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">创建失败</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>经过如上的代码，你可以发现创建一个句柄需要填写各种各样的 <code class="docutils literal notranslate"><span class="pre">Vk{结构体名称}Info</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Vk{句柄名称}CreateInfo</span></code> 等结构体。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中各式各样的结构体占了绝大多数。给人一种：<span class="sd-sphinx-override sd-badge sd-bg-info sd-bg-text-info">来，我这样有张大表，先把表填了，我才知道接下来如何干活</span> 的感觉。</p>
</div>
<div class="hint admonition">
<p class="admonition-title">现在我们面临一个问题</p>
<p>我咋知道设备支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的哪个版本？</p>
</div>
</section>
</section>
</section>
<section id="id10">
<h2>获取支持的 Vulkan 版本<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>由于历史原因 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 标准在设计时并没有考虑到获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本，只有获取驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。在 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 中我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本有两个版本，一个是系统端支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本，一个是驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。为什么会有两个版本？</p>
<p>这是由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的函数分为不同域。系统端支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本主要是用于配置系统支持的功能、 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 和扩展，不同版本支持的功能、 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 和扩展不尽相同。驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本主要是用于配置硬件设备支持的功能和扩展，不同版本支持的功能和扩展不尽相同。</p>
<p>之后在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.1</span></code> 标准中，推出了 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 接口来获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p>
<div class="note admonition">
<p class="admonition-title">硬件设备的 Layer</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 中硬件设备是有相关的 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 功能的，但用处不大，比较鸡肋，后来 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准组将硬件设备的 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 遗弃，但对外的接口还保留着。</p>
</div>
<p>由于在支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 的实现中 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 可能由于 <code class="docutils literal notranslate"><span class="pre">VK_ERROR_INCOMPATIBLE_DRIVER</span></code> 失败返回，所以需要在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 之前获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。获取流程如下：</p>
<div class="mermaid">
            flowchart TD
   TryToGetvkEnumerateInstanceVersion[&quot;尝试获取 vkEnumerateInstanceVersion 函数接口实现&quot;]
   IsNull{&quot;是否为 NULL&quot;}
   SupportVulkan_1_0[&quot;支持Vulkan 1.0&quot;]
   SupportVulkanFromvkEnumerateInstanceVersion[&quot;支持 vkEnumerateInstanceVersion 中获得的 Vulkan 版本&quot;]

   TryToGetvkEnumerateInstanceVersion--&gt;IsNull
   IsNull--是--&gt;SupportVulkan_1_0
   IsNull--否--&gt;SupportVulkanFromvkEnumerateInstanceVersion
        </div><section id="vkenumerateinstanceversion">
<h3>vkEnumerateInstanceVersion<a class="headerlink" href="#vkenumerateinstanceversion" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 函数定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEnumerateInstanceVersion</span><span class="p">(</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pApiVersion</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApiVersion</span> <code class="docutils literal notranslate"><span class="pre">instance</span></code> 域函数支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 属于全局函数。</p>
</div>
<p>接下来就让我们获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本吧：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkEnumerateInstanceVersion</span><span class="w"> </span><span class="n">vkEnumerateInstanceVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkEnumerateInstanceVersion</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">VK_NULL_HANDLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkEnumerateInstanceVersion&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">vkEnumerateInstanceVersion</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vulkan_version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkEnumerateInstanceVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vulkan_version</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">Vulkan</span><span class="w"> </span><span class="n">Loader</span><span class="w"> </span><span class="n">或任意一个</span><span class="w"> </span><span class="n">Layer</span><span class="w"> </span><span class="n">发生了内存分配失败</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">vulkan_version</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">VK_MAKE_API_VERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id11">
<h2>获取物理硬件设备<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 具有能够发现连接在主板上支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 设备的能力。通过 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数获取支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备。</p>
<section id="vkenumeratephysicaldevices">
<h3>vkEnumeratePhysicalDevices<a class="headerlink" href="#vkenumeratephysicaldevices" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEnumeratePhysicalDevices</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkInstance</span><span class="w">                                  </span><span class="n">instance</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pPhysicalDeviceCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="o">*</span><span class="w">                           </span><span class="n">pPhysicalDevices</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">instance</span> 是之前使用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 创建的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pPhysicalDeviceCount</span> 是用于指定或获取的物理设备数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pPhysicalDevices</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么是数量不小于 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 数组。</p></li>
</ul>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数将会将查询到支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备数量写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 所指向的内存中，所以 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是一个有效指针。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数将会将 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 数量的有效 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄依次写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 指向的数组中。如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 指定的数量小于支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备数量的话， <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 将会写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 个物理设备句柄到数组中并返回 <code class="docutils literal notranslate"><span class="pre">VK_INCOMPLETE</span></code> 表示并不是所有设备都写入数组返回。</p>
<p>如果一切正常 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄不需要通过类似 <code class="docutils literal notranslate"><span class="pre">vkCreatePhysicalDevice</span></code> 这样的函数创建（ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准也没有该函数 ），而是在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 时内部已经做好了管理。也就是说 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 的生命周期与 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄一致。</p>
</div>
<p>接下来就让我们获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的物理设备吧：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkEnumeratePhysicalDevices</span><span class="w"> </span><span class="n">vkEnumeratePhysicalDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkEnumeratePhysicalDevices</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkEnumeratePhysicalDevices&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此时 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 的第一个参数不为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 而为有效 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄。</p>
</div>
<p>之后即可以获取到物理设备了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_device_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_count</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">(</span><span class="n">physical_device_count</span><span class="p">);</span>
<span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_count</span><span class="p">,</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</pre></div>
</div>
</section>
</section>
<section id="id12">
<h2>获取物理设备属性<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>当获取到物理设备 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄之后，可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 函数获取对应物理设备的属性。</p>
<section id="vkgetphysicaldeviceproperties">
<h3>vkGetPhysicalDeviceProperties<a class="headerlink" href="#vkgetphysicaldeviceproperties" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceProperties</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceProperties</span><span class="o">*</span><span class="w">                 </span><span class="n">pProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 对应要获取属性的物理设备的句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pProperties</span> 对应返回的物理设备属性。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 定义如下：</p>
</section>
<section id="vkphysicaldeviceproperties">
<h3>VkPhysicalDeviceProperties<a class="headerlink" href="#vkphysicaldeviceproperties" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkPhysicalDeviceProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">apiVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">driverVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">vendorID</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">deviceID</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceType</span><span class="w">                </span><span class="n">deviceType</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w">                                </span><span class="n">deviceName</span><span class="p">[</span><span class="n">VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">                             </span><span class="n">pipelineCacheUUID</span><span class="p">[</span><span class="n">VK_UUID_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceLimits</span><span class="w">              </span><span class="n">limits</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceSparseProperties</span><span class="w">    </span><span class="n">sparseProperties</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">apiVersion</span> 该设备驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">driverVersion</span> 该设备驱动版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vendorID</span> 设备供应商的 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceID</span> 设备的 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceType</span> 设备类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceName</span> 设备名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pipelineCacheUUID</span> 设备的通用唯一识别码（ <code class="docutils literal notranslate"><span class="pre">universally</span> <span class="pre">unique</span> <span class="pre">identifier</span></code> ）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">limits</span> 设备的限值信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sparseProperties</span> 稀疏数据属性。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">稀疏</p>
<p><code class="docutils literal notranslate"><span class="pre">稀疏</span></code> 为离散在内存各处的大量数据，这些数据可以被一并使用，常用表述数据量巨大的资源。</p>
</div>
<p>这里我们主要关注 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 和 <code class="docutils literal notranslate"><span class="pre">deviceType</span></code> 属性。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 主要是用于描述对应设备支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的版本，该版本很重要，说明设备只支持 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 版本之前的标准，如果在此设备上使用高于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 版本的功能的话将会导致错误或未定义行为。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deviceType</span></code> 主要是用于描述对应设备是独立显卡还是集成显卡。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceType</span></code> 枚举值定义如下：</p>
</section>
<section id="vkphysicaldevicetype">
<h3>VkPhysicalDeviceType<a class="headerlink" href="#vkphysicaldevicetype" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkPhysicalDeviceType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_OTHER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_CPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_OTHER</span> 该设备类型不与任何其他类型匹配， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中未定义的设备类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span> 集成显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span> 独立显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span> 虚拟环境中的虚拟显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_CPU</span> 中央处理器（ <code class="docutils literal notranslate"><span class="pre">CPU</span></code> ）。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">VK_PHYSICAL_DEVICE_TYPE_CPU</p>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_CPU</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 类型的设备，但是在通过 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 获取物理设备时，并不一定会得到插在主板上的 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 设备句柄，由于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 并不一定支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，所以 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 不一定能够获得，大部分支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备还是显卡设备。</p>
</div>
<p>在使用时，一般首选使用 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span></code> 独立显卡，之后再考虑使用 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span></code> 集成显卡。</p>
<p>获取物理属性例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 获取相应的设备属性了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的所有设备</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkPhysicalDeviceProperties</span><span class="w"> </span><span class="n">physical_device_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">   </span><span class="n">vkGetPhysicalDeviceProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_properties</span><span class="p">);</span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Physical Device Name:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">physical_device_properties</span><span class="p">.</span><span class="n">deviceName</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="devicequeue">
<span id="id13"></span><h2>设备队列<a class="headerlink" href="#devicequeue" title="Link to this heading">#</a></h2>
<p>接下来简单介绍一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的设备队列。</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的每一个 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 物理设备上都有一到多个设备队列。设备队列用于执行所有的用户任务指令，包括渲染、计算、查询、剔除和构建等等各种任务指令。</p>
<p>每个设备队列支持一到多个功能域，这些功能域分为如下 <code class="docutils literal notranslate"><span class="pre">5</span></code> 种：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">图形</span> 主要用于图形渲染，执行各种渲染绘制指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">计算</span> 主要用于执行并行计算（计算着色器），执行各种计算指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">转移</span> 主要用于执行资源的布局转移并支持在不同队列中进行转移，执行各种转移指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">稀疏绑定</span> 主要用于稀疏内存的管理。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">受保护</span> 主要用于受保护的内存的管理。</p></li>
</ul>
<p>在使用时常用的为 <code class="docutils literal notranslate"><span class="pre">图形</span></code> 、 <code class="docutils literal notranslate"><span class="pre">计算</span></code> 和 <code class="docutils literal notranslate"><span class="pre">转移</span></code> 功能的队列。</p>
<div class="important admonition">
<p class="admonition-title">设备队列和功能域</p>
<p>每个物理设备上支持一到多个设备队列，每个设备队列支持一到多个功能域。这里很有可能多个设备队列支持相同的功能域。比如同一物理设备上的设备队列 <code class="docutils literal notranslate"><span class="pre">A</span></code> 和 <code class="docutils literal notranslate"><span class="pre">B</span></code> 都支持图形和计算功能。</p>
</div>
<section id="id14">
<h3>获取设备队列（族）信息<a class="headerlink" href="#id14" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中是通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数获取：</p>
<section id="vkgetphysicaldevicequeuefamilyproperties">
<h4>vkGetPhysicalDeviceQueueFamilyProperties<a class="headerlink" href="#vkgetphysicaldevicequeuefamilyproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pQueueFamilyPropertyCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkQueueFamilyProperties</span><span class="o">*</span><span class="w">                    </span><span class="n">pQueueFamilyProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 要获取属性的物理设备的句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyPropertyCount</span> 是用于指定或获取的设备队列族数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyProperties</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么是数量不小于 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组。</p></li>
</ul>
<p>该函数的用法与 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数是一样的。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数将会将查询到的设备队列族数量写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 所指向的内存中，所以 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是一个有效指针。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数将会将 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 数量的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数据依次写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 指向的数组中。如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 指定的数量小于支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备队列数量的话， <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 将会写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 个设备队列族信息。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<div class="note admonition">
<p class="admonition-title">队列族</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中设备队列是按照 <code class="docutils literal notranslate"><span class="pre">族</span></code> 进行管理的，前面我们知道一个物理设备上的可能会有多个设备队列支持相同的功能域，这些支持相同功能域的设备队列算作同一族。</p>
<figure class="align-default" id="id48">
<img alt="_images/vk_queue_family_struct.svg" src="_images/vk_queue_family_struct.svg" /><figcaption>
<p><span class="caption-text">如上图中。队列0、1、2三个队列属于队列族A，则这三个队列支持计算、图形和转移功能。队列3属于队列族B，则该队列支持计算和转移功能。</span><a class="headerlink" href="#id48" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
<p>设备队列族 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 定义如下：</p>
</section>
<section id="vkqueuefamilyproperties">
<h4>VkQueueFamilyProperties<a class="headerlink" href="#vkqueuefamilyproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkQueueFamilyProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkQueueFlags</span><span class="w">    </span><span class="n">queueFlags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">queueCount</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">timestampValidBits</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkExtent3D</span><span class="w">      </span><span class="n">minImageTransferGranularity</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkQueueFamilyProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFlags</span> 为队列族位域，用于描述该队列族支持的功能域。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCount</span> 该队列族中的队列数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">timestampValidBits</span> 时间戳中有效的位数，有效的位数范围为 <code class="docutils literal notranslate"><span class="pre">36</span></code> 到 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位，如果为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 说明不支持时间戳。超出有效范围的位保证为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">minImageTransferGranularity</span> 在该族队列上进行图片转移操作时支持的最小转移粒度（大小）。</p></li>
</ul>
<p>目前我们主要关心 <code class="docutils literal notranslate"><span class="pre">queueFlags</span></code> 和 <code class="docutils literal notranslate"><span class="pre">queueCount</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">queueFlags</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 类型，其定义如下：</p>
</section>
<section id="vkqueueflags">
<h4>VkQueueFlags<a class="headerlink" href="#vkqueueflags" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">VkFlags</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">VkFlags</span><span class="w"> </span><span class="n">VkQueueFlags</span><span class="p">;</span>
</pre></div>
</div>
<p>可以看到 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 其实就是一个 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的标志位。</p>
<div class="note admonition">
<p class="admonition-title">VkFlags</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有的标志位 <code class="docutils literal notranslate"><span class="pre">Vk{标志位名称}Flags</span></code> 都为 <code class="docutils literal notranslate"><span class="pre">VkFlags</span></code> 也就是 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 。每一位对应的含义都在对应的 <code class="docutils literal notranslate"><span class="pre">Vk{标志位名称}FlagBits</span></code> 枚举中定义。</p>
</div>
<div class="note admonition">
<p class="admonition-title">标志位与位域</p>
<p>所谓标志位，也就是位域。像 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 其比特位有 <code class="docutils literal notranslate"><span class="pre">32</span></code> 个，如果某一比特位为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则说明对应的位域被激活，也就是对应位域表示的事物被激活。比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的二进制：0000 0000 0000 0000 0000 0000 0000 0001</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的二进制：0000 0000 0000 0000 0000 0000 0000 0010</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">likes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">某人的喜好</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">likes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">//什么也不喜欢</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LIKE_CAT_BI</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LIKE_CAT_BIT</span><span class="p">)</span><span class="w"> </span><span class="c1">//喜欢猫</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">)</span><span class="w"> </span><span class="c1">//喜欢狗</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">))</span><span class="w"> </span><span class="c1">//既喜欢猫，也喜欢狗</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 对应位域的 <code class="docutils literal notranslate"><span class="pre">VkQueueFlagBits</span></code> 定义如下:</p>
</section>
<section id="vkqueueflagbits">
<h4>VkQueueFlagBits<a class="headerlink" href="#vkqueueflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkQueueFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_COMPUTE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_TRANSFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_SPARSE_BINDING_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">    </span><span class="n">VK_QUEUE_PROTECTED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_GRAPHICS_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">图形</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_COMPUTE_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">计算</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_TRANSFER_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">转移</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_SPARSE_BINDING_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">稀疏绑定</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_PROTECTED_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">受保护</span></code> 功能。</p></li>
</ul>
<p>获取设备队列（族）信息例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceQueueFamilyProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceQueueFamilyProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 获取相应的设备队列（族）属性了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">queue_family_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkQueueFamilyProperties</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue_familys</span><span class="p">(</span><span class="n">queue_family_count</span><span class="p">);</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span><span class="w"> </span><span class="n">queue_familys</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">uint32_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint32_max</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">queue_family_count</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">queue_familys</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">queueFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="o">::</span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="o">::</span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 寻找支持图形的队列族</span>
<span class="w">      </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">assert</span><span class="p">(</span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">uint32_max</span><span class="p">)</span><span class="w"> </span><span class="c1">//没找到支持图形的队列族</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">support_graphics_queue_family_index</p>
<p>需要获取存储对应设备队列族在 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组中的索引值，这会在之后使用到。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VK_QUEUE_GRAPHICS_BIT</p>
<p>我们一般倾向于需要支持 <code class="docutils literal notranslate"><span class="pre">VK_QUEUE_GRAPHICS_BIT</span></code> 图形功能的队列族，这是因为大部分设备队列族如果支持图形功能的话，其他的计算、转移和稀疏绑定功能也会同时支持。</p>
</div>
</section>
</section>
</section>
<section id="id15">
<h2>逻辑设备<a class="headerlink" href="#id15" title="Link to this heading">#</a></h2>
<p>在获得了物理设备句柄之后，我们需要在某个物理设备上创建逻辑设备，之后所有的操作都应用于此逻辑设备上。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中使用 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 句柄表示一个逻辑设备。</p>
<section id="id16">
<h3>创建逻辑设备<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
<p>首先需要使用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建逻辑设备。</p>
<section id="vkcreatedevice">
<h4>vkCreateDevice<a class="headerlink" href="#vkcreatedevice" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateDevice</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkDeviceCreateInfo</span><span class="o">*</span><span class="w">                   </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="o">*</span><span class="w">                                   </span><span class="n">pDevice</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 为之前使用 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 获取到的某个物理设备句柄，逻辑设备将在此物理设备上创建。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 表示逻辑设备的创建信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pDevice</span> 创建返回的逻辑设备 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 句柄。</p></li>
</ul>
<p>如果创建成功将会返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。并且同一个物理设备可以创建多个逻辑设备。</p>
<p>创建逻辑设备的 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 结构体定义如下：</p>
</section>
<section id="vkdevicecreateinfo">
<h4>VkDeviceCreateInfo<a class="headerlink" href="#vkdevicecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkDeviceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">                    </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                        </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceCreateFlags</span><span class="w">                </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">queueCreateInfoCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkDeviceQueueCreateInfo</span><span class="o">*</span><span class="w">     </span><span class="n">pQueueCreateInfos</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">enabledLayerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">                 </span><span class="n">ppEnabledLayerNames</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">enabledExtensionCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">                 </span><span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkPhysicalDeviceFeatures</span><span class="o">*</span><span class="w">    </span><span class="n">pEnabledFeatures</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 标志位，保留为将来使用。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCreateInfoCount</span> 为 <code class="docutils literal notranslate"><span class="pre">pQueueCreateInfos</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueCreateInfos</span> 指向 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 数组指针，用于逻辑设备创建设备队列。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledLayerCount</span> 为 <code class="docutils literal notranslate"><span class="pre">ppEnabledLayerNames</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledLayerNames</span> 指向字符串数组指针，用于启用设备 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 为 <code class="docutils literal notranslate"><span class="pre">ppEnabledExtensionNames</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledExtensionNames</span> 指向字符串数组指针，用于启用设备扩展。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkPhysicalDeviceFeatures</span> 设置要激活的物理设备特性。</p></li>
</ul>
<p>此时我们主要关心数量为 <code class="docutils literal notranslate"><span class="pre">queueCreateInfoCount</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pQueueCreateInfos</span></code> 数组。该数组用于在创建逻辑设备时指定创建的设备队列信息。该结构体定义如下：</p>
</section>
<section id="vkdevicequeuecreateinfo">
<h4>VkDeviceQueueCreateInfo<a class="headerlink" href="#vkdevicequeuecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkDeviceQueueCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceQueueCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueFamilyIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w">                </span><span class="n">pQueuePriorities</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceQueueCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 标志位。用于设置目标设备队列的行为。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 对应的队列族在 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数返回的 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 数组中的索引值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCount</span> 在对应的队列族中创建的设备队列数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueuePriorities</span> 设备队列优先级。指向数量为 <code class="docutils literal notranslate"><span class="pre">queueCount</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">float</span></code> 的数组，对应设置每一个设备队列的优先级。</p></li>
</ul>
<p>这里 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 成员非常重要，该成员对应着使用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 获取到的设备队列族在 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 数组中的索引值，大部分情况会去选择支持图形功能的队列族所对应的索引。</p>
<p>这样我们就可以创建逻辑设备了，例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkCreateDevice</span><span class="w"> </span><span class="n">vkCreateDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateDevice</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateDevice&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建逻辑设备了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="n">中找到的支持图形功能的队列族索引</span><span class="p">;</span>

<span class="kt">float</span><span class="w"> </span><span class="n">queue_prioritie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="n">VkDeviceQueueCreateInfo</span><span class="w"> </span><span class="n">device_queue_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">queueCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">pQueuePriorities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_prioritie</span><span class="p">;</span>

<span class="n">VkDeviceCreateInfo</span><span class="w"> </span><span class="n">device_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">queueCreateInfoCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pQueueCreateInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_queue_create_info</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">enabledLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pEnabledFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateDevice</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="device">
<h2>获取 Device 域函数<a class="headerlink" href="#device" title="Link to this heading">#</a></h2>
<p>在创建完逻辑设备 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 之后，与 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 及其产生的子对象（句柄）的所有交互函数都属于 <code class="docutils literal notranslate"><span class="pre">Device</span> <span class="pre">域函数</span></code> 。我们通过 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供的 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数获取 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
<section id="vkgetdeviceprocaddr">
<h3>vkGetDeviceProcAddr<a class="headerlink" href="#vkgetdeviceprocaddr" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">PFN_vkVoidFunction</span><span class="w"> </span><span class="nf">vkGetDeviceProcAddr</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">                                 </span><span class="n">pName</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pName</span> 要获取的逻辑设备对应的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数驱动实现。</p></li>
</ul>
<p>该函数就是用于获取不同设备驱动实现的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数接口，不同的 <code class="docutils literal notranslate"><span class="pre">device</span></code> 支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 扩展函数不尽相同，但是如果支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 特定版本的话（ <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties::apiVersion</span></code> ）则一定能够获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心标准中的函数实现。</p>
<p>如果获取 <code class="docutils literal notranslate"><span class="pre">device</span></code> 对应驱动中没有实现的函数的话，将会返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>该函数的返回值与 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 一样为 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> ，与 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 一样， <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 在获取驱动中某一有效函数后需要强制转换成对应函数。</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数指针如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetDeviceProcAddr</span><span class="w"> </span><span class="n">vkGetDeviceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetDeviceProcAddr</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetDeviceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 获取 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域的函数了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">}</span><span class="w"> </span><span class="n">vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">})</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vk{Device 域函数名}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在创建完 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 之后，由于之后所有要调用的函数最终都作用在某一具体逻辑设备上（或由该逻辑设备创建的相关对象上），所以之后所有函数都是 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
</div>
</section>
</section>
<section id="id17">
<h2>获取设备队列<a class="headerlink" href="#id17" title="Link to this heading">#</a></h2>
<p>我们在创建逻辑设备时指定了需要使用的设备队列信息， <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建过程中会为我们创建对应的设备队列，之后我们需要通过 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数获取设备队列 <code class="docutils literal notranslate"><span class="pre">VkQueue</span></code> 句柄。</p>
<section id="vkgetdevicequeue">
<h3>vkGetDeviceQueue<a class="headerlink" href="#vkgetdevicequeue" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetDeviceQueue</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">queueFamilyIndex</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">queueIndex</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkQueue</span><span class="o">*</span><span class="w">                                    </span><span class="n">pQueue</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 创建设备队列时对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 创建设备队列时对应的队列族索引。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueIndex</span> 对应着队列族中设备队列的索引。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueue</span> 将会返回 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 索引对应的队列族中，设备队列索引值为 <code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 的索引句柄。</p></li>
</ul>
<p>由于一个队列族中可能有多个设备队列，并且在创建逻辑设备时可以同时创建多个设备队列，索引此时需要用户指定 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 和 <code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 来获取对应的设备队列（句柄）。</p>
<p>在使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 获取设备队列句柄之前，需要先获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数指针：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetDeviceQueue</span><span class="w"> </span><span class="n">vkGetDeviceQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetDeviceQueue</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetDeviceQueue&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数时使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 获取，其为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
</div>
<p>之后我们就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 获取对应的设备队列句柄了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="n">中找到的支持图形功能的队列族索引</span><span class="p">;</span>

<span class="n">VkQueue</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">vkGetDeviceQueue</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于在创建 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 代码示例中只指定了一个支持图形的队列，所以这里：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 为之前获取的 <code class="docutils literal notranslate"><span class="pre">support_graphics_queue_family_index</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
</ul>
</div>
</section>
</section>
<section id="memory">
<span id="id18"></span><h2>内存<a class="headerlink" href="#memory" title="Link to this heading">#</a></h2>
<section id="id19">
<h3>内存分类<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中函数主要分为两类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数中主要在 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 能够访问的（主板上）内存中进行分配和访问。比如在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 时需要指定 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">VkAllocationCallbacks*</span> <span class="pre">pAllocator</span></code> 内存分配回调（一般回调内部使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 或 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 等进行分配）。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问的内存一般称为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存。</p>
<p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数中主要在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 能够访问的内存（显存）中进行内存分配和访问。这一部分内存称为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存。</p>
<div class="important admonition">
<p class="admonition-title">const VkAllocationCallbacks* pAllocator</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 内存分配回调分配的内存将会存储在内存条中，该部分内存属于特殊的 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存，确切的说使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 或 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 等分配的内存，在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中不属于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 管理的范畴（ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中属于 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端范畴，其本质上属于 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 范畴）。这里仅仅为了引出 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端做的简要引子。</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 的具体用法将会在之后单独的章节中进行讲解。</p>
</div>
<p>由此引出了 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的两个 <code class="docutils literal notranslate"><span class="pre">端</span></code> 分类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端</p></li>
</ul>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端一般是指 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 可以访问的那部分资源（内存），而该部分资源可能存储在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备上的内存中也可能存储在内存条上的内存中。只不过这部分资源可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问到并归为 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 管理范畴。</p>
<p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端表示 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备可访问的的专属资源（内存）。</p>
<p>这里可以看出内存条上的内存和 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上的显存都属于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 可访问的内存范畴。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中我们往往在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端将数据准备好，之后使用 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备访问该数据进行计算。然而 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端准备的数据只有 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 能够访问， <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备并不能直接访问 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中为我们提供了可被 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 访问的 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存。
也就是说这一部分内存既可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问也可以被 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端访问。一般来说，我们会先将 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的数据拷贝至可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问也可以被 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端访问的内存中，之后再将这部分数据拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存中被 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 访问使用。</p>
<div class="mermaid">
            flowchart LR

   Host[&quot;Host 端\n（使用 new 或 malloc 分配内存）&quot;]
   HostAndDevice[&quot;Host 端与 Device 都可访问的内存&quot;]
   Device[&quot;Device 端内存&quot;]

   Host--拷贝--&gt;HostAndDevice--&quot;（总线）拷贝&quot;--&gt;Device
        </div><div class="tip admonition">
<p class="admonition-title">既然数据在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端都可以访问的内存中，为什么还需要拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端中？</p>
<p>在硬件层面 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端都可以访问的内存，这类内存对于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 这种处理连续内存非常友好，而像 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 这种大量并行计算的设备来说就不尽人意了，拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端中的目的是将这一步分数据转换成设备友好的内存结构，提高内存读写性能。</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中可以在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备上直接访问 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 都可访问的内存。只不过我们经常将这部分内存数据拷贝至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 专属内存中提高性能。</p>
</div>
<p>最终可得出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的内存分类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存</p></li>
</ul>
<div class="important admonition">
<p class="admonition-title">Vulkan 内存</p>
<p>其实在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准看来，所有的内存都属于 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存，只不过有些 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问。有些 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 专属内存。</p>
</div>
</section>
<section id="id20">
<h3>获取 Vulkan 支持的内存信息<a class="headerlink" href="#id20" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 所有的内存信息都可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数获取，其定义如下：</p>
<section id="vkgetphysicaldevicememoryproperties">
<h4>vkGetPhysicalDeviceMemoryProperties<a class="headerlink" href="#vkgetphysicaldevicememoryproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceMemoryProperties</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkPhysicalDevice</span><span class="w">                           </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkPhysicalDeviceMemoryProperties</span><span class="o">*</span><span class="w">          </span><span class="n">pMemoryProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 为对应获取对应内存信息的物理设备。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemoryProperties</span> 相应的内存信息将会写入并返回。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 结构体描述如下：</p>
</section>
<section id="vkphysicaldevicememoryproperties">
<h4>VkPhysicalDeviceMemoryProperties<a class="headerlink" href="#vkphysicaldevicememoryproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_MAX_MEMORY_TYPES 32U</span>
<span class="cp">#define VK_MAX_MEMORY_HEAPS 16U</span>

<span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                         </span><span class="n">memoryTypeCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryType</span><span class="w">                                     </span><span class="n">memoryTypes</span><span class="p">[</span><span class="n">VK_MAX_MEMORY_TYPES</span><span class="p">];</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                         </span><span class="n">memoryHeapCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryHeap</span><span class="w">                                     </span><span class="n">memoryHeaps</span><span class="p">[</span><span class="n">VK_MAX_MEMORY_HEAPS</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceMemoryProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypeCount</span> 内存类型的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypes</span> 对应的内存类型信息数据。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryHeapCount</span> 内存堆的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryHeaps</span> 对应的内存堆的信息数据。</p></li>
</ul>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 结构体描述如下：</p>
</section>
<section id="vkmemorytype">
<h4>VkMemoryType<a class="headerlink" href="#vkmemorytype" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkMemoryPropertyFlags</span><span class="w">          </span><span class="n">propertyFlags</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                       </span><span class="n">heapIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">propertyFlags</span> 该类内存的属性信息，使用标志位存储相应信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">heapIndex</span> 对应的内存堆的索引，表示指向 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps[heapIndex]</span></code> 的内存堆。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlags</span></code> 对应的各个比特位的值定义于 <code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlagBits</span></code> 枚举中，定义如下：</p>
</section>
<section id="vkmemorypropertyflagbits">
<h4>VkMemoryPropertyFlagBits<a class="headerlink" href="#vkmemorypropertyflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkMemoryPropertyFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_PROTECTED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 物理设备自身的内存只有物理设备自身可访问，也就是 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端可访问到的内存只有 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端自身可访问， <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端不可访问。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端连续内存，表示对于该内存的读写可连续进行（就像 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 对于内存的修改那样）。该内存类型不需要手动进行 <code class="docutils literal notranslate"><span class="pre">刷新</span></code> 和 <code class="docutils literal notranslate"><span class="pre">失效</span></code> 操作。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端高速内存，并且自带 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span></code> 属性。这一部分内存大小相对较小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</span> 表示这部分内存为可以滞后分配内存，等要使用时再分配内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_PROTECTED_BIT</span> 表示这部分内存为受保护内存，并且只允许 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 硬件设备和受保护的队列（ <code class="docutils literal notranslate"><span class="pre">VK_QUEUE_PROTECTED_BIT</span></code> ）可以访问该内存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">刷新</span></code> 和 <code class="docutils literal notranslate"><span class="pre">失效</span></code> 操作</p>
<p>是指使用 <code class="docutils literal notranslate"><span class="pre">vkFlushMappedMemoryRanges</span></code> 进行内存刷新，使用 <code class="docutils literal notranslate"><span class="pre">vkInvalidateMappedMemoryRanges</span></code> 使内存失效。有关详细说明将会在单独的章节中进行讲解。</p>
</div>
<p>我们经常会使用到 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span></code> 、 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span></code> 属性的内存。</p>
<p>接下来我们来看一下 <code class="docutils literal notranslate"><span class="pre">VkMemoryType::heapIndex</span></code> 对应的 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 的定义：</p>
</section>
<section id="vkmemoryheap">
<h4>VkMemoryHeap<a class="headerlink" href="#vkmemoryheap" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryHeap</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w">                   </span><span class="n">size</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryHeapFlags</span><span class="w">              </span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryHeap</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 表示该内存堆的大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 表示该堆的属性标志位，各位的含义被定义在 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 中。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 与 <code class="docutils literal notranslate"><span class="pre">堆</span></code></p>
<p>一个 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 对应这一个内存 <code class="docutils literal notranslate"><span class="pre">堆</span></code> 。 <code class="docutils literal notranslate"><span class="pre">堆</span></code> 就是用于存储数据的地方，一般对应着物理存储介质。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中内存是从堆上进行分配和管理的。</p>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkDeviceSize</span></code> 定义如下：</p>
</section>
<section id="vkdevicesize">
<h4>VkDeviceSize<a class="headerlink" href="#vkdevicesize" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">VkDeviceSize</span><span class="p">;</span>
</pre></div>
</div>
<p>从定义来看 <code class="docutils literal notranslate"><span class="pre">VkDeviceSize</span></code> 就是一个正整数。</p>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlags</span></code> 对应的各个比特位的值定义于 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 枚举中，定义如下：</p>
</section>
<section id="vkmemoryheapflagbits">
<h4>VkMemoryHeapFlagBits<a class="headerlink" href="#vkmemoryheapflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkMemoryHeapFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">  </span><span class="n">VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span> 表示该内存堆为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 专属内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</span> 由于逻辑设备可以包含多个物理设备，此标志位表示该堆对应多个物理设备上的内存堆，对该堆的操作将会在每个物理设备的内存堆上进行相同的操作。</p></li>
</ul>
<p>常用的为 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span></code> 标志位。</p>
</section>
<section id="id21">
<h4>VkPhysicalDeviceMemoryProperties 结构图<a class="headerlink" href="#id21" title="Link to this heading">#</a></h4>
<p>为了更清晰的理解 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> ，在此给出一张 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 结构参考图：</p>
<figure class="align-default" id="id49">
<img alt="_images/VkPhysicalDeviceMemoryProperties_struct.svg" src="_images/VkPhysicalDeviceMemoryProperties_struct.svg" /><figcaption>
<p><span class="caption-text">如图所示为一种可能的结构。第一种内存类型对应着第三个内存堆，第二种内存类型对应着第一个内存堆，第三种内存类型对应着第二个内存堆。</span><a class="headerlink" href="#id49" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>接下来就能够通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 获取内存信息了，和之前很多函数一样，首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceMemoryProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceMemoryProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以通过调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 获得内存相关信息了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>

<span class="n">VkPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="n">vkGetPhysicalDeviceMemoryProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_memory_properties</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryTypeCount</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkMemoryType</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryTypes</span><span class="p">[</span><span class="n">memory_type_index</span><span class="p">];</span>

<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt DEVICE_LOCAL&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt HOST_VISIBLE&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt HOST_COHERENT&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">heap_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_type</span><span class="p">.</span><span class="n">heapIndex</span><span class="p">;</span>

<span class="w">   </span><span class="n">VkMemoryHeap</span><span class="w"> </span><span class="n">memory_heap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryHeaps</span><span class="p">[</span><span class="n">heap_index</span><span class="p">];</span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;heap &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">heap_index</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">memory_heap</span><span class="p">.</span><span class="n">size</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; GB&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_heap</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s"> DEVICE_LOCAL&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id22">
<h3>内存管理<a class="headerlink" href="#id22" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 中分配内存使用 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 、 <code class="docutils literal notranslate"><span class="pre">new</span></code> ，回收内存使用 <code class="docutils literal notranslate"><span class="pre">free</span></code> 、 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 。而在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中分配内存使用 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 函数，回收内存使用 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 函数。</p>
<div class="note admonition">
<p class="admonition-title">const VkAllocationCallbacks* pAllocator</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 的内存回调在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中为特殊的内存管理，其本质应该算作 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 的内存管理。将会在单独的章节进行讲解。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VkAllocationCallbacks 与 vk[Allocate/Free]Memory</p>
<p><code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 为 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 的内存管理范畴。 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 和 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 将会在 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps</span></code> 中的某一内存堆上进行内存管理（分配和回收）。</p>
</div>
<section id="id23">
<h4>分配内存<a class="headerlink" href="#id23" title="Link to this heading">#</a></h4>
<p>在某一个堆上进行内存分配，调用 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 函数，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkAllocateMemory</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkDevice</span><span class="w">                          </span><span class="n">device</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkMemoryAllocateInfo</span><span class="o">*</span><span class="w">       </span><span class="n">pAllocateInfo</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">      </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkDeviceMemory</span><span class="o">*</span><span class="w">                   </span><span class="n">pMemory</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。内存将会在该逻辑设备上进行分配。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocateInfo</span> 为内存分配的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemory</span> 为分配完的内存句柄。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo</span></code> 定义如下：</p>
<section id="vkmemoryallocateinfo">
<span id="id24"></span><h5>VkMemoryAllocateInfo<a class="headerlink" href="#vkmemoryallocateinfo" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryAllocateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkStructureType</span><span class="w">                         </span><span class="n">sType</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                             </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w">                            </span><span class="n">allocationSize</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                </span><span class="n">memoryTypeIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryAllocateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">allocationSize</span> 为要分配的内存大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypeIndex</span> 为在 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes</span></code> 数组对应的 <code class="docutils literal notranslate"><span class="pre">memoryTypeIndex</span></code> 索引处的堆上分配内存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">注意</p>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo::memoryTypeIndex</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes</span></code> 内存类型数组所对应的索引值，而 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">不是</span> <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps</span></code> 内存堆数组所对应的索引值。</p>
</div>
<p>这样我们就可以在支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备上分配内存了。在正式分配内存前，首先获取 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 函数的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkAllocateMemory</span><span class="w"> </span><span class="n">vkAllocateMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkAllocateMemory</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkAllocateMemory&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>现在 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[0]</span></code> 对应内存类型的堆上分配 <code class="docutils literal notranslate"><span class="pre">1KB</span></code> 内存（假如，对应的内存堆大小足够大）。示例代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">VkMemoryAllocateInfo</span><span class="w"> </span><span class="n">memory_allocate_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span><span class="p">;</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">allocationSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="c1">//1KB</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">memoryTypeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//在 VkPhysicalDeviceMemoryProperties::memoryTypes[0] 对应内存类型的堆上分配</span>

<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span><span class="w"> </span><span class="c1">// 分配的目标内存句柄</span>
<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkAllocateMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_allocate_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_memory</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
<section id="id25">
<h4>回收内存<a class="headerlink" href="#id25" title="Link to this heading">#</a></h4>
<p>内存成功分配完之后，可以通过 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 函数进行回收。其定义如下：</p>
<section id="vkfreememory">
<h5>vkFreeMemory<a class="headerlink" href="#vkfreememory" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkFreeMemory</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkDevice</span><span class="w">                             </span><span class="n">device</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkDeviceMemory</span><span class="w">                       </span><span class="n">memory</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">         </span><span class="n">pAllocator</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memory</span> 要回收的内存句柄。需要为 <code class="docutils literal notranslate"><span class="pre">device</span></code> 上分配的内存句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
</ul>
<p>这样我们就可以回收内存了。在正式回收内存前，首先获取 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 函数的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkFreeMemory</span><span class="w"> </span><span class="n">vkFreeMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkFreeMemory</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkFreeMemory&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以进行内存回收了，示例代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功分配的内存句柄</span><span class="p">;</span>

<span class="n">vkFreeMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">device_memory</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="id26">
<h2>资源<a class="headerlink" href="#id26" title="Link to this heading">#</a></h2>
<p>分配内存的目的是存储数据并用于计算，之后储存获得的结果。但在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中，并不能直接对内存进行操作，内存只能绑定到具体 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 上才能够使用。这是由于 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的并行性，在并行处理多块特定结构的数据时能够得到更优效率，而 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 非常善于处理连续内存。为了能够使得用户分配的内存在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上尽可能的高速处理， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为用户提供了 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 来为用户屏蔽掉复杂的 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 内存结构。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中为我们提供了 <code class="docutils literal notranslate"><span class="pre">2</span></code> 种资源：</p>
<ol class="arabic simple">
<li><p>缓存（ <code class="docutils literal notranslate"><span class="pre">Buffer</span></code> ）</p></li>
<li><p>图片（ <code class="docutils literal notranslate"><span class="pre">Image</span></code> ）</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">缓存</span></code> 资源和 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 资源都需要绑定一块特定内存才能够使用。对于 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 可以简单理解为其代表一块连续的内存（虽然在实际存储中内部的结构可能是非常复杂的），其内存可以存储任何数据。对于 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 可以简单理解为一个二维或三维的数组（也可以是一维的，但用的较少），其内部可以存储特定格式的数据（ <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 内部数据对格式没有要求，但 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 有要求，其目的是高速并行）。</p>
<p>所以创建完内存后，下一步就是创建要绑定的资源。</p>
<section id="id27">
<h3>缓存<a class="headerlink" href="#id27" title="Link to this heading">#</a></h3>
<p>现在我们知道 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 代表一段连续的内存，其内部拥有自己的优化格式。不同用途的缓存，其内部的格式不尽相同，具体创建何种用途的缓存与开发需求有关，并在创建缓存时通过 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 指定相关信息。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中通过 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 函数创建缓存。</p>
<section id="vkcreatebuffer">
<h4>vkCreateBuffer<a class="headerlink" href="#vkcreatebuffer" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateBuffer</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkBufferCreateInfo</span><span class="o">*</span><span class="w">                   </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBuffer</span><span class="o">*</span><span class="w">                                   </span><span class="n">pBuffer</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 创建缓存的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pBuffer</span> 创建的缓存结果。</p></li>
</ul>
<p>其中最重要的就是配置 <code class="docutils literal notranslate"><span class="pre">pCreateInfo</span></code> 信息。 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 定义如下：</p>
</section>
<section id="vkbuffercreateinfo">
<h4>VkBufferCreateInfo<a class="headerlink" href="#vkbuffercreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkBufferCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">        </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">            </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkBufferCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">           </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkBufferUsageFlags</span><span class="w">     </span><span class="n">usage</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkSharingMode</span><span class="w">          </span><span class="n">sharingMode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">               </span><span class="n">queueFamilyIndexCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">        </span><span class="n">pQueueFamilyIndices</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkBufferCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 缓存额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 创建的缓存大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">usage</span> 缓存的用途。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sharingMode</span> 共享模式。用于配置缓存是否可在设备队列间进行共享。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndexCount</span> 对应 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyIndices</span></code> 的元素数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyIndices</span> 对应类型为 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的数组。用于配置需要互相共享访问该缓存的那些队列族索引。如果 <code class="docutils literal notranslate"><span class="pre">sharingMode</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">VK_SHARING_MODE_CONCURRENT</span></code> 的话，该项将被忽略。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyIndices</span></code> 中的索引值对应于 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数中获取的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组索引。</p>
<p>其中最重要的就是对于 <code class="docutils literal notranslate"><span class="pre">usage</span></code> 的配置。 其为我们提供了缓存的各种用途。其定义如下：</p>
</section>
<section id="vkbufferusageflags">
<h4>VkBufferUsageFlags<a class="headerlink" href="#vkbufferusageflags" title="Link to this heading">#</a></h4>
<p>其中最常用的缓存用途如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkBufferUsageFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000080</span><span class="p">,</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span> 将该缓存作为数据传输的源。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span> 将该缓存作为数据传输的目标。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</span> 将该缓存作为统一缓存（用于向着色器中传递数据）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span> 将该缓存作为存储缓存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</span> 将该缓存作为索引缓存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span> 将该缓存作为顶点缓存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">其他 VK_BUFFER_USAGE_*_BUFFER_BIT</p>
<p>还有很多其他的缓存用途枚举，比如 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</span></code> 用于存储 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 硬件实时光追标准中的 <code class="docutils literal notranslate"><span class="pre">加速结构</span></code> 数据。其他缓存用途将在专门的章节进行讲解。</p>
</div>
<p>而 <code class="docutils literal notranslate"><span class="pre">VkSharingMode</span></code> 的类型枚举就比较简单：</p>
</section>
<section id="vksharingmode">
<h4>VkSharingMode<a class="headerlink" href="#vksharingmode" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkSharingMode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SHARING_MODE_CONCURRENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkSharingMode</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SHARING_MODE_EXCLUSIVE</span> 对于该缓存的访问一次只能在单独的一个队列族上进行。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SHARING_MODE_CONCURRENT</span> 对于该缓存的访问一次可以在多个队列族上进行。</p></li>
</ul>
<p>现在来尝试创建一个存有一个三角形的三个顶点信息的顶点缓存，并使用 <code class="docutils literal notranslate"><span class="pre">VK_SHARING_MODE_EXCLUSIVE</span></code> 模式。在创建前需要获取到 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 的函数实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkCreateBuffer</span><span class="w"> </span><span class="n">vkCreateBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateBuffer</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateBuffer&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 进行缓存创建了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备</span><span class="p">;</span>

<span class="c1">// 顶点位置</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Position</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 顶点颜色</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Color</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 位置和颜色</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PositionAndColor</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">Position</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">   </span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 组建一个三角形</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PositionAndColor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position_and_colors</span><span class="p">;</span>
<span class="n">position_and_colors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">{{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">}});</span>
<span class="n">position_and_colors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">{{</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">}});</span>
<span class="n">position_and_colors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">}});</span>

<span class="n">VkBufferCreateInfo</span><span class="w"> </span><span class="n">buffer_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">position_and_colors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">sharingMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkSharingMode</span><span class="o">::</span><span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkBuffer</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateBuffer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</p>
<p>在如上的代码示例中 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo::usage</span></code> 设置为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer_create_info</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span> 表示该缓存将会作为数据传输的目标，用于之后的数据拷贝（具体如何将数据拷贝进该缓存将在之后的章节进行讲解）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span> 表示该缓存将会作为顶点缓存进行内存优化。</p></li>
</ul>
</div>
</section>
</section>
<section id="image">
<span id="id28"></span><h3>图片<a class="headerlink" href="#image" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">图片</span></code> 为一维、二维或三维块内存结构的资源。每个内存块都有相同且特定的格式。与缓存不同的是，图片的内存块格式是强制要求明确指定的，与缓存相同的是图片创建时也需要指明其用途，当然这是为了内存的内部优化。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中图片资源使用 <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 句柄表示。</p>
<p>图片资源通过 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 函数创建。其定义如下：</p>
<section id="vkcreateimage">
<h4>vkCreateImage<a class="headerlink" href="#vkcreateimage" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateImage</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkImageCreateInfo</span><span class="o">*</span><span class="w">                    </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkImage</span><span class="o">*</span><span class="w">                                    </span><span class="n">pImage</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 创建图片的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pImage</span> 创建的图片结果。</p></li>
</ul>
<p>与创建缓存资源类似，我们来看一下 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span></code> 的配置信息定义：</p>
</section>
<section id="vkimagecreateinfo">
<h4>VkImageCreateInfo<a class="headerlink" href="#vkimagecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkImageCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">          </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">              </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageCreateFlags</span><span class="w">       </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageType</span><span class="w">              </span><span class="n">imageType</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkFormat</span><span class="w">                 </span><span class="n">format</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkExtent3D</span><span class="w">               </span><span class="n">extent</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">mipLevels</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">arrayLayers</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkSampleCountFlagBits</span><span class="w">    </span><span class="n">samples</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageTiling</span><span class="w">            </span><span class="n">tiling</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageUsageFlags</span><span class="w">        </span><span class="n">usage</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkSharingMode</span><span class="w">            </span><span class="n">sharingMode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">queueFamilyIndexCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">          </span><span class="n">pQueueFamilyIndices</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageLayout</span><span class="w">            </span><span class="n">initialLayout</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 图片额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">imageType</span> 图片的类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">format</span> 图片格式。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">extent</span> 图片大小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">mipLevels</span> 多级渐远纹理级别。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">arrayLayers</span> 层级数量。<span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 大于 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">samples</span> 采样点数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">tiling</span> 瓦片排布。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">usage</span> 图片的用途。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sharingMode</span> 共享模式。用于配置缓存是否可在设备队列间进行共享。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndexCount</span> 对应 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyIndices</span></code> 的元素数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyIndices</span> 对应类型为 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的数组。用于配置需要互相共享访问该缓存的那些队列族索引。如果 <code class="docutils literal notranslate"><span class="pre">sharingMode</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">VK_SHARING_MODE_CONCURRENT</span></code> 的话，该项将被忽略。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">initialLayout</span> 初始化布局</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">imageType</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkImageType</span></code> 类型定义如下：</p>
</section>
<section id="vkimagetype">
<h4>VkImageType<a class="headerlink" href="#vkimagetype" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_IMAGE_TYPE_1D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_TYPE_2D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_TYPE_3D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TYPE_1D</span> 表示一维图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TYPE_2D</span> 表示二维图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TYPE_3D</span> 表示三维图片。</p></li>
</ul>
</section>
<section id="vkformat">
<h4>VkFormat<a class="headerlink" href="#vkformat" title="Link to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">VkFormat</span></code> 即代表着每个像素的数据格式。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中声明了大量的格式枚举，这里我们挑几个经典的进行讲解。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkFormat</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_FORMAT_B8G8R8A8_UNORM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">44</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkFormat</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_FORMAT_B8G8R8A8_UNORM</span> 表示有 <code class="docutils literal notranslate"><span class="pre">BGRA</span></code> 蓝、绿、红和透明四个分量，每个分量占 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特。 <code class="docutils literal notranslate"><span class="pre">UNORM</span></code> 表示无符号归一化（ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">normalized</span></code> ），也就是颜色值的有限范围为 <span class="math notranslate nohighlight">\([0,1]\)</span> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_FORMAT_B8G8R8A8_SRGB</span> 表示有 <code class="docutils literal notranslate"><span class="pre">BGRA</span></code> 蓝、绿、红和透明四个分量，每个分量占 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特。 <code class="docutils literal notranslate"><span class="pre">SRGB</span></code> 表示使用 <code class="docutils literal notranslate"><span class="pre">sRGB</span></code> 标准红绿蓝协议（ <code class="docutils literal notranslate"><span class="pre">standard</span> <span class="pre">Red</span> <span class="pre">Green</span> <span class="pre">Blue</span></code> ） 。</p></li>
</ul>
<p>还有其他各种各样的格式，而最常用的也就是 <code class="docutils literal notranslate"><span class="pre">RGBA</span></code> 这样的红绿蓝和透明四个分量的组合格式。更多格式将会在单独章节进行讲解。</p>
<p>其中 <code class="docutils literal notranslate"><span class="pre">extent</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkExtent3D</span></code> 类型定义如下：</p>
</section>
<section id="vkextent3d">
<h4>VkExtent3D<a class="headerlink" href="#vkextent3d" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkExtent3D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">depth</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkExtent3D</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">width</span> 表示宽。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">height</span> 表示高。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">depth</span> 表示深度。</p></li>
</ul>
<p>图片的 <code class="docutils literal notranslate"><span class="pre">extent</span></code> 大小和 <code class="docutils literal notranslate"><span class="pre">arrayLayers</span></code> 层级与其 <code class="docutils literal notranslate"><span class="pre">imageType</span></code> 图片类型有关：</p>
<ul class="simple">
<li><p>当图片为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TYPE_1D</span></code> 时 <code class="docutils literal notranslate"><span class="pre">extent.depth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">extent.height</span></code> 两者皆 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
<li><p>当图片为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TYPE_2D</span></code> 时 <code class="docutils literal notranslate"><span class="pre">extent.depth</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
<li><p>当图片为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TYPE_3D</span></code> 时 <code class="docutils literal notranslate"><span class="pre">arrayLayers</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkSampleCountFlagBits</span></code> 其定义如下：</p>
</section>
<section id="vksamplecountflagbits">
<h4>VkSampleCountFlagBits<a class="headerlink" href="#vksamplecountflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkSampleCountFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_1_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_2_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_4_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_8_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_16_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_32_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_64_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkSampleCountFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_1_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">1</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_2_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">2</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_4_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">4</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_8_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">8</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_16_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">16</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_32_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">32</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_64_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">64</span></code> 个采样点。</p></li>
</ul>
<p>该 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::samples</span></code> 是用于配置图片中的每一个像素由多少个子像素构成，这些子像素会在多采样阶段合并作为整个像素的结果。这在抗锯齿方面非常有用。</p>
<p><code class="docutils literal notranslate"><span class="pre">VkImageTiling</span></code> 其定义如下：</p>
</section>
<section id="vkimagetiling">
<h4>VkImageTiling<a class="headerlink" href="#vkimagetiling" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageTiling</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_IMAGE_TILING_OPTIMAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_IMAGE_TILING_LINEAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageTiling</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TILING_OPTIMAL</span> 图片的瓦片按照 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 本地优化方式排布。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TILING_LINEAR</span> 图片的瓦片按照线性方式排布。</p></li>
</ul>
<p>资源在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端和在 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端，其内部的内存结构是不一样的，这个我们反复强调过。 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 为了得到更高的性能将图片的多个像素合成一个瓦片并使用内部的一种高效结构，这也就是 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TILING_OPTIMAL</span></code> 的目的，这种结构在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端是不能被识别的，一般处于 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 擅长处理线性连续的资源数据，
所以想要在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端对 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端的资源进行读写，需要现将 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端的资源转成 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端能够识别的排布，这也就是 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TILING_LINEAR</span></code> 的目的。</p>
</section>
<section id="vkimageusageflags">
<h4>VkImageUsageFlags<a class="headerlink" href="#vkimageusageflags" title="Link to this heading">#</a></h4>
<p>与缓存类似，为了更高的性能，您需要指定图片的用途， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中图片的用途如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageUsageFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_TRANSFER_SRC_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_SAMPLED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_STORAGE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000080</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageUsageFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_TRANSFER_SRC_BIT</span> 将该图片作为数据传输的源。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span> 将该图片作为数据传输的目标。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_SAMPLED_BIT</span> 将该图片作为可采样图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_STORAGE_BIT</span> 将该图片作为可存储图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span> 将该图片作为颜色附件。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span> 将该图片作为深度-模板附件。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span> 将该图片作为暂存附件。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</span> 将该图片作为输入附件。</p></li>
</ul>
<p>在这里我们仅关注 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_SAMPLED_BIT</span></code> 。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code> 在渲染时，需要告诉 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 渲染到哪张图片上，此时作为渲染目标的图片需要使用 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code> 创建。其他的用途将会在单独章节中进行讲解。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_SAMPLED_BIT</span></code> 用于表示该图片将用于渲染时纹理采样。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">VK_IMAGE_USAGE_TRANSFER_SRC_BIT 和 VK_IMAGE_USAGE_TRANSFER_DST_BIT</p>
<p>这两种用途与缓存的 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span></code> 相似。都是用资源间数据传输的。</p>
</div>
</section>
<section id="vkimagelayout">
<h4>VkImageLayout<a class="headerlink" href="#vkimagelayout" title="Link to this heading">#</a></h4>
<p>为了进一步优化图片， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中需要对图片进行布局设置，特定布局下的图片在特定用途下将会有更加优良的性能表现。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中同样提供的大量的图片布局枚举供我们使用，在这里也挑几个经典的进行讲解。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageLayout</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_UNDEFINED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_GENERAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_PREINITIALIZED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageLayout</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_UNDEFINED</span> 表示未定义布局。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_GENERAL</span> 表示通用布局。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span> 表示颜色附件布局。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_PREINITIALIZED</span> 表示内存中已经存有特定布局的数据将用于图片。也就是图片已被提前初始化完成。该布局的目的是将 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的数据写入图片中，并且目前该布局只能用于线性图片中（ <code class="docutils literal notranslate"><span class="pre">VkImageTiling::VK_IMAGE_TILING_LINEAR</span></code> ）。</p></li>
</ul>
<p>在通过 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span></code> 创建图片时 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 要求 <code class="docutils literal notranslate"><span class="pre">initialLayout</span></code> 的布局 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 或 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_PREINITIALIZED</span></code> 。但大多数情况下图片都没有预制的数据，所以在创建图片时 <code class="docutils literal notranslate"><span class="pre">initialLayout</span></code> 的布局一般都是 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 。</p>
<p>当图片内的布局为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 时表示内部的数据布局是未定义的，这时 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 并不知道如何解析该图片，为了能让 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 识别出该资源，需要将布局从 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 转换至其他布局。是的，布局可以转换。不同阶段转换成对应阶段的特定布局会得到更加高效的性能表现（比如在渲染结果输出阶段将图片的布局转换成 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span></code> ）。同样 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 也考虑到布局转来转去过于繁琐，所以
提供了 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_GENERAL</span></code> 通用布局，该布局是通用的，在任何阶段都可以使用，代价就是稍稍降低了一点点性能，但好处是不再需要管理图片的布局，而 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_GENERAL</span></code> 布局也作为很多引擎的首选布局（因为真的很方便）。</p>
</section>
<section id="id29">
<h4>VkImageCreateInfo 其他参数和综述<a class="headerlink" href="#id29" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::mipLevels</span> 用于图片的多级渐远级别。对于多级渐远将会在专门的章节中讲解。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::arrayLayers</span> 用于配置图片的层级。一般在创建 <code class="docutils literal notranslate"><span class="pre">CubeMap</span></code> （天空盒）时与 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::flags</span></code> 配合使用。这一部分将会在专门的章节中讲解。</p></li>
</ul>
<p>而对于如下参数则与 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 中的概念相同。</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::sharingMode</span></p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::queueFamilyIndexCount</span></p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::pQueueFamilyIndices</span></p></li>
</ul>
<p>这些参数都是用于配置该资源在哪些队列中进行数据共享。</p>
<section id="id30">
<h5>综述<a class="headerlink" href="#id30" title="Link to this heading">#</a></h5>
<p>对于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 图片资源有如下特点：</p>
<ul class="simple">
<li><p>所有图片都是以三维图片进行表示的（一维、二维图片只是相应的扩展维度度量缩减到了 <code class="docutils literal notranslate"><span class="pre">1</span></code> ）。并使用 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::extent</span></code> 配置每个维度的像素数量。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::format</span></code> 用于表示图片的单个像素的数据格式。</p></li>
<li><p>每个像素中都有逻辑子像素，类似于将一个像素按照九宫格的方式进行分割，具体分成几宫格是使用 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::samples</span></code> 进行配置的。如果配置为 <code class="docutils literal notranslate"><span class="pre">VkImageUsageFlagBits::VK_SAMPLE_COUNT_1_BIT</span></code> 则表示当前像素即为最终像素。其它的配置都会将一个像素分割成多个小像素，并在渲染的多采样阶段将多个小像素的值合并，并做为最终像素值保存。</p></li>
<li><p>图片在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端和 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端的排布不同。具体何种排布使用 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::tiling</span></code> 进行配置。</p></li>
<li><p>图片具有布局属性。通过特定阶段将图片转换成特定布局将会提升性能表现。</p></li>
</ul>
<p>现在来尝试创建一个图片，该图片具有如下特点：</p>
<ul class="simple">
<li><p>该图片为二维图片。<code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::imageType</span> <span class="pre">=</span> <span class="pre">VkImageType::VK_IMAGE_TYPE_2D</span></code></p></li>
<li><p>每个像素都有 <code class="docutils literal notranslate"><span class="pre">RGBA</span></code> 四个分量，每个分量 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特，并使用 <code class="docutils literal notranslate"><span class="pre">sRGB</span></code> 标准。<code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::format</span> <span class="pre">=</span> <span class="pre">VkFormat::VK_FORMAT_B8G8R8A8_SRGB</span></code></p></li>
<li><p>图片大小为 <span class="math notranslate nohighlight">\(1920 \times 1080\)</span> 。<code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::extent</span> <span class="pre">=</span> <span class="pre">VkExtent3D{width</span> <span class="pre">=</span> <span class="pre">1920,</span> <span class="pre">height</span> <span class="pre">=</span> <span class="pre">1080,</span> <span class="pre">depth</span> <span class="pre">=</span> <span class="pre">1}</span></code></p></li>
<li><p>该图片将在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 中作为颜色附件使用。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::usage</span> <span class="pre">=</span> <span class="pre">VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code></p></li>
<li><p>没有多级渐远。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::mipLevels</span> <span class="pre">=</span> <span class="pre">1</span></code></p></li>
<li><p>没有子像素。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::samples</span> <span class="pre">=</span> <span class="pre">VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT</span></code></p></li>
<li><p>仅在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 中访问。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::tiling</span> <span class="pre">=</span> <span class="pre">VkImageTiling::VK_IMAGE_TILING_OPTIMAL</span></code></p></li>
</ul>
<p>在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 前首先获取该函数的驱动实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkCreateImage</span><span class="w"> </span><span class="n">vkCreateImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateImage</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateImage&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 创建图片了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备</span><span class="p">;</span>

<span class="n">VkExtent3D</span><span class="w"> </span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">extent</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1920</span><span class="p">;</span>
<span class="n">extent</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1080</span><span class="p">;</span>
<span class="n">extent</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="n">VkImageCreateInfo</span><span class="w">  </span><span class="n">image_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">imageType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageType</span><span class="o">::</span><span class="n">VK_IMAGE_TYPE_2D</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkFormat</span><span class="o">::</span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extent</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">mipLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">arrayLayers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkSampleCountFlagBits</span><span class="o">::</span><span class="n">VK_SAMPLE_COUNT_1_BIT</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">tiling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageTiling</span><span class="o">::</span><span class="n">VK_IMAGE_TILING_OPTIMAL</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageUsageFlagBits</span><span class="o">::</span><span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">sharingMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkSharingMode</span><span class="o">::</span><span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">initialLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageLayout</span><span class="o">::</span><span class="n">VK_IMAGE_LAYOUT_UNDEFINED</span><span class="w"> </span><span class="p">;</span>

<span class="n">VkImage</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateImage</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">image_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">image</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id31">
<h3>图片视图<a class="headerlink" href="#id31" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中仅仅创建完 <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 是不够的，还需要告诉 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 如何“解析”该图片。 <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 仅仅用于表示具有特定数据格式的数据块，并没有规定图片中数据的意义，此时就需要创建 <code class="docutils literal notranslate"><span class="pre">VkImageView</span></code> （图片视图）来声明图片数据的解析方式，这样 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 就知道如何使用该图片了。</p>
<p>比如，创建了一个图片（ <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> ），其内部拥有一个 <span class="math notranslate nohighlight">\(512(width) \times 512(height) \times 6(depth)\)</span> 的三维图片数据，也就是说该图片是由 <code class="docutils literal notranslate"><span class="pre">6</span></code> 张 <code class="docutils literal notranslate"><span class="pre">512</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">512</span></code> 的二维图片组成三维图片。现在对于该图片可以有两种解释：</p>
<ol class="arabic simple">
<li><p>解析为一个三维图片</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/3d_image.png"><img alt="_images/3d_image.png" src="_images/3d_image.png" style="width: 327.5px; height: 295.5px;" /></a>
</figure>
<ol class="arabic simple" start="2">
<li><p>解析为由 <code class="docutils literal notranslate"><span class="pre">6</span></code> 张图片拼成的一个正方体盒子</p></li>
</ol>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/3d_image_cubemap.png"><img alt="_images/3d_image_cubemap.png" src="_images/3d_image_cubemap.png" style="width: 548px; height: 250.5px;" /></a>
</figure>
<p>为了指定如何解析图片数据， <code class="docutils literal notranslate"><span class="pre">VkImageView</span></code> 应运而生。</p>
<section id="vkcreateimageview">
<h4>vkCreateImageView<a class="headerlink" href="#vkcreateimageview" title="Link to this heading">#</a></h4>
<p>可以通过调用 <code class="docutils literal notranslate"><span class="pre">vkCreateImageView</span></code> 创建 <code class="docutils literal notranslate"><span class="pre">VkImageView</span></code> ，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateImageView</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkImageViewCreateInfo</span><span class="o">*</span><span class="w">                </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkImageView</span><span class="o">*</span><span class="w">                                </span><span class="n">pView</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 对应图片视图的创建信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pView</span> 创建的图片视图结果。</p></li>
</ul>
</section>
<section id="vkimageviewcreateinfo">
<h4>VkImageViewCreateInfo<a class="headerlink" href="#vkimageviewcreateinfo" title="Link to this heading">#</a></h4>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkImageViewCreateInfo</span></code> 定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkImageViewCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">            </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageViewCreateFlags</span><span class="w">     </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImage</span><span class="w">                    </span><span class="n">image</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageViewType</span><span class="w">            </span><span class="n">viewType</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkFormat</span><span class="w">                   </span><span class="n">format</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkComponentMapping</span><span class="w">         </span><span class="n">components</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageSubresourceRange</span><span class="w">    </span><span class="n">subresourceRange</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageViewCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 图片视图的额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">image</span> 视图的目标图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">viewType</span> 视图类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">format</span> 视图用于解析 <code class="docutils literal notranslate"><span class="pre">image</span></code> 的像素数据格式。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">components</span> 用于规定每个像素中的数据的映射关系。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">subresourceRange</span> 用于规定该视图对于 <code class="docutils literal notranslate"><span class="pre">image</span></code> 的解析范围。</p></li>
</ul>
</section>
<section id="vkimageviewtype">
<h4>VkImageViewType<a class="headerlink" href="#vkimageviewtype" title="Link to this heading">#</a></h4>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkImageViewType</span></code> 的定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageViewType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_1D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_2D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_3D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_CUBE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_1D_ARRAY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_2D_ARRAY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageViewType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_1D</span> 一维视图。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_2D</span> 二维视图。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_3D</span> 三维视图。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_CUBE</span> 立方体视图。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_1D_ARRAY</span> 一维数组视图。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_2D_ARRAY</span> 二维数组视图。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</span> 立方体数组视图。</p></li>
</ul>
<p>这里图片视图类型与 <code class="docutils literal notranslate"><span class="pre">VkImageType</span></code> 有相对应，也有一些 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_VIEW_TYPE_CUBE</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_VIEW_TYPE_*_ARRAY</span></code> 这样的解析类型。</p>
<p>对于之前的举例中 <span class="math notranslate nohighlight">\(512(width) \times 512(height) \times 6(depth)\)</span> 的三维图片数据的两种解析方式，根据 <code class="docutils literal notranslate"><span class="pre">VkImageViewType</span></code> 标准，其对应如下：</p>
<ol class="arabic simple">
<li><p>解析为一个三维图片。其对应 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_VIEW_TYPE_3D</span></code></p></li>
<li><p>解析为由 <code class="docutils literal notranslate"><span class="pre">6</span></code> 张图片拼成的一个正方体盒子。其对应 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_VIEW_TYPE_CUBE</span></code></p></li>
</ol>
<p>由此可见，就算 <code class="docutils literal notranslate"><span class="pre">VkImageViewCreateInfo::image</span></code> 相同，不同的图片视图配置，对于相同的图片也会有不同的解析结果。</p>
<p>其他视图类型在这里就不一一展开讲解了，这将会在详细章节中进行讲解。但这里提一嘴 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_VIEW_TYPE_2D</span></code> ，该视图类型比较常用，常见于将图片解析成一个二维图片。</p>
</section>
<section id="vkcomponentmapping">
<h4>VkComponentMapping<a class="headerlink" href="#vkcomponentmapping" title="Link to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">VkComponentMapping</span></code> 用于规定各个像素的分量映射，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkComponentMapping</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkComponentSwizzle</span><span class="w">    </span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkComponentSwizzle</span><span class="w">    </span><span class="n">g</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkComponentSwizzle</span><span class="w">    </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkComponentSwizzle</span><span class="w">    </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkComponentMapping</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">r</span> 红色分量映射。控制该视图对于该分量的解析结果。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">g</span> 绿色分量映射。控制该视图对于该分量的解析结果。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">b</span> 蓝色分量映射。控制该视图对于该分量的解析结果。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">a</span> 不透明分量映射。控制该视图对于该分量的解析结果。</p></li>
</ul>
<section id="vkcomponentswizzle">
<h5>VkComponentSwizzle<a class="headerlink" href="#vkcomponentswizzle" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Provided by VK_VERSION_1_0</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkComponentSwizzle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_IDENTITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_ONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMPONENT_SWIZZLE_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkComponentSwizzle</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_IDENTITY</span> 表示个颜色分量原封不动的映射。是什么颜色分量就映射至什么分量。红色分量映射到红色、绿色分量映射到绿色和蓝色分量映射到蓝色。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_ZERO</span> 映射成 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_ONE</span> 映射成 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_R</span> 映射成红颜色分量值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_G</span> 映射成绿颜色分量值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_B</span> 映射成蓝颜色分量值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMPONENT_SWIZZLE_A</span> 映射成透明分量值。</p></li>
</ul>
<p>不出意外，基本上都是使用 <code class="docutils literal notranslate"><span class="pre">VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY</span></code> ，即不对映射进行任何篡改。除非您有特殊需求。</p>
<p>接下来讲解一下 <code class="docutils literal notranslate"><span class="pre">VkImageViewCreateInfo::subresourceRange</span></code> ，其定义如下</p>
</section>
</section>
<section id="vkimagesubresourcerange">
<h4>VkImageSubresourceRange<a class="headerlink" href="#vkimagesubresourcerange" title="Link to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">VkImageSubresourceRange</span></code> 用于限定该视图对于 <code class="docutils literal notranslate"><span class="pre">image</span></code> 的解析范围。其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkImageSubresourceRange</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkImageAspectFlags</span><span class="w">    </span><span class="n">aspectMask</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">              </span><span class="n">baseMipLevel</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">              </span><span class="n">levelCount</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">              </span><span class="n">baseArrayLayer</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">              </span><span class="n">layerCount</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageSubresourceRange</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">aspectMask</span> 指定图片按照哪一方面进行解析。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">baseMipLevel</span> 多级渐远纹理的起始级别。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">levelCount</span> 多级渐远纹理的级别数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">baseArrayLayer</span> 图片的起始层级。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">layerCount</span> 图片的层级数。</p></li>
</ul>
<section id="vkimageaspectflags">
<h5>VkImageAspectFlags<a class="headerlink" href="#vkimageaspectflags" title="Link to this heading">#</a></h5>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkImageAspectFlags</span></code> 定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Provided by VK_VERSION_1_0</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageAspectFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_IMAGE_ASPECT_COLOR_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_ASPECT_DEPTH_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_ASPECT_STENCIL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_ASPECT_METADATA_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageAspectFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_ASPECT_COLOR_BIT</span> 将图片数据解析成颜色值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_ASPECT_DEPTH_BIT</span> 将图片数据解析成深度值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_ASPECT_STENCIL_BIT</span> 将图片数据解析成模板值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_ASPECT_METADATA_BIT</span> 将图片数据解析成原始数据值。用于稀疏资源。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_ASPECT_COLOR_BIT</span></code> 、 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_ASPECT_DEPTH_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_ASPECT_STENCIL_BIT</span></code> 经常使用。</p>
<div class="note admonition">
<p class="admonition-title">深度和模板</p>
<p>深度和模板将会在详细章节中展开。</p>
</div>
<div class="note admonition">
<p class="admonition-title">稀疏资源</p>
<p>稀疏资源将会在详细章节中展开。</p>
</div>
<p>目前我们对于多级渐远纹理是忽略的，也就是多级渐远级别只有图片本身的 <code class="docutils literal notranslate"><span class="pre">0</span></code> 级，对于多级渐远纹理将会在详细章节进行讲解。</p>
</section>
<section id="id32">
<h5>解析范围<a class="headerlink" href="#id32" title="Link to this heading">#</a></h5>
<p>通过前面对于 <code class="docutils literal notranslate"><span class="pre">VkImageSubresourceRange</span></code> 的说明，可以知道其是用于解析目标图片的范围，所谓 <code class="docutils literal notranslate"><span class="pre">解析范围</span></code> 换句话说就是：</p>
<blockquote>
<div><p>对于图片视图的目标图片 <code class="docutils literal notranslate"><span class="pre">VkImageViewCreateInfo::image</span></code> ，哪一部分图片数据是该视图可见的，并且指定如何解析这一部分数据。</p>
</div></blockquote>
<p>通过之前的 <a class="reference internal" href="#image"><span class="std std-ref">图片</span></a> 章节，我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的图片都是按照三维图片 <code class="docutils literal notranslate"><span class="pre">数组</span></code> 形式存储的：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkImageCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">VkExtent3D</span><span class="w">               </span><span class="n">extent</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">arrayLayers</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<p>其中的 <code class="docutils literal notranslate"><span class="pre">VkImageSubresourceRange::baseArrayLayer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VkImageSubresourceRange::layerCount</span></code> 就是用于限定该图片视图对于目标图片的哪些层级可见。</p>
<p>比如，最常见的就是对于二维颜色图片的视图：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>

<span class="n">VkImage</span><span class="w"> </span><span class="n">color_image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建像素是颜色格式的二维图片</span><span class="p">;</span><span class="w"> </span><span class="c1">// 假如为 512（width） × 512（height） × 1（depth） × 1（layer）</span>
<span class="w">                                                     </span><span class="c1">// 像素格式为 VkFormat::VK_FORMAT_B8G8R8A8_SRGB</span>

<span class="n">VkImageSubresourceRange</span><span class="w"> </span><span class="n">color_image_subresource_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">color_image_subresource_range</span><span class="p">.</span><span class="n">aspectMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageAspectFlagBits</span><span class="o">::</span><span class="n">VK_IMAGE_ASPECT_COLOR_BIT</span><span class="p">;</span>
<span class="n">color_image_subresource_range</span><span class="p">.</span><span class="n">baseMipLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">color_image_subresource_range</span><span class="p">.</span><span class="n">levelCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">color_image_subresource_range</span><span class="p">.</span><span class="n">baseArrayLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">color_image_subresource_range</span><span class="p">.</span><span class="n">layerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="n">VkComponentMapping</span><span class="w"> </span><span class="n">component_mapping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">component_mapping</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkComponentSwizzle</span><span class="o">::</span><span class="n">VK_COMPONENT_SWIZZLE_IDENTITY</span><span class="p">;</span>
<span class="n">component_mapping</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkComponentSwizzle</span><span class="o">::</span><span class="n">VK_COMPONENT_SWIZZLE_IDENTITY</span><span class="p">;</span>
<span class="n">component_mapping</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkComponentSwizzle</span><span class="o">::</span><span class="n">VK_COMPONENT_SWIZZLE_IDENTITY</span><span class="p">;</span>
<span class="n">component_mapping</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkComponentSwizzle</span><span class="o">::</span><span class="n">VK_COMPONENT_SWIZZLE_IDENTITY</span><span class="p">;</span>

<span class="n">VkImageViewCreateInfo</span><span class="w"> </span><span class="n">color_image_view_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color_image</span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">viewType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageViewType</span><span class="o">::</span><span class="n">VK_IMAGE_VIEW_TYPE_2D</span><span class="w"> </span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkFormat</span><span class="o">::</span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">component_mapping</span><span class="p">;</span>
<span class="n">color_image_view_create_info</span><span class="p">.</span><span class="n">subresourceRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color_image_subresource_range</span><span class="p">;</span>

<span class="n">VkImageView</span><span class="w"> </span><span class="n">color_image_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateImageView</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">color_image_view_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">color_image_view</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;创建图片视图失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其示意图如下：</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image_and_view.png"><img alt="_images/image_and_view.png" src="_images/image_and_view.png" style="width: 274px; height: 260px;" /></a>
</figure>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>示意图中视图比图片大，其用意为表示视图的可视范围为整个图片，而不是视图可访问的数据大于图片已知数据集的意思。</p>
</div>
</section>
</section>
</section>
</section>
<section id="id33">
<h2>资源与内存<a class="headerlink" href="#id33" title="Link to this heading">#</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中创建一个资源（ <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 或 <code class="docutils literal notranslate"><span class="pre">VkBuffer</span></code> ）仅仅表示一个资源符号，其内部仅有对于该资源的描述，没有确切的内存空间。所以在创建资源之后需要绑定一个内存，这样就给了该资源完整的一生。 <span class="sd-sphinx-override sd-badge sd-bg-primary sd-bg-text-primary">✧(๑≖ ◡ ≖๑)</span></p>
<p>在创建完资源后，需要绑定内存，这就需要创建内存，创建内存需要设置 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo::allocationSize</span></code> 内存分配的大小。但是此时该资源需要多大的内存呢？ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为我们提供了两个函数来获取相应资源需要的内存信息：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkGetBufferMemoryRequirements(…)</span> 获取缓存资源需要的内存信息</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkGetImageMemoryRequirements(…)</span> 获取图片资源需要的内存信息</p></li>
</ul>
<p>这两个函数的定义如下：</p>
<section id="vkgetbuffermemoryrequirements">
<h3>vkGetBufferMemoryRequirements<a class="headerlink" href="#vkgetbuffermemoryrequirements" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetBufferMemoryRequirements</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBuffer</span><span class="w">                                    </span><span class="n">buffer</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkMemoryRequirements</span><span class="o">*</span><span class="w">                       </span><span class="n">pMemoryRequirements</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">buffer</span> 要获取内存信息的目标缓存资源句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemoryRequirements</span> 获取的内存结果信息。</p></li>
</ul>
</section>
<section id="vkgetimagememoryrequirements">
<h3>vkGetImageMemoryRequirements<a class="headerlink" href="#vkgetimagememoryrequirements" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetImageMemoryRequirements</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkImage</span><span class="w">                                     </span><span class="n">image</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkMemoryRequirements</span><span class="o">*</span><span class="w">                       </span><span class="n">pMemoryRequirements</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">image</span> 要获取内存信息的目标图片资源句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemoryRequirements</span> 写入需要的内存结果信息。</p></li>
</ul>
<p>其中的 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements</span></code> 定义如下：</p>
</section>
<section id="vkmemoryrequirements">
<h3>VkMemoryRequirements<a class="headerlink" href="#vkmemoryrequirements" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryRequirements</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">    </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">    </span><span class="n">alignment</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">memoryTypeBits</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryRequirements</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 资源需要的内存大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">alignment</span> 内存对齐的大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypeBits</span> 支持的内存类型标志位所对应的的索引值。</p></li>
</ul>
<p>当创建内存时需要指定内存分配的大小，也就是 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo::allocationSize</span></code> ，该大小应不小于 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements::size</span></code> 大小。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements::alignment</span></code> 内存对齐不是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准的重点，但考虑到完整性将会在专门的章节中进行讲解。这里简单说明一下。在芯片中对于内存的访问并不是一个比特一个比特访问的，而是为了提高效率将多个比特为一组， 芯片一组一组的进行读取的，所以数据需要写到各组的正确位置，这样芯片一组组读取就能够获得正确的内容了，而一组的比特数量一般为内存对齐大小的整数倍。</p>
<p>而此时我们需要重点关注一下 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements::memoryTypeBits</span></code> 所表述的意义：</p>
<section id="memorytypebits">
<h4>memoryTypeBits<a class="headerlink" href="#memorytypebits" title="Link to this heading">#</a></h4>
<p>通过 <a class="reference internal" href="#memory"><span class="std std-ref">内存</span></a> 章节我们知道一台 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上存在有多个 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> （ <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[VK_MAX_MEMORY_TYPES]</span></code> ），并且每个 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 都有对应的的内存堆。这样一台 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上就存在有多个内存堆。可能其中某几个内存堆都支持分配该资源的内存，此时需要告知我们都有哪些堆支持分配该资源内存，而堆与 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 对应，所以 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 应该
告诉我们都有哪些 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 支持该资源的内存分配。这应该返回一个数组才对，而 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements::memoryTypeBits</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 为一个正整数，而不是一个数组，为什么会这样？</p>
<div class="note admonition">
<p class="admonition-title">VK_MAX_MEMORY_TYPES</p>
<p><code class="docutils literal notranslate"><span class="pre">VK_MAX_MEMORY_TYPES</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">32</span></code>。 定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_MAX_MEMORY_TYPES 32U</span>
</pre></div>
</div>
</div>
<p>这是通过 <code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements::memoryTypeBits</span></code> 的标志位进行“数组”表示的。 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 由 <code class="docutils literal notranslate"><span class="pre">32</span></code> 位比特组成，如果某一位的比特值为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则相应位数作为支持的 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 数组索引。比如：</p>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryRequirements::memoryTypeBits</span></code> 为 <code class="docutils literal notranslate"><span class="pre">113</span></code> 的话其对应的二进制为 <code class="docutils literal notranslate"><span class="pre">0000</span> <span class="pre">0000</span> <span class="pre">0000</span> <span class="pre">0000</span> <span class="pre">0000</span> <span class="pre">0000</span> <span class="pre">0100</span> <span class="pre">1011</span></code> 则表示：</p>
<ul class="simple">
<li><p>第 <code class="docutils literal notranslate"><span class="pre">0</span></code> 位的比特为 <code class="docutils literal notranslate"><span class="pre">1</span></code> : <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[0]</span></code> 类型内存支持分配该资源。</p></li>
<li><p>第 <code class="docutils literal notranslate"><span class="pre">1</span></code> 位的比特为 <code class="docutils literal notranslate"><span class="pre">1</span></code> : <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[1]</span></code> 类型内存支持分配该资源。</p></li>
<li><p>第 <code class="docutils literal notranslate"><span class="pre">3</span></code> 位的比特为 <code class="docutils literal notranslate"><span class="pre">1</span></code> : <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[3]</span></code> 类型内存支持分配该资源。</p></li>
<li><p>第 <code class="docutils literal notranslate"><span class="pre">6</span></code> 位的比特为 <code class="docutils literal notranslate"><span class="pre">1</span></code> : <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[6]</span></code> 类型内存支持分配该资源。</p></li>
</ul>
<p>就这样通过一个 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 就存储了一个“数组” ，而 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes</span></code> 数组的最大长度为 <code class="docutils literal notranslate"><span class="pre">VK_MAX_MEMORY_TYPES</span></code> 即 <code class="docutils literal notranslate"><span class="pre">32</span></code> ，这样一个 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 有 <code class="docutils literal notranslate"><span class="pre">32</span></code> 位就可以囊括整个数组长度 。这种数据存储方式一般叫按位存储或标志位等。</p>
<p>如此我们就知道资源的内存应该分配在哪一个内存类型上了。进而就知道在哪个内存堆上进行的内存分配。</p>
</section>
</section>
<section id="id34">
<h3>资源与内存的绑定<a class="headerlink" href="#id34" title="Link to this heading">#</a></h3>
<p>现在我们知道如何创建资源和内存，并且能够获取到在哪个内存类型（堆）上分配内存。如此，我们就可以进行资源绑定了。大致流程如下：</p>
<div class="mermaid">
            flowchart TB

   CreateResource[&quot;创建资源&quot;]
   GetMemoryRequirement[&quot;获取资源的内存要求&quot;]
   AllocateMemory[&quot;根据要求分配内存&quot;]
   Binding[&quot;资源与内存绑定&quot;]

   CreateResource--&gt;GetMemoryRequirement
   GetMemoryRequirement--&gt;AllocateMemory
   AllocateMemory--&gt;Binding
        </div><p>假如说我们现在已经成功创建了一个 <code class="docutils literal notranslate"><span class="pre">VkBuffer</span></code> 的话，现在我们需要筛选要在哪一个内存类型（堆）上分配内存，如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkBuffer</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的缓存资源句柄</span><span class="p">;</span>

<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkMemoryRequirements</span><span class="w"> </span><span class="n">memory_requirements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">vkGetBufferMemoryRequirements</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_requirements</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">VK_MAX_MEMORY_TYPES</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="p">(((</span><span class="n">memory_requirements</span><span class="p">.</span><span class="n">memoryTypeBits</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x01</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x01</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 说明 VkPhysicalDeviceMemoryProperties::memoryTypes[memory_type_index] 上可以分配内存</span>
<span class="w">      </span><span class="c1">// 这里为了简单，遍历所有匹配的内存类型，并尝试内存分配，如果内存分配成功就跳出，否则继续尝试分配内存。</span>

<span class="w">      </span><span class="n">VkMemoryAllocateInfo</span><span class="w"> </span><span class="n">memory_allocate_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">      </span><span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span><span class="p">;</span>
<span class="w">      </span><span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">      </span><span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">allocationSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_requirements</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="w">      </span><span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">memoryTypeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_type_index</span><span class="p">;</span>

<span class="w">      </span><span class="n">VkResult</span><span class="w"> </span><span class="n">allocate_memory_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkAllocateMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_allocate_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_memory</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">allocate_memory_result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span><span class="c1">// 成功创建的话就跳出</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span><span class="n">device_memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;没有找到支持该资源的内存类型（堆）&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样我们就成功在正确的内存类型上分配了内存。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 资源的内存筛选与分配，除了获取内存分配信息使用的是 <code class="docutils literal notranslate"><span class="pre">vkGetImageMemoryRequirements</span></code> 函数，其他和 <code class="docutils literal notranslate"><span class="pre">VkBuffer</span></code> 的流程是相同的。</p>
</div>
<p>接下来就可以通过调用 <code class="docutils literal notranslate"><span class="pre">vkBindBufferMemory</span></code> 和 <code class="docutils literal notranslate"><span class="pre">vkBindImageMemory</span></code> 分别将缓存和图片资源与内存进行绑定了。</p>
<section id="vkbindbuffermemory">
<h4>vkBindBufferMemory<a class="headerlink" href="#vkbindbuffermemory" title="Link to this heading">#</a></h4>
<p>将缓存与内存进行绑定，通过 <code class="docutils literal notranslate"><span class="pre">vkBindBufferMemory</span></code> 函数进行绑定，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkBindBufferMemory</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBuffer</span><span class="w">                                    </span><span class="n">buffer</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceMemory</span><span class="w">                              </span><span class="n">memory</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">                                </span><span class="n">memoryOffset</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">buffer</span> 要绑定的目标缓存句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memory</span> 要绑定的目标缓存句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryOffset</span> 以 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 对应的 <code class="docutils literal notranslate"><span class="pre">memoryOffset</span></code> 偏移处作为资源的起始内存。单位为 <code class="docutils literal notranslate"><span class="pre">字节</span></code> 。</p></li>
</ul>
<p>该函数比较简洁明了，将 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 进行绑定。此时注意 <code class="docutils literal notranslate"><span class="pre">memoryOffset</span></code> 成员。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 官方对于内存推荐的做法是分配一块大内存，之后将这块大内存分成多块用于存储不同的资源，这时就需要指定资源的内存偏移，以此来设置资源的起始内存位置。
但此时我们给出的示例中的内存分配都是刚刚好的（整个内存块全部被资源占有），所以此时 <code class="docutils literal notranslate"><span class="pre">memoryOffset</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkBuffer</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的缓存资源句柄</span><span class="p">;</span>
<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的内存句柄</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkBindBufferMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">device_memory</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;缓存绑定内存失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="vkbindimagememory">
<h4>vkBindImageMemory<a class="headerlink" href="#vkbindimagememory" title="Link to this heading">#</a></h4>
<p>与缓存绑定内存类似，图片通过 <code class="docutils literal notranslate"><span class="pre">vkBindImageMemory</span></code> 进行内存绑定。其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkBindImageMemory</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkImage</span><span class="w">                                     </span><span class="n">image</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceMemory</span><span class="w">                              </span><span class="n">memory</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">                                </span><span class="n">memoryOffset</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">image</span> 要绑定的目标图片句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memory</span> 要绑定的目标缓存句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryOffset</span> 以 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 对应的 <code class="docutils literal notranslate"><span class="pre">memoryOffset</span></code> 偏移处作为资源的起始内存。单位为 <code class="docutils literal notranslate"><span class="pre">字节</span></code> 。</p></li>
</ul>
<p>与缓存绑定内存类似，这里就不再赘述。</p>
</section>
</section>
</section>
<section id="id35">
<h2>数据传输<a class="headerlink" href="#id35" title="Link to this heading">#</a></h2>
<p>现在我们有了内存，有了资源，并且资源与内存进行了绑定。一切看起来是那么的美好。<span class="sd-sphinx-override sd-badge sd-bg-primary sd-bg-text-primary">｡ (ˊᗜˋ*) ｡</span> 但是现在内存中的数据没有任何意义（没有任何赋值，仅仅为默认值），我们需要向内存中写入数据，来存储意义非凡的数据才是我们想要的。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中传输数据有很多种途径，大体可以分成两类：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">通过CPU向内存中传输数据</span></p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">通过GPU向内存中传输数据</span></p></li>
</ul>
<section id="cpu">
<h3>通过CPU向内存中传输数据<a class="headerlink" href="#cpu" title="Link to this heading">#</a></h3>
<p>当分配 <code class="docutils literal notranslate"><span class="pre">VkDeviceMemory</span></code> 内存时需要指定 <a class="reference internal" href="#vkmemoryallocateinfo"><span class="std std-ref">VkMemoryAllocateInfo</span></a> 中的内存类型索引 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo::memoryTypeIndex</span></code> 。如果该内存类型支持 <code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span></code> （也就是可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问到）的话，分配的设备内存可以进行 <code class="docutils literal notranslate"><span class="pre">内存映射</span></code> 。</p>
<div class="note admonition">
<p class="admonition-title">内存映射</p>
<p>所谓 <code class="docutils literal notranslate"><span class="pre">内存映射</span></code> 就是将 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkDeviceMemory</span></code> 内存映射到一个指针上，对该指针所指向的内存进行读写就是直接向 <code class="docutils literal notranslate"><span class="pre">VkDeviceMemory</span></code> 所代表的设备内存中进行读写。</p>
</div>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">VkDeviceMemory</span></code> 设备内存 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 在支持 <code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlagBits::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span></code> 的内存类型上进行分配。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中是通过 <code class="docutils literal notranslate"><span class="pre">vkMapMemory</span></code> 函数将内存进行映射，其定义如下：</p>
<section id="vkmapmemory">
<h4>vkMapMemory<a class="headerlink" href="#vkmapmemory" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkMapMemory</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceMemory</span><span class="w">                              </span><span class="n">memory</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">                                </span><span class="n">offset</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">                                </span><span class="n">size</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkMemoryMapFlags</span><span class="w">                            </span><span class="n">flags</span><span class="p">,</span>
<span class="w">    </span><span class="kt">void</span><span class="o">**</span><span class="w">                                      </span><span class="n">ppData</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memory</span> 要映射的目标缓存句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">offset</span> 映射的内存偏移。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 映射的内存大小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 保留成员，用于未来时使用。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppData</span> 映射结果。</p></li>
</ul>
<p>如此我们就可以对设备内存进行内存映射了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功在</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="w"> </span><span class="n">上创建的内存句柄</span><span class="p">;</span>
<span class="n">VkDeviceSize</span><span class="w"> </span><span class="n">memory_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="c1">// 假如内存的大小为 1024 byte</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">memory_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkMapMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">device_memory</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">memory_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_ptr</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;内存映射失败&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">您准备好的数据</span><span class="p">;</span>

<span class="n">memcpy</span><span class="p">(</span><span class="n">memory_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">memory_size</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将准备好的数据拷贝至设备内存中</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>如果设备内存已经通过 <code class="docutils literal notranslate"><span class="pre">vkMapMemory</span></code> 映射完成，处于 <code class="docutils literal notranslate"><span class="pre">映射态</span></code> ，则 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">不能</span> 再次调用  <code class="docutils literal notranslate"><span class="pre">vkMapMemory</span></code> 再一次映射内存。</p>
</div>
<p>映射完成后您可以取消设备内存的映射，这是通过调用 <code class="docutils literal notranslate"><span class="pre">vkUnmapMemory</span></code> 函数解除内存映射：</p>
</section>
<section id="vkunmapmemory">
<h4>vkUnmapMemory<a class="headerlink" href="#vkunmapmemory" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkUnmapMemory</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDeviceMemory</span><span class="w">                              </span><span class="n">memory</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memory</span> 要取消映射的目标缓存句柄。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>要解除映射的设备内存 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 当前 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 已经通过 <code class="docutils literal notranslate"><span class="pre">vkMapMemory</span></code> 调用处于 <code class="docutils literal notranslate"><span class="pre">映射态</span></code> 。</p>
</div>
<p>当解除映射之后，之前映射的指针将失效，如果想重新获取映射指针，再次调用 <code class="docutils literal notranslate"><span class="pre">vkMapMemory</span></code> 进行映射即可。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前完成内存映射的设备内存</span><span class="p">;</span>

<span class="n">vkUnmapMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">device_memory</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="gpu">
<span id="transformdatatogpu"></span><h3>通过GPU向内存中传输数据<a class="headerlink" href="#gpu" title="Link to this heading">#</a></h3>
<p>为了能够控制 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 完成我们需要的工作， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为我们提供了一系列的 <code class="docutils literal notranslate"><span class="pre">指令</span></code> 接口，通过组合各种指令，控制 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 进行计算，其中就包括拥有数据传输（读写）功能的指令。</p>
<p>其中拥有数据传输功能的指令有很多，这里并不打算展开深入讲解，但为了加深理解，这里简单讲解 <code class="docutils literal notranslate"><span class="pre">vkCmdCopyBuffer</span></code> 指令。该指令用于在 <code class="docutils literal notranslate"><span class="pre">Buffer</span></code> 间传输数据，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkCmdCopyBuffer</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkCommandBuffer</span><span class="w">                             </span><span class="n">commandBuffer</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBuffer</span><span class="w">                                    </span><span class="n">srcBuffer</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBuffer</span><span class="w">                                    </span><span class="n">dstBuffer</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">regionCount</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkBufferCopy</span><span class="o">*</span><span class="w">                         </span><span class="n">pRegions</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">commandBuffer</span> 指令缓存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">srcBuffer</span> 源缓存。需要其创建时 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo::usage</span></code> 包含 <code class="docutils literal notranslate"><span class="pre">VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span></code> 位域。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">dstBuffer</span> 目标缓存。需要其创建时 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo::usage</span></code> 包含 <code class="docutils literal notranslate"><span class="pre">VkBufferUsageFlagBits::VK_BUFFER_USAGE_TRANSFER_DST_BIT</span></code> 位域。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">regionCount</span> 传输数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pRegions</span> 传输配置（数组）。且元素数量不能小于 <code class="docutils literal notranslate"><span class="pre">regionCount</span></code> 指定的数量。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">指令缓存</p>
<p>之前说过， <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 是通过组合各种指令并执行来进行计算的， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为了效率最大化推出了 <code class="docutils literal notranslate"><span class="pre">指令缓存</span></code> ，您可以简单将其理解为指令包（容器），通过传输一包包指令来告诉 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 是如何工作的。具体细节将会在之后具体章节展开。</p>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkBufferCopy</span></code> 中的成员意义非常直接，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkBufferCopy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">    </span><span class="n">srcOffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">    </span><span class="n">dstOffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">    </span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkBufferCopy</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">srcOffset</span> 源缓存偏移。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">dstOffset</span> 目标缓存偏移。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 拷贝的大小。单位为 <code class="docutils literal notranslate"><span class="pre">字节</span></code> 。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">vkCmdCopyBuffer</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 经典的数据传输指令，其中最经典的用法就是：将 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的数据传输到 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 端内存中供 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>

<span class="n">VkDeviceSize</span><span class="w"> </span><span class="n">memory_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="c1">// 假如内存的大小都为 1024 byte</span>

<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">host_visible_device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功在</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="w"> </span><span class="n">上创建的内存句柄</span><span class="p">;</span><span class="w"> </span><span class="c1">// 此时该设备内存中数据为未定义值（未初始化）</span>
<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_local_device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功在</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="n">上创建的内存句柄</span><span class="p">;</span><span class="w"> </span><span class="c1">// 此时该设备内存中数据已经被 GPU 写入完成</span>

<span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">copy_buffer_command_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">用于记录缓存拷贝指令的指令缓存</span><span class="p">;</span>

<span class="n">开启指令缓存指令记录</span><span class="p">(</span><span class="n">copy_buffer_command_buffer</span><span class="p">);</span>

<span class="n">VkBufferCopy</span><span class="w"> </span><span class="n">buffer_copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">buffer_copy</span><span class="p">.</span><span class="n">srcOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">buffer_copy</span><span class="p">.</span><span class="n">dstOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">buffer_copy</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_size</span><span class="p">;</span>

<span class="n">vkCmdCopyBuffer</span><span class="p">(</span><span class="n">copy_buffer_command_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">device_local_device_memory</span><span class="p">,</span><span class="w"> </span><span class="n">host_visible_device_memory</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer_copy</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将缓存拷贝指令加入到指令缓存中</span>

<span class="n">结束指令缓存指令记录</span><span class="p">(</span><span class="n">copy_buffer_command_buffer</span><span class="p">);</span>

<span class="n">将指令缓存推送到GPU</span><span class="p">(</span><span class="n">copy_buffer_command_buffer</span><span class="p">);</span>

<span class="n">等待GPU指令执行完成</span><span class="p">();</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">memory_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkMapMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">host_visible_device_memory</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">memory_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_ptr</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;内存映射失败&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">memory_size</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">memory_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">memory_size</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将传输至 CPU 可访问缓存中的数据拷贝至 CPU 可访问的内存中</span>

<span class="n">vkUnmapMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">host_visible_device_memory</span><span class="p">);</span>

<span class="c1">// 对 buffer 的其他操作 ...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<ul class="simple">
<li><p>将指令缓存推送到 <code class="docutils literal notranslate"><span class="pre">GPU</span></code></p></li>
<li><p>等待 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 指令执行完成</p></li>
</ul>
<p>这两部分将会在后面的章节进行讲解。</p>
</div>
</section>
</section>
<section id="id36">
<h2>指令<a class="headerlink" href="#id36" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中提供了一系列的接口函数，其中有一部分函数将会作为 <code class="docutils literal notranslate"><span class="pre">指令</span></code> 通过 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 记录在 <code class="docutils literal notranslate"><span class="pre">指令容器</span></code> 中，之后可以将 <code class="docutils literal notranslate"><span class="pre">指令容器</span></code> 推送到 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 中执行。</p>
<p>这种在 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 记录，在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上执行的函数叫做 <code class="docutils literal notranslate"><span class="pre">指令</span></code> 。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中提供了各种各样的指令，比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vkCmdFillBuffer</span><span class="p">(...);</span>
<span class="n">vkCmdCopyBuffer</span><span class="p">(...);</span>
<span class="n">vkCmdCopyBufferToImage</span><span class="p">(...);</span>
<span class="n">vkCmdBlitImage</span><span class="p">(...)</span>
<span class="n">vkCmdResolveImage</span><span class="p">(...);</span>
<span class="n">vkCmdDraw</span><span class="p">(...);</span>
<span class="n">vkCmdDispatch</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>其中不难看出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的所有指令都是以 <code class="docutils literal notranslate"><span class="pre">vkCmd{指令名称}</span></code> 的格式进行命名的，而且通过指令名称可以很直接看出其用途：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdFillBuffer</span> 填充缓存指令。用于初始化缓存中的数据。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdCopyBuffer</span> 缓存间数据拷贝指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdCopyBufferToImage</span> 缓存拷贝至据图片指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdBlitImage</span> 图片传输构建指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdResolveImage</span> 图片采样指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdDraw</span> 绘制指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vkCmdDispatch</span> 调度指令。</p></li>
</ul>
<p>具体指令如何使用，将会在详细章节进行讲解。</p>
<p>上面我们知道指令都是记录在 <code class="docutils literal notranslate"><span class="pre">指令容器</span></code> 中，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为我们提供了 <code class="docutils literal notranslate"><span class="pre">指令缓存</span></code> 。</p>
</section>
<section id="id37">
<h2>指令缓存<a class="headerlink" href="#id37" title="Link to this heading">#</a></h2>
<p>由于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 与 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 沟通是通过 <code class="docutils literal notranslate"><span class="pre">PCI</span></code> 总线，这种传输方式相比于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 与 <code class="docutils literal notranslate"><span class="pre">内存条</span></code> 间的访问速度慢上不少，所以为了最大效率的利用 <code class="docutils literal notranslate"><span class="pre">PCI</span></code> 总线，往往希望 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 在一次 <code class="docutils literal notranslate"><span class="pre">PCI</span></code> 数据传输中传输的数据越多越好。也就是此原因， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为了尽可能多的一次性多提交指令，为我们提供了 <code class="docutils literal notranslate"><span class="pre">VkCommandBuffer</span></code> 句柄，用于代表 <code class="docutils literal notranslate"><span class="pre">指令缓存</span></code> 对象。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中，指令缓存使用 <code class="docutils literal notranslate"><span class="pre">VkCommandBuffer</span></code> 句柄表示。如果按照正常思路对于指令缓存的创建应该有一个名为 <code class="docutils literal notranslate"><span class="pre">vkCreateCommandBuffer(...)</span></code> 的函数，但是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准在设计时考虑了更多。首先考虑到 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 有如下基本特点：</p>
<ul class="simple">
<li><p>支持多线程</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CPU</span></code> 与 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 沟通只能通过指令缓存</p></li>
<li><p>渲染一个场景往往需要执行成千上万个指令缓存，进行各种高强度计算</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GPU</span></code> 本身具有强大的并行计算能力</p></li>
</ul>
<p>这就表示指令缓存其本身不论是创建还是执行都需要尽可能的提高效率，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准将指令缓存使用 <code class="docutils literal notranslate"><span class="pre">池</span></code> 的方式管理。也就是 <code class="docutils literal notranslate"><span class="pre">指令缓存池</span></code> 。</p>
<div class="note admonition">
<p class="admonition-title">池</p>
<p>所谓 <code class="docutils literal notranslate"><span class="pre">池</span></code> ，就是一片提前划分好的区域，当需要空间时，直接占有池子中的一块闲置区域，当不需要时直接还给 <code class="docutils literal notranslate"><span class="pre">池子</span></code> 。这不再需要繁琐的空间分配算法，由于空间已经分配完成，需要空间，直接使用即可。这对于性能来说非常高效。</p>
</div>
</section>
<section id="id38">
<h2>指令缓存池<a class="headerlink" href="#id38" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中使用 <code class="docutils literal notranslate"><span class="pre">VkCommandPool</span></code> 句柄代表 <code class="docutils literal notranslate"><span class="pre">指令缓存池</span></code> 。与其他句柄创建类型，其使用 <code class="docutils literal notranslate"><span class="pre">vkCreateCommandPool(...)</span></code> 函数创建指令缓存池。</p>
<section id="vkcreatecommandpool">
<h3>vkCreateCommandPool<a class="headerlink" href="#vkcreatecommandpool" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateCommandPool</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandPoolCreateInfo</span><span class="o">*</span><span class="w">              </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkCommandPool</span><span class="o">*</span><span class="w">                              </span><span class="n">pCommandPool</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 指令缓存池的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCommandPool</span> 创建的目标指令缓存池。</p></li>
</ul>
<p>我们来看一下 <code class="docutils literal notranslate"><span class="pre">VkCommandPoolCreateInfo</span></code> 的定义，如下。</p>
</section>
<section id="vkcommandpoolcreateinfo">
<h3>VkCommandPoolCreateInfo<a class="headerlink" href="#vkcommandpoolcreateinfo" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkCommandPoolCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkCommandPoolCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueFamilyIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkCommandPoolCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 指令缓存池额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 目标队列族索引。</p></li>
</ul>
<p>其中重点关注一下 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 成员。根据 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准的要求，指令缓存池都是基于设备的其中一个 <a class="reference internal" href="#devicequeue"><span class="std std-ref">设备队列</span></a> 族创建的，并且该池中的所有队列缓存 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 推送到对应同族的设备队列中执行。</p>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkCommandPoolCreateFlags</span></code> 可用的枚举值定义在 <code class="docutils literal notranslate"><span class="pre">VkCommandPoolCreateFlagBits</span></code> 中，其定义如下：</p>
</section>
<section id="vkcommandpoolcreateflagbits">
<h3>VkCommandPoolCreateFlagBits<a class="headerlink" href="#vkcommandpoolcreateflagbits" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkCommandPoolCreateFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkCommandPoolCreateFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</span> 用于指定该指令缓存池中分配的指令缓存的寿命将会较短。这意味着该池中的指令缓存将会在较短的时间内重置或回收。该标志位可能用于底层驱动内部控制内存分配策略。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span> 用于指定该指令缓存池中分配的各个指令缓存可以单独进行重置。</p></li>
</ul>
<p>现在我们就可以在支持图形功能的队列上创建一个指令缓存池了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到支持图形的队列族索引</span><span class="p">;</span>

<span class="n">VkCommandPoolCreateInfo</span><span class="w"> </span><span class="n">command_pool_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">command_pool_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</span><span class="p">;</span>
<span class="n">command_pool_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">command_pool_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkCommandPoolCreateFlagBits</span><span class="o">::</span><span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使其分配的所有指令缓存都可以单独重置</span>
<span class="n">command_pool_create_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">;</span>

<span class="n">VkCommandPool</span><span class="w"> </span><span class="n">command_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateCommandPool</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_pool_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_pool</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;指令缓存池创建失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id39">
<h2>分配指令缓存<a class="headerlink" href="#id39" title="Link to this heading">#</a></h2>
<p>在创建完指令缓存池之后，就可以从该池中分配指令缓存了。 我们可以通过 <code class="docutils literal notranslate"><span class="pre">vkAllocateCommandBuffers</span></code> 分配指令缓存。定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkAllocateCommandBuffers</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandBufferAllocateInfo</span><span class="o">*</span><span class="w">          </span><span class="n">pAllocateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkCommandBuffer</span><span class="o">*</span><span class="w">                            </span><span class="n">pCommandBuffers</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocateInfo</span> 指令缓存的分配信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCommandBuffers</span> 分配的目标指令缓存。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferAllocateInfo</span></code> 定义如下：</p>
<section id="vkcommandbufferallocateinfo">
<h3>VkCommandBufferAllocateInfo<a class="headerlink" href="#vkcommandbufferallocateinfo" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkCommandBufferAllocateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">         </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">             </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkCommandPool</span><span class="w">           </span><span class="n">commandPool</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkCommandBufferLevel</span><span class="w">    </span><span class="n">level</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                </span><span class="n">commandBufferCount</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkCommandBufferAllocateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">commandPool</span> 指定在哪个指令缓存池中进行分配。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">level</span> 指令缓存级别。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">commandBufferCount</span> 要创建的指令缓存数量。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">commandBufferCount</span></code> 成员对应的数量为要从 <code class="docutils literal notranslate"><span class="pre">commandPool</span></code> 中分配的指令缓存数量，并会将分配结果写入 <code class="docutils literal notranslate"><span class="pre">vkAllocateCommandBuffers(...)</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pCommandBuffers</span></code> 中，这也就表明 <code class="docutils literal notranslate"><span class="pre">pCommandBuffers</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是满足数量为 <code class="docutils literal notranslate"><span class="pre">commandBufferCount</span></code> 的数组。</p>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferLevel</span></code> 用于表示分配的指令缓存级别，其定义如下：</p>
</section>
<section id="vkcommandbufferlevel">
<h3>VkCommandBufferLevel<a class="headerlink" href="#vkcommandbufferlevel" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkCommandBufferLevel</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkCommandBufferLevel</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span> 指令该指令缓存级别为主要。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span> 指令该指令缓存级别为次要。</p></li>
</ul>
<p>所谓 <code class="docutils literal notranslate"><span class="pre">主要</span></code> 级别指令缓存，其表示该级别的指令缓存可以直接推给 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 进行执行，而 <code class="docutils literal notranslate"><span class="pre">次要</span></code> 指令缓存不能直接推送，只能依附于 <code class="docutils literal notranslate"><span class="pre">主要</span></code> 级指令缓存上，并由 <code class="docutils literal notranslate"><span class="pre">主要</span></code> 级指令缓存间接调用。</p>
<div class="note admonition">
<p class="admonition-title">主、次要指令缓存</p>
<p>有关主、次要指令缓存将在详细章节展开。目前我们只关注 <code class="docutils literal notranslate"><span class="pre">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span></code> 主要指令缓存即可。</p>
<p>下文会出现 <code class="docutils literal notranslate"><span class="pre">一级</span></code> 和 <code class="docutils literal notranslate"><span class="pre">二级</span></code> （指令）缓存，分别代表 <code class="docutils literal notranslate"><span class="pre">主要</span></code> 级别和 <code class="docutils literal notranslate"><span class="pre">次要</span></code> 级别指令缓存。</p>
</div>
<p>接下来我们就可以从指令缓存池中分配指令缓存了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkCommandPool</span><span class="w"> </span><span class="n">command_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建的指令缓存池</span><span class="p">;</span>

<span class="n">VkCommandBufferAllocateInfo</span><span class="w"> </span><span class="n">command_buffer_allocate_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">commandPool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">command_pool</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkCommandBufferLevel</span><span class="o">::</span><span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">commandBufferCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkCommandBuffer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">command_buffers</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkAllocateCommandBuffers</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_buffer_allocate_info</span><span class="p">,</span><span class="w"> </span><span class="n">command_buffers</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;指令缓存分配失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id40">
<h2>开启指令缓存<a class="headerlink" href="#id40" title="Link to this heading">#</a></h2>
<p>在通过 <code class="docutils literal notranslate"><span class="pre">vkAllocateCommandBuffers</span></code> 分配完指令缓存后，当前的指令缓存处于 <code class="docutils literal notranslate"><span class="pre">初始状态</span></code> 。为了能够在该指令缓存中记录指令， 我们需要状态切换至 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 。这需要通过调用 <code class="docutils literal notranslate"><span class="pre">vkBeginCommandBuffer</span></code> 函数将 <code class="docutils literal notranslate"><span class="pre">初始状态</span></code> 的指令缓存切换至 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 。其定义如下：</p>
<section id="vkbegincommandbuffer">
<h3>vkBeginCommandBuffer<a class="headerlink" href="#vkbegincommandbuffer" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkBeginCommandBuffer</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkCommandBuffer</span><span class="w">                             </span><span class="n">commandBuffer</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandBufferBeginInfo</span><span class="o">*</span><span class="w">             </span><span class="n">pBeginInfo</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">commandBuffer</span> 切换状态的指令缓存。且 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">需要</span> 为 <code class="docutils literal notranslate"><span class="pre">初始状态</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pBeginInfo</span> 该指令缓存的状态配置信息。</p></li>
</ul>
<p>通过调用该函数如果返回 <code class="docutils literal notranslate"><span class="pre">VkResult::VK_SUCCESS</span></code> 说明 <code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code> 从 <code class="docutils literal notranslate"><span class="pre">初始状态</span></code> 成功切换至 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 。其中的 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferBeginInfo</span></code> 定义如下：</p>
</section>
<section id="vkcommandbufferbegininfo">
<h3>VkCommandBufferBeginInfo<a class="headerlink" href="#vkcommandbufferbegininfo" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkCommandBufferBeginInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">                          </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                              </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkCommandBufferUsageFlags</span><span class="w">                </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandBufferInheritanceInfo</span><span class="o">*</span><span class="w">    </span><span class="n">pInheritanceInfo</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkCommandBufferBeginInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pInheritanceInfo</span> 用于指令缓存为二级缓存时。如果指令缓存为一级缓存时将忽略该成员。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">pInheritanceInfo</p>
<p>由于二级缓存将会在专门的章节展开，这里只使用一级缓存。所以忽略 <code class="docutils literal notranslate"><span class="pre">pInheritanceInfo</span></code> 成员。</p>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferUsageFlags</span></code> 定义如下：</p>
</section>
<section id="vkcommandbufferusageflags">
<h3>VkCommandBufferUsageFlags<a class="headerlink" href="#vkcommandbufferusageflags" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkCommandBufferUsageFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkCommandBufferUsageFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span> 表示该指令缓存将只会提交一次。并会在每次提交与提交之间再次重置指令缓存并记录指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</span> 表示整个二级缓存都被限制在一个渲染过程（ <code class="docutils literal notranslate"><span class="pre">Render</span> <span class="pre">Pass</span></code> ）中。如果是一级缓存将会忽略该标志位。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span> 表示该指令缓存可在同一队列族中的各个队列上重复提交该指令缓存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">Render Pass</p>
<p>为渲染过程，该过程会在内部有一个临时的上下文，用于在内部记录各种渲染状态，用于绘制各种图元。这将会在之后的专门章节进行讲解。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT 与 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</p>
<p>如果为一级缓存。则 <code class="docutils literal notranslate"><span class="pre">VkCommandBufferBeginInfo::flags</span></code> 中不能同时存在 <code class="docutils literal notranslate"><span class="pre">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span></code> 位域。</p>
</div>
<p>接下来我们就可以开启指令了，将 <code class="docutils literal notranslate"><span class="pre">初始状态</span></code> 的指令缓存切换至 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code>：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">command_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建的一级</span><span class="p">(</span><span class="n">主要级</span><span class="p">)</span><span class="n">指令缓存</span><span class="p">;</span>

<span class="n">VkCommandBufferBeginInfo</span><span class="w"> </span><span class="n">command_buffer_begin_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">command_buffer_begin_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span><span class="p">;</span>
<span class="n">command_buffer_begin_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">command_buffer_begin_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkCommandBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span><span class="p">;</span><span class="w"> </span><span class="c1">// 该指令缓存可以反复提交</span>
<span class="n">command_buffer_begin_info</span><span class="p">.</span><span class="n">pInheritanceInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// 由于我们使用的是一级指令缓存，该成员将会忽略</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkBeginCommandBuffer</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_buffer_begin_info</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;启用该指令缓存失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id41">
<h2>指令记录<a class="headerlink" href="#id41" title="Link to this heading">#</a></h2>
<p>在 <a class="reference internal" href="#transformdatatogpu"><span class="std std-ref">通过GPU向内存中传输数据</span></a> 中给出了在指令缓存中记录 <code class="docutils literal notranslate"><span class="pre">vkCmdCopyBuffer</span></code> 指令的示例。我们可以在指令缓存处于 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 后记录各种指令。</p>
<p>通过之前的章节我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供了各种各样的不同功能的指令，这些指令都在指令缓存处于 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 时记录指令。比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">command_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建的一级</span><span class="p">(</span><span class="n">主要级</span><span class="p">)</span><span class="n">指令缓存</span><span class="p">;</span>
<span class="n">VkCommandBufferBeginInfo</span><span class="w"> </span><span class="n">command_buffer_begin_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前的指令缓存开启配置</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkBeginCommandBuffer</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_buffer_begin_info</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;启用该指令缓存失败&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 现在指令缓存处于【记录状态】可以开始记录指令了</span>
<span class="n">vkCmd开启渲染过程</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// 向 command_buffer 中记录一条【开启渲染过程】指令</span>
<span class="n">vkCmd绑定几何数据</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// 向 command_buffer 中记录一条【绑定几何数据】指令</span>
<span class="n">vkCmd绑定渲染接口数据</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// 向 command_buffer 中记录一条【绑定渲染接口数据】指令</span>
<span class="n">vkCmd绑定渲染管线</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// 向 command_buffer 中记录一条【绑定渲染管线】指令</span>
<span class="n">vkCmd绘制</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// 向 command_buffer 中记录一条【绘制】指令</span>
<span class="n">vkCmd</span><span class="p">...(</span><span class="n">command_buffer</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="c1">// 向 command_buffer 中记录其他指令</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为我们提供了各式各样功能不同的指令，具体指令定义和使用方式将在具体章节中展开。</p>
</div>
</section>
<section id="id42">
<h2>结束指令缓存<a class="headerlink" href="#id42" title="Link to this heading">#</a></h2>
<p>当所有需要的指令都记录到了目标指令缓存之后，需要调用 <code class="docutils literal notranslate"><span class="pre">vkEndCommandBuffer</span></code> 结束指令缓存的 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> ，将其从 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 转至成 <code class="docutils literal notranslate"><span class="pre">可执行状态</span></code> ，为将指令缓存推送到 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 做准备。其定义如下：</p>
<section id="vkendcommandbuffer">
<h3>vkEndCommandBuffer<a class="headerlink" href="#vkendcommandbuffer" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEndCommandBuffer</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkCommandBuffer</span><span class="w">                             </span><span class="n">commandBuffer</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">commandBuffer</span> 要结束记录的指令缓存。且 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">需要</span> 为 <code class="docutils literal notranslate"><span class="pre">记录状态</span></code> 。</p></li>
</ul>
<p>结束指令缓存就相对简单：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">command_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前处于</span><span class="p">[</span><span class="n">记录状态</span><span class="p">]</span><span class="n">的指令缓存</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkEndCommandBuffer</span><span class="p">(</span><span class="n">command_buffer</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;结束该指令缓存失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id43">
<h2>指令推送<a class="headerlink" href="#id43" title="Link to this heading">#</a></h2>
<p>当指令缓存记录完需要的指令之后，我们就可以将指令推送给 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 执行了。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>指令推送是一个高开销的操作，所以最好一次性尽量提交多个指令缓存。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中通过 <code class="docutils literal notranslate"><span class="pre">vkQueueSubmit</span></code> 将接口提交至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 执行。</p>
<section id="vkqueuesubmit">
<span id="id44"></span><h3>vkQueueSubmit<a class="headerlink" href="#vkqueuesubmit" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkQueueSubmit</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkQueue</span><span class="w">                                     </span><span class="n">queue</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">submitCount</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkSubmitInfo</span><span class="o">*</span><span class="w">                         </span><span class="n">pSubmits</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkFence</span><span class="w">                                     </span><span class="n">fence</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queue</span> 指定推送至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上的哪一个设备队列中执行。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">submitCount</span> 表示此次推送的指令缓存批次数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pSubmits</span> 表示此次推送的指令缓存批次。该指针所指向的指令缓存批次数量不能小于 <code class="docutils literal notranslate"><span class="pre">submitCount</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">fence</span> 栏栅。如果 <code class="docutils literal notranslate"><span class="pre">fence</span></code> 不为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 的话，则其用于等待该批推送的指令缓存在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上执行结束。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">指令缓存批次</p>
<p>指令缓存都是一批批发送至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备的，每一批都可以包含多个指令缓存。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VkFence</p>
<p><code class="docutils literal notranslate"><span class="pre">栏栅</span></code> 将会在之后的章节进行讲解</p>
</div>
<p>现在我们看一下 <code class="docutils literal notranslate"><span class="pre">VkSubmitInfo</span></code> ，其定义如下：</p>
</section>
<section id="vksubmitinfo">
<h3>VkSubmitInfo<a class="headerlink" href="#vksubmitinfo" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkSubmitInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">                </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                    </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                       </span><span class="n">waitSemaphoreCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkSemaphore</span><span class="o">*</span><span class="w">             </span><span class="n">pWaitSemaphores</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkPipelineStageFlags</span><span class="o">*</span><span class="w">    </span><span class="n">pWaitDstStageMask</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                       </span><span class="n">commandBufferCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkCommandBuffer</span><span class="o">*</span><span class="w">         </span><span class="n">pCommandBuffers</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                       </span><span class="n">signalSemaphoreCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkSemaphore</span><span class="o">*</span><span class="w">             </span><span class="n">pSignalSemaphores</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkSubmitInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_SUBMIT_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">waitSemaphoreCount</span> 等待的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pWaitSemaphores</span> 等待的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 。该指针所指向的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 数量不能小于 <code class="docutils literal notranslate"><span class="pre">waitSemaphoreCount</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pWaitDstStageMask</span> 表示 <code class="docutils literal notranslate"><span class="pre">pWaitSemaphores</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 在哪些 <code class="docutils literal notranslate"><span class="pre">管线状态</span></code> 处等待 <code class="docutils literal notranslate"><span class="pre">旗语</span></code>。该指针所指向的 <code class="docutils literal notranslate"><span class="pre">管线状态</span></code> 数量不能小于 <code class="docutils literal notranslate"><span class="pre">waitSemaphoreCount</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">commandBufferCount</span> 表示要推送的指令缓存数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCommandBuffers</span> 表示要推送的指令缓存。该指针所指向的指令缓存数量不能小于 <code class="docutils literal notranslate"><span class="pre">commandBufferCount</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">signalSemaphoreCount</span> 表示要激活的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pSignalSemaphores</span> 表示要激活的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code>  。该指针所指向的 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 数量不能小于 <code class="docutils literal notranslate"><span class="pre">signalSemaphoreCount</span></code> 。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">VkSemaphore</p>
<p>表示 <code class="docutils literal notranslate"><span class="pre">旗语</span></code> 用于在设备队列之间进行同步的 <code class="docutils literal notranslate"><span class="pre">原语</span></code> （对象）。这将会在之后的详细章节展开说明。目前可忽略。</p>
</div>
<p>这样，我们就可以将指令推送至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 进行执行了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkQueue</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前从</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">中创建</span><span class="err">，</span><span class="n">支持图形功能的设备队列</span><span class="p">;</span>

<span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">command_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前分配并完成指令记录的一级</span><span class="p">(</span><span class="n">主要级</span><span class="p">)</span><span class="n">指令缓存</span><span class="p">;</span>

<span class="n">VkSubmitInfo</span><span class="w"> </span><span class="n">submit_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_SUBMIT_INFO</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">waitSemaphoreCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pWaitSemaphores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pWaitDstStageMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">commandBufferCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pCommandBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_buffer</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">signalSemaphoreCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pSignalSemaphores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkQueueSubmit</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">submit_info</span><span class="p">,</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;该批次指令缓存推送失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们知道 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 是一个高并行的设备，当指令缓存通过 <code class="docutils literal notranslate"><span class="pre">vkQueueSubmit</span></code> 推送至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 后其中记录的指令将会并行的执行。换句话说，当 <code class="docutils literal notranslate"><span class="pre">vkQueueSubmit</span></code> 返回后，其并 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">不</span> 代表推送的指令缓存已经执行完成，而是表示这批指令缓存已经推送到了 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> ，但对于这批指令缓存
何时执行完成，我们是不知道的，这时我们就需要等待推送的指令完成。</p>
</section>
</section>
<section id="id45">
<h2>等待指令缓存执行完成<a class="headerlink" href="#id45" title="Link to this heading">#</a></h2>
<p>有三种方式用于等待指令缓存执行完成：</p>
<ol class="arabic simple">
<li><p>等待整个 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备执行完所有的任务（ <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 处于闲置状态）。如果所有任务都执行完成，说明推送的所有指令缓存也执行完成。通过 <code class="docutils literal notranslate"><span class="pre">vkDeviceWaitIdle(...)</span></code> 进行等待。</p></li>
<li><p>等待指令缓存推送的设备队列执行完所有的任务（ 设备队列处于闲置状态）。通过 <code class="docutils literal notranslate"><span class="pre">vkQueueWaitIdle(...)</span></code> 进行等待。</p></li>
<li><p>仅仅等待该批次推送的指令缓存执行完成，而不是等待整个 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 处于闲置状态。通过 <code class="docutils literal notranslate"><span class="pre">VkFence</span></code> （栏栅）进行等待。</p></li>
</ol>
<p>由此可见第 <code class="docutils literal notranslate"><span class="pre">2</span></code> 种方式比第 <code class="docutils literal notranslate"><span class="pre">1</span></code> 种方式高效，第 <code class="docutils literal notranslate"><span class="pre">3</span></code> 种方式比第 <code class="docutils literal notranslate"><span class="pre">2</span></code> 种方式高效。</p>
<p>这里我们先来看看 <code class="docutils literal notranslate"><span class="pre">vkDeviceWaitIdle</span></code> ，其定义如下：</p>
<section id="vkdevicewaitidle">
<h3>vkDeviceWaitIdle<a class="headerlink" href="#vkdevicewaitidle" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkDeviceWaitIdle</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 等待的目标设备。</p></li>
</ul>
<p>当执行该函数后 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 端的执行将会卡住（阻塞）直到 <code class="docutils literal notranslate"><span class="pre">device</span></code> 上的所有任务执行完成成为闲置状态，并返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。</p>
<p>这非常简单直接，直接调用 <code class="docutils literal notranslate"><span class="pre">vkDeviceWaitIdle</span></code> 并指定等待的目标设备句柄即可：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建的设备</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkDeviceWaitIdle</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">// 设备上的所有任务执行完成，处于闲置状态</span>
<span class="p">}</span>
</pre></div>
</div>
<p>接下来我们来看看 <code class="docutils literal notranslate"><span class="pre">vkQueueWaitIdle</span></code> ，其定义如下：</p>
</section>
<section id="vkqueuewaitidle">
<h3>vkQueueWaitIdle<a class="headerlink" href="#vkqueuewaitidle" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkQueueWaitIdle</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkQueue</span><span class="w">                                     </span><span class="n">queue</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queue</span> 等待的目标设备队列。</p></li>
</ul>
<p>当执行该函数后 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 端的执行将会卡住（阻塞）直到 <code class="docutils literal notranslate"><span class="pre">device</span></code> 上的所有任务执行完成成为闲置状态，并返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。</p>
<p>与 <code class="docutils literal notranslate"><span class="pre">vkDeviceWaitIdle</span></code> 类似，直接调用 <code class="docutils literal notranslate"><span class="pre">vkQueueWaitIdle</span></code> 并指定等待的目标设备队列句柄即可：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkQueue</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前指令缓存推送的目标设备队列</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkQueueWaitIdle</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">// 设备队列上的所有任务执行完成，处于闲置状态</span>
<span class="p">}</span>
</pre></div>
</div>
<p>接下来我们来说明一下第 <code class="docutils literal notranslate"><span class="pre">3</span></code> 种方式： <code class="docutils literal notranslate"><span class="pre">栏栅</span></code> 。</p>
</section>
<section id="id46">
<h3>栏栅<a class="headerlink" href="#id46" title="Link to this heading">#</a></h3>
<p>在使用 <a class="reference internal" href="#vkqueuesubmit"><span class="std std-ref">vkQueueSubmit</span></a> 推送指令缓存时可以指定一个 <code class="docutils literal notranslate"><span class="pre">VkFence</span></code> （栏栅）句柄。该句柄用于表示该批次推送的指令缓存的执行状态。</p>
<p>栏栅只有两个状态：</p>
<ul class="simple">
<li><p>未激活态</p></li>
<li><p>激活态</p></li>
</ul>
<p>一般栏栅在创建完成之后，初始状态为未激活态。当栏栅处于未激活态时，表示之前推送的指令缓存并未执行完成，当推送的指令缓存全部执行结束之后， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 会将栏栅从未激活态转变成激活态。</p>
<p>这样就可以通过查看栏栅是否处于激活态就可以知道推送的指令缓存是否执行结束。</p>
<p>要想指定一个栏栅我们需要先通过 <code class="docutils literal notranslate"><span class="pre">vkCreateFence</span></code> 函数创建一个，其定义如下：</p>
<section id="vkcreatefence">
<h4>vkCreateFence<a class="headerlink" href="#vkcreatefence" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateFence</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkFenceCreateInfo</span><span class="o">*</span><span class="w">                    </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkFence</span><span class="o">*</span><span class="w">                                    </span><span class="n">pFence</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 栏栅的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pFence</span> 创建的栏栅。</p></li>
</ul>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkFenceCreateInfo</span></code> 定义如下：</p>
</section>
<section id="vkfencecreateinfo">
<h4>VkFenceCreateInfo<a class="headerlink" href="#vkfencecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkFenceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">       </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">           </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkFenceCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkFenceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值， <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 用于指定该栏栅的初始状态。如果为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 表示使用默认 <code class="docutils literal notranslate"><span class="pre">未激活</span></code> 为初始状态。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkFenceCreateFlags</span></code> 可用值如下：</p>
</section>
<section id="vkfencecreateflags">
<h4>VkFenceCreateFlags<a class="headerlink" href="#vkfencecreateflags" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkFenceCreateFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_FENCE_CREATE_SIGNALED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkFenceCreateFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_FENCE_CREATE_SIGNALED_BIT</span> 表示栏栅初始化为 <code class="docutils literal notranslate"><span class="pre">激活</span></code> 状态。</p></li>
</ul>
<p>如没有特殊需求 <code class="docutils literal notranslate"><span class="pre">VkFenceCreateFlagBits::VK_FENCE_CREATE_SIGNALED_BIT</span></code> 一般不使用。</p>
<p>这样我们就能够创建栏栅了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建的设备</span><span class="p">;</span>

<span class="n">VkFenceCreateInfo</span><span class="w"> </span><span class="n">fence_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">fence_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</span><span class="p">;</span>
<span class="n">fence_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">fence_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 初始状态为 【未激活】状态</span>

<span class="n">VkFence</span><span class="w"> </span><span class="n">fence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateFence</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fence_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fence</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;栏栅创建失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>之后在推送指令缓存时就可以使用此栏栅了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkQueue</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前从</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="n">中创建</span><span class="err">，</span><span class="n">支持图形功能的设备队列</span><span class="p">;</span>
<span class="n">VkFence</span><span class="w"> </span><span class="n">fence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建栏栅</span><span class="p">;</span>

<span class="n">VkCommandBuffer</span><span class="w"> </span><span class="n">command_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前分配并完成指令记录的一级</span><span class="p">(</span><span class="n">主要级</span><span class="p">)</span><span class="n">指令缓存</span><span class="p">;</span>

<span class="n">VkSubmitInfo</span><span class="w"> </span><span class="n">submit_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_SUBMIT_INFO</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">waitSemaphoreCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pWaitSemaphores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pWaitDstStageMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">commandBufferCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pCommandBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">command_buffer</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">signalSemaphoreCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">submit_info</span><span class="p">.</span><span class="n">pSignalSemaphores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkQueueSubmit</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">submit_info</span><span class="p">,</span><span class="w"> </span><span class="n">fence</span><span class="cm">/*指定栏栅*/</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;该批次指令缓存推送失败&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id47">
<h4>等待栏栅<a class="headerlink" href="#id47" title="Link to this heading">#</a></h4>
<p>当使用 <a class="reference internal" href="#vkqueuesubmit"><span class="std std-ref">vkQueueSubmit</span></a> 推送指令缓存时指定栏栅后，我们就可以通过等待栏栅从未激活态变为激活态，用于判断推送的指令缓存是否执行完成。我们可以通过 <code class="docutils literal notranslate"><span class="pre">vkWaitForFences(...)</span></code> 函数等待栏栅被激活，其定义如下：</p>
<section id="vkwaitforfences">
<h5>vkWaitForFences<a class="headerlink" href="#vkwaitforfences" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkWaitForFences</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">fenceCount</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkFence</span><span class="o">*</span><span class="w">                              </span><span class="n">pFences</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBool32</span><span class="w">                                    </span><span class="n">waitAll</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w">                                    </span><span class="n">timeout</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">fenceCount</span> 等待的栏栅数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pFences</span> 等待的栏栅。该指针所指向的栏栅数量不能小于 <code class="docutils literal notranslate"><span class="pre">fenceCount</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">waitAll</span> 是否等待 <code class="docutils literal notranslate"><span class="pre">pFences</span></code> 中的所有栏栅执行结束。如果为 <code class="docutils literal notranslate"><span class="pre">VK_TRUE</span></code> 的话则会阻塞该函数直到 <code class="docutils literal notranslate"><span class="pre">pFences</span></code> 所有的栏栅被激活，否则 <code class="docutils literal notranslate"><span class="pre">pFences</span></code> 中只要有 <code class="docutils literal notranslate"><span class="pre">1</span></code> 个栏栅被激活，该函数将接触阻塞。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">timeout</span> 是该函数阻塞的时间。单位为 <code class="docutils literal notranslate"><span class="pre">纳秒</span></code> 。如果该函数等待 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 纳秒之后对应的栏栅没有被激活的话，将接触阻塞，并返回 <code class="docutils literal notranslate"><span class="pre">VkResult::VK_TIMEOUT</span></code> 。否则返回 <code class="docutils literal notranslate"><span class="pre">VkResult::VK_SUCCESS</span></code> 表示栏栅被激活。</p></li>
</ul>
<p>如果 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ，则该函数不会进行任何等待而直接返回，并直接返回栏栅的当前状态。</p>
<p>这样，我们就可以等待推送的指令缓存执行结束：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkFence</span><span class="w"> </span><span class="n">fence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前创建栏栅</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkQueueSubmit</span><span class="p">(...,</span><span class="w"> </span><span class="n">fence</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;该批次指令缓存推送失败&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_ERROR_UNKNOWN</span><span class="p">;</span>

<span class="k">do</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkWaitForFences</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fence</span><span class="p">,</span><span class="w"> </span><span class="n">VK_TRUE</span><span class="p">,</span><span class="w"> </span><span class="mi">3000000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 等待 3 毫秒</span>
<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_TIMEOUT</span><span class="p">)</span><span class="w"> </span><span class="c1">// 如果 fence 没有被激活，继续等待</span>

<span class="p">...</span><span class="w"> </span><span class="c1">// fence 被激活，推送的指令缓存执行结束</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
<div class="related-pages">
    <a class="next-page" href="Instance.html">
        <div class="page-info">
            <div class="context">
                <span>Next</span>
            </div>
            <div class="title">最初之物 VkInstance</div>
        </div>
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
    </a>
    <a class="prev-page" href="EnvironmentalConfig.html">
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
        <div class="page-info">
            <div class="context">
                <span>Previous</span>
            </div>
            
            <div class="title">环境配置</div>
            
        </div>
    </a>
</div>
<div class="bottom-of-page">
    <div class="left-details">
        <div class="copyright">
            Copyright &#169; 2023-2024, FuXii
        </div>
        Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
        
        <a href="https://github.com/pradyunsg/furo">Furo</a>
        
        <div>
             <span id="busuanzi_container_site_uv" style='display:none'>site view <span
                    id="busuanzi_value_site_uv"></span></span> 
        </div>
    </div>
    <div class="right-details">
        <div class="icons">
            <a class="muted-link " href="https://github.com/FuXiii/Essentials.of.Vulkan" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
            
        </div>
        <div class="left-details">
             <span id="busuanzi_container_page_pv" style='display:none'>page view <span
                    id="busuanzi_value_page_pv"></span></span> 
        </div>
    </div>
</div>

      </footer>
    </div>
    <aside class="toc-drawer">
      

<div class="toc-sticky toc-scroll" style="width: 500px;">
    <div class="toc-title-container" style="width: 500px;">
        <span class="toc-title" style="width: 500px;">
            On this page
        </span>
    </div>
    <div class="toc-tree-container" style="width: 500px;">
        <div class="toc-tree" style="width: 500px;">
            <ul>
<li><a class="reference internal" href="#">纵览</a><ul>
<li><a class="reference internal" href="#vulkan">Vulkan 能为我们做什么</a></li>
<li><a class="reference internal" href="#id3">Vulkan 的句柄</a><ul>
<li><a class="reference internal" href="#dispatchable">Dispatchable</a></li>
<li><a class="reference internal" href="#non-dispatchable">Non-dispatchable</a></li>
<li><a class="reference internal" href="#id4">句柄的使用</a></li>
<li><a class="reference internal" href="#id5">句柄初始化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">Vulkan 的接口</a></li>
<li><a class="reference internal" href="#id7">获取 Vulkan 接口</a><ul>
<li><a class="reference internal" href="#id8">加载 Vulkan 动态库</a></li>
<li><a class="reference internal" href="#id9">Vulkan 函数分类</a></li>
<li><a class="reference internal" href="#vkgetinstanceprocaddr">vkGetInstanceProcAddr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vulkan-vkinstance">Vulkan 最初之物 VkInstance</a><ul>
<li><a class="reference internal" href="#vkinstance">创建 VkInstance</a><ul>
<li><a class="reference internal" href="#vkcreateinstance">vkCreateInstance</a></li>
<li><a class="reference internal" href="#vkinstancecreateinfo">VkInstanceCreateInfo</a></li>
<li><a class="reference internal" href="#vkapplicationinfo">VkApplicationInfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id10">获取支持的 Vulkan 版本</a><ul>
<li><a class="reference internal" href="#vkenumerateinstanceversion">vkEnumerateInstanceVersion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">获取物理硬件设备</a><ul>
<li><a class="reference internal" href="#vkenumeratephysicaldevices">vkEnumeratePhysicalDevices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">获取物理设备属性</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldeviceproperties">vkGetPhysicalDeviceProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldeviceproperties">VkPhysicalDeviceProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldevicetype">VkPhysicalDeviceType</a></li>
</ul>
</li>
<li><a class="reference internal" href="#devicequeue">设备队列</a><ul>
<li><a class="reference internal" href="#id14">获取设备队列（族）信息</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldevicequeuefamilyproperties">vkGetPhysicalDeviceQueueFamilyProperties</a></li>
<li><a class="reference internal" href="#vkqueuefamilyproperties">VkQueueFamilyProperties</a></li>
<li><a class="reference internal" href="#vkqueueflags">VkQueueFlags</a></li>
<li><a class="reference internal" href="#vkqueueflagbits">VkQueueFlagBits</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id15">逻辑设备</a><ul>
<li><a class="reference internal" href="#id16">创建逻辑设备</a><ul>
<li><a class="reference internal" href="#vkcreatedevice">vkCreateDevice</a></li>
<li><a class="reference internal" href="#vkdevicecreateinfo">VkDeviceCreateInfo</a></li>
<li><a class="reference internal" href="#vkdevicequeuecreateinfo">VkDeviceQueueCreateInfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#device">获取 Device 域函数</a><ul>
<li><a class="reference internal" href="#vkgetdeviceprocaddr">vkGetDeviceProcAddr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">获取设备队列</a><ul>
<li><a class="reference internal" href="#vkgetdevicequeue">vkGetDeviceQueue</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory">内存</a><ul>
<li><a class="reference internal" href="#id19">内存分类</a></li>
<li><a class="reference internal" href="#id20">获取 Vulkan 支持的内存信息</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldevicememoryproperties">vkGetPhysicalDeviceMemoryProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldevicememoryproperties">VkPhysicalDeviceMemoryProperties</a></li>
<li><a class="reference internal" href="#vkmemorytype">VkMemoryType</a></li>
<li><a class="reference internal" href="#vkmemorypropertyflagbits">VkMemoryPropertyFlagBits</a></li>
<li><a class="reference internal" href="#vkmemoryheap">VkMemoryHeap</a></li>
<li><a class="reference internal" href="#vkdevicesize">VkDeviceSize</a></li>
<li><a class="reference internal" href="#vkmemoryheapflagbits">VkMemoryHeapFlagBits</a></li>
<li><a class="reference internal" href="#id21">VkPhysicalDeviceMemoryProperties 结构图</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">内存管理</a><ul>
<li><a class="reference internal" href="#id23">分配内存</a><ul>
<li><a class="reference internal" href="#vkmemoryallocateinfo">VkMemoryAllocateInfo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">回收内存</a><ul>
<li><a class="reference internal" href="#vkfreememory">vkFreeMemory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id26">资源</a><ul>
<li><a class="reference internal" href="#id27">缓存</a><ul>
<li><a class="reference internal" href="#vkcreatebuffer">vkCreateBuffer</a></li>
<li><a class="reference internal" href="#vkbuffercreateinfo">VkBufferCreateInfo</a></li>
<li><a class="reference internal" href="#vkbufferusageflags">VkBufferUsageFlags</a></li>
<li><a class="reference internal" href="#vksharingmode">VkSharingMode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#image">图片</a><ul>
<li><a class="reference internal" href="#vkcreateimage">vkCreateImage</a></li>
<li><a class="reference internal" href="#vkimagecreateinfo">VkImageCreateInfo</a></li>
<li><a class="reference internal" href="#vkimagetype">VkImageType</a></li>
<li><a class="reference internal" href="#vkformat">VkFormat</a></li>
<li><a class="reference internal" href="#vkextent3d">VkExtent3D</a></li>
<li><a class="reference internal" href="#vksamplecountflagbits">VkSampleCountFlagBits</a></li>
<li><a class="reference internal" href="#vkimagetiling">VkImageTiling</a></li>
<li><a class="reference internal" href="#vkimageusageflags">VkImageUsageFlags</a></li>
<li><a class="reference internal" href="#vkimagelayout">VkImageLayout</a></li>
<li><a class="reference internal" href="#id29">VkImageCreateInfo 其他参数和综述</a><ul>
<li><a class="reference internal" href="#id30">综述</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id31">图片视图</a><ul>
<li><a class="reference internal" href="#vkcreateimageview">vkCreateImageView</a></li>
<li><a class="reference internal" href="#vkimageviewcreateinfo">VkImageViewCreateInfo</a></li>
<li><a class="reference internal" href="#vkimageviewtype">VkImageViewType</a></li>
<li><a class="reference internal" href="#vkcomponentmapping">VkComponentMapping</a><ul>
<li><a class="reference internal" href="#vkcomponentswizzle">VkComponentSwizzle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vkimagesubresourcerange">VkImageSubresourceRange</a><ul>
<li><a class="reference internal" href="#vkimageaspectflags">VkImageAspectFlags</a></li>
<li><a class="reference internal" href="#id32">解析范围</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id33">资源与内存</a><ul>
<li><a class="reference internal" href="#vkgetbuffermemoryrequirements">vkGetBufferMemoryRequirements</a></li>
<li><a class="reference internal" href="#vkgetimagememoryrequirements">vkGetImageMemoryRequirements</a></li>
<li><a class="reference internal" href="#vkmemoryrequirements">VkMemoryRequirements</a><ul>
<li><a class="reference internal" href="#memorytypebits">memoryTypeBits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">资源与内存的绑定</a><ul>
<li><a class="reference internal" href="#vkbindbuffermemory">vkBindBufferMemory</a></li>
<li><a class="reference internal" href="#vkbindimagememory">vkBindImageMemory</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id35">数据传输</a><ul>
<li><a class="reference internal" href="#cpu">通过CPU向内存中传输数据</a><ul>
<li><a class="reference internal" href="#vkmapmemory">vkMapMemory</a></li>
<li><a class="reference internal" href="#vkunmapmemory">vkUnmapMemory</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gpu">通过GPU向内存中传输数据</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id36">指令</a></li>
<li><a class="reference internal" href="#id37">指令缓存</a></li>
<li><a class="reference internal" href="#id38">指令缓存池</a><ul>
<li><a class="reference internal" href="#vkcreatecommandpool">vkCreateCommandPool</a></li>
<li><a class="reference internal" href="#vkcommandpoolcreateinfo">VkCommandPoolCreateInfo</a></li>
<li><a class="reference internal" href="#vkcommandpoolcreateflagbits">VkCommandPoolCreateFlagBits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id39">分配指令缓存</a><ul>
<li><a class="reference internal" href="#vkcommandbufferallocateinfo">VkCommandBufferAllocateInfo</a></li>
<li><a class="reference internal" href="#vkcommandbufferlevel">VkCommandBufferLevel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id40">开启指令缓存</a><ul>
<li><a class="reference internal" href="#vkbegincommandbuffer">vkBeginCommandBuffer</a></li>
<li><a class="reference internal" href="#vkcommandbufferbegininfo">VkCommandBufferBeginInfo</a></li>
<li><a class="reference internal" href="#vkcommandbufferusageflags">VkCommandBufferUsageFlags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id41">指令记录</a></li>
<li><a class="reference internal" href="#id42">结束指令缓存</a><ul>
<li><a class="reference internal" href="#vkendcommandbuffer">vkEndCommandBuffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id43">指令推送</a><ul>
<li><a class="reference internal" href="#vkqueuesubmit">vkQueueSubmit</a></li>
<li><a class="reference internal" href="#vksubmitinfo">VkSubmitInfo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id45">等待指令缓存执行完成</a><ul>
<li><a class="reference internal" href="#vkdevicewaitidle">vkDeviceWaitIdle</a></li>
<li><a class="reference internal" href="#vkqueuewaitidle">vkQueueWaitIdle</a></li>
<li><a class="reference internal" href="#id46">栏栅</a><ul>
<li><a class="reference internal" href="#vkcreatefence">vkCreateFence</a></li>
<li><a class="reference internal" href="#vkfencecreateinfo">VkFenceCreateInfo</a></li>
<li><a class="reference internal" href="#vkfencecreateflags">VkFenceCreateFlags</a></li>
<li><a class="reference internal" href="#id47">等待栏栅</a><ul>
<li><a class="reference internal" href="#vkwaitforfences">vkWaitForFences</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
    </div>
</div>


    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=7d86a446"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/tabs.js?v=3ee01567"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/mermaid@10.2.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </body>
</html>