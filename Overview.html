<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="genindex.html" /><link rel="search" title="搜索" href="search.html" /><link rel="next" title="文献" href="Literature/index.html" /><link rel="prev" title="环境配置" href="EnvironmentalConfig.html" />
        <link rel="canonical" href="https://github.com/FuXiii/Essentials.of.Vulkan/Overview.html" />

    <link rel="shortcut icon" href="_static/VulkanLogo.png"/><!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>纵览 - Vulkan入门精要</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b20cc3f5" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Vulkan入门精要</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
<div class="sidebar-sticky" ><a class="sidebar-brand" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/Vulkan.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Vulkan入门精要</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">入门精要</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="StartFromVulkanSDK.html">开始于 Vulkan SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="EnvironmentalConfig.html">环境配置</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">纵览</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">文献翻译</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="Literature/index.html">文献</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 文献</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Literature/VulkanRayTracingFinalSpecificationRelease.html">Vulkan 光线追踪最终标准发布</a></li>
<li class="toctree-l2"><a class="reference internal" href="Literature/Vulkan-GuideRayTracing.html">光线追踪</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/NVIDIAVulkanRayTracingTutorial.html">NVIDIA Vulkan 光线追踪教程</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of NVIDIA Vulkan 光线追踪教程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/JitterCamera.html">相机抖动抗锯齿教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/AnyHitShaders.html">任意命中着色器（Any Hit Shaders）教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Instances.html">实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Reflections.html">反射</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/MultipleClosestHitShaders.html">多重最近命中着色器</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Animation.html">动态更新</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Literature/vk_mini_path_tracer.html">Vulkan迷你路径追踪</a></li>
<li class="toctree-l2"><a class="reference internal" href="Literature/TheRTXShaderBindingTableThreeWays.html">RTX 着色器绑定表的三种方式</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">随笔</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="InformalEssay/index.html">Vulkan 标准</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Vulkan 标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VulkanKHRRayTracing.html">Vulkan KHR 光线追踪标准</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Vulkan KHR 光线追踪标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_acceleration_structure.html">VK_KHR_acceleration_structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_ray_tracing_pipeline.html">VK_KHR_ray_tracing_pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_deferred_host_operations.html">VK_KHR_deferred_host_operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/ShaderBindingTable.html">着色器绑定表</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="InformalEssay/VK_KHR_buffer_device_address.html">VK_KHR_buffer_device_address</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="InformalEssay/VulkanForAndroid.html">Android 平台适配</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">工程应用</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="Application/index.html">应用</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 应用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Application/VolumetricCloud.html">体积云</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUImGui.html">WebGPU ImGui</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUHelloTriangle.html">WebGPU Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUShaderCompiler.html">WebGPU Shader Compiler</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">更新日志</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Changelog.html">更新日志</a></li>
</ul>

</div>
</div>

</div>

    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/FuXiii/Essentials.of.Vulkan/edit/main/source/Overview.rst" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="id1">
<h1>纵览<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header sd-bg-muted sd-bg-text-muted">
<span class="sd-summary-icon"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-history" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M1.643 3.143L.427 1.927A.25.25 0 000 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 00.177-.427L2.715 4.215a6.5 6.5 0 11-1.18 4.458.75.75 0 10-1.493.154 8.001 8.001 0 101.6-5.684zM7.75 4a.75.75 0 01.75.75v2.992l2.028.812a.75.75 0 01-.557 1.392l-2.5-1A.75.75 0 017 8.25v-3.5A.75.75 0 017.75 4z"></path></svg></span>更新记录<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<ul class="simple">
<li><p class="sd-card-text">2023/5/15 增加该文章</p></li>
<li><p class="sd-card-text">2023/5/16 将 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 章节的内容移动至单独 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 文章中</p></li>
<li><p class="sd-card-text">2023/6/23 更新该文档</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">能为我们做什么</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">接口</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">最初之物</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 增加 <code class="docutils literal notranslate"><span class="pre">创建</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 更新 <code class="docutils literal notranslate"><span class="pre">创建</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">VkApplicationInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">获取支持的</span> <span class="pre">Vulkan</span> <span class="pre">版本</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">获取支持的</span> <span class="pre">Vulkan</span> <span class="pre">版本</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的接口</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">获取物理硬件设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节并增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 声明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/27 更新 <code class="docutils literal notranslate"><span class="pre">获取物理硬件设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/27 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节，增加全局函数的条目</p></li>
<li><p class="sd-card-text">2023/6/27 增加 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">获取物理设备属性</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 更新 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceType</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">句柄</span></code> 描述</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">设备队列</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 更新 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">稀疏</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列信息</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFlagBits</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 更新 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的静态库</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">逻辑设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">创建逻辑设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 更新 <code class="docutils literal notranslate"><span class="pre">获取设备队列（族）信息</span></code> 章节。修改 <code class="docutils literal notranslate"><span class="pre">例程</span></code> 的错误</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列（族）信息</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Device</span> <span class="pre">域函数</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数特殊性</span></code> 说明，修正分类说明，删除 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">内存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">内存分类</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">分配内存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节中的 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数特殊性</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/9 更新 <code class="docutils literal notranslate"><span class="pre">分配内存</span></code> 章节更名为 <code class="docutils literal notranslate"><span class="pre">分配缓存</span></code></p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 修正 <code class="docutils literal notranslate"><span class="pre">内存分类</span></code> 章节中的一些错误，优化调理，增加新的说明。</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span> <span class="pre">结构图</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/10 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数例程</p></li>
</ul>
</div>
</details><p>由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 比较复杂，为了更好的入门 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，还是大致过一遍 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的核心思路，这对以后的学习很有帮助。</p>
<section id="vulkan">
<h2>Vulkan 能为我们做什么<a class="headerlink" href="#vulkan" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 最主要的任务就是为我们提供了 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 并行计算的接口。是的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 仅仅只是规定了一套接口，其并没有接口的具体实现，而实现是需要硬件厂商自己适配实现，所以市面上并不是所有硬件设备都支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 。像 <code class="docutils literal notranslate"><span class="pre">NVIDIA</span></code> 、 <code class="docutils literal notranslate"><span class="pre">AMD</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Intel</span></code> 等国际大厂基本提供了完整的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code>
核心标准接口。而像国产的后起之秀 <a class="reference external" href="https://www.mthreads.com/">摩尔线程</a> 也在努力适配 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准（ <span class="sd-sphinx-override sd-badge sd-bg-warning sd-bg-text-warning">景嘉微你要加油啊</span>）。由于标准的实现都是自家的，所以每家厂商都可以根据自家设备的特点进行优化和扩展，这样在提供 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心功能的基础上也推出了自家的扩展功能，而扩展功能往往是该设备的卖点（比如硬件实时光线追踪扩展功能）。</p>
<p>而在使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 时，相比于标准，我们往往更关注于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 所提供的功能，主要的功能如下：</p>
<ul class="simple">
<li><p>光栅化渲染</p></li>
<li><p>实时光线追踪</p></li>
<li><p>视频编解码</p></li>
<li><p>（通用）并行计算</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">光栅化渲染</span></code> 应该是最主要的功能了（同时也是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的核心功能）。该章节也主要以 <code class="docutils literal notranslate"><span class="pre">光栅化渲染</span></code> 为核心进行纵览。</p>
</section>
<section id="id3">
<h2>Vulkan 的接口<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的接口，也就是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数，最开始是使用 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言发布的，有些繁琐，后来推出了 <code class="docutils literal notranslate"><span class="pre">C++</span></code> 版本的接口，现在 <code class="docutils literal notranslate"><span class="pre">Python</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Java</span></code> 和 <code class="docutils literal notranslate"><span class="pre">C#</span></code> 等高级语言也陆续支持开发 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的家族也在慢慢壮大。</p>
<p>本教程主要是用最原始的 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言版本进行讲解。</p>
</section>
<section id="id4">
<h2>获取 Vulkan 接口<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 只是一套标准，具体的实现都在硬件驱动中，为了能够使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 驱动硬件设备，我们需要获取驱动中 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准实现的接口。</p>
<section id="id5">
<h3>加载 Vulkan 动态库<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中提供了 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 进行 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准实现接口的获取。根据前文介绍我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 对应着 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库，所以我们第一步就是加载 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库。</p>
<div class="note admonition">
<p class="admonition-title">Vulkan 的动态库</p>
<p><code class="docutils literal notranslate"><span class="pre">Windows</span></code> 操作系统上 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库为 <code class="docutils literal notranslate"><span class="pre">vulkan-1.dll</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 上的为 <code class="docutils literal notranslate"><span class="pre">libvulkan.so.1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">libvulkan.so</span></code> 。</p>
</div>
<div class="hint admonition">
<p class="admonition-title">Vulkan 的静态库</p>
<p>为什么不是用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的静态库呢？最主要的原因来源于 <a class="reference external" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderApplicationInterface.md#static-linking">Vulkan Loader 的 Static Linking</a> 文档：</p>
<blockquote>
<div><p>In previous versions of the loader, it was possible to statically link the loader. This was removed and is no longer possible. The decision to remove static linking was because of changes to the driver which made older applications that statically linked unable to find newer drivers.</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 之前的版本中，是可以静态链接 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 的。这将会在不久的将来移除。这是由于之前静态链接的老程序无法找到新的驱动。</p>
</div></blockquote>
<p>此外静态链接有如下问题：</p>
<ul class="simple">
<li><p>除非重编译链接原工程否则永远得不到新 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 内容</p></li>
<li><p>包含的两个库可能会链接了不同版本的 <code class="docutils literal notranslate"><span class="pre">Loader</span></code></p></li>
</ul>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-0">
Windows 加载</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Windows.h&gt;</span>

<span class="n">HMODULE</span><span class="w"> </span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">&quot;vulkan-1.dll&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-1">
Linux 加载</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dlfcn.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libvulkan.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RTLD_NOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTLD_LOCAL</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">library</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libvulkan.so&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RTLD_NOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTLD_LOCAL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id6">
<h3>Vulkan 函数分类<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>之后我们就可以从加载的动态库中获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的函数了，但是在获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数前我们需要先介绍一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中函数的分类：</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Instance 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 进行交互。主要是获取一些与设备不相关与环境相关的函数。</dt><dd><ul>
<li><dl class="simple">
<dt><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">全局函数</span> 在 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数中有几个函数为全局函数。所谓全局函数是指任何驱动都需要实现的接口，并且用户可直接无条件获取其实现。全局函数如下：</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceExtensionProperties</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceLayerProperties</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">PhysicalDevice 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 进行交互。主要是一些获取硬件设备相关信息的函数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Device 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 进行交互。主要是获取一些与硬件设备相关的功能函数。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">PhysicalDevice 域函数特殊性</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 文档中 <a class="reference external" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#_extending_physical_device_core_functionality">4.1.1 Extending Physical Device Core Functionality</a> 中有相关 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 的描述。</p>
<blockquote>
<div><p>当物理设备支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本等于或高于对应函数发布时的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本的话，用户可以使用对应函数。换句话就是，如果在创建 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境时（创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 时）使用了较低版本，但是物理设备支持的版本高于此版本（ <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> ），并且 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 在物理设备支持的高版本中被定义并实现，则可以获取高版本的 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 使用。</p>
</div></blockquote>
<p>一般可以认为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span></code> 域函数为特殊的 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数。</p>
</div>
<div class="note admonition">
<p class="admonition-title">vkGetInstanceProcAddr 和 Device 域函数</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中并没有禁止用户使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 获得 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数，但这是不推荐的，当有多个硬件设备时会造成模棱两可的函数获取。比如电脑上插着两个显卡，一个是摩尔线程的，一个是景嘉微的，这两个设备都支持绘制函数 <code class="docutils literal notranslate"><span class="pre">vkCmdDraw</span></code> 函数 ，但是到底获取的是哪个设备的实现是由 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 定义的，用户并不能知道返回的函数是哪个设备的实现。</p>
</div>
</section>
<section id="vkgetinstanceprocaddr">
<h3>vkGetInstanceProcAddr<a class="headerlink" href="#vkgetinstanceprocaddr" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中获取 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数，提供了统一的 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数获取接口，如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">VKAPI_PTR</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_vkVoidFunction</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">PFN_vkVoidFunction</span><span class="w"> </span><span class="nf">vkGetInstanceProcAddr</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pName</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">instance</span> 获取 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 兼容的函数接口，或是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 用于获取不依赖任何 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的函数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pName</span> 获取的接口函数名称。</p></li>
</ul>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数之后就可以使用该函数获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数了。</p>
<div class="note admonition">
<p class="admonition-title">获取全局函数</p>
<p>获取全局函数时 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code></p>
</div>
<div class="note admonition">
<p class="admonition-title">PFN_{函数名}</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中，所有的接口函数都有对应的函数指针声明，命名规则为 <code class="docutils literal notranslate"><span class="pre">PFN_{函数名}</span></code> 。</p>
</div>
<div class="note admonition">
<p class="admonition-title">PFN_vkVoidFunction 与 vkGetInstanceProcAddr</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型函数指针。但是我们想获得 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中如 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 这样的函数指针，该指针并不是 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型的，而是 <code class="docutils literal notranslate"><span class="pre">PFN_vkCreateInstance</span></code> 类型的，如何从 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型获得 <code class="docutils literal notranslate"><span class="pre">PFN_vkCreateInstance</span></code> 类型呢？
在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中规定直接使用强制类型转换即可。下文有示例。</p>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-2" name="sd-tab-set-1" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-2">
Windows 获取</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="w"> </span><span class="n">vkGetInstanceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetInstanceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-3" name="sd-tab-set-1" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-3">
Linux 获取</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="w"> </span><span class="n">vkGetInstanceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetInstanceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>之后就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 获取 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域的函数了。比如获取 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数接口：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkCreateInstance</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateInstance</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">VK_NULL_HANDLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateInstance&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">VK_NULL_HANDLE</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 被定义为空或无效句柄，一般被声明为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 、 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于获取 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span></code> 域函数和 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数将会在后文有所体现。</p>
</div>
<div class="note admonition">
<p class="admonition-title">句柄</p>
<p>英文为 <code class="docutils literal notranslate"><span class="pre">Handle</span></code> ，一般认为句柄与唯一识别号作用相同，一个句柄代表一个具体对象，函数作用在句柄上，内部是在修改句柄背后对应的那个对象。</p>
</div>
</section>
</section>
<section id="vulkan-vkinstance">
<h2>Vulkan 最初之物 VkInstance<a class="headerlink" href="#vulkan-vkinstance" title="Link to this heading">#</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中首先要创建的就是 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 对象。该对象包含了用户设置的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境信息，包括使用的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的版本信息等，用于初始化 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境，并构建出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 这个繁杂的系统根基。 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;</span>

<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkInstance</span><span class="p">)</span>
</pre></div>
</div>
<p>从 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 定义可知为一个句柄，该句柄为一个结构体指针。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有的对象都是一个句柄。</p>
<p>如上 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 声明等价于:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstance_T</span><span class="o">*</span><span class="w"> </span><span class="n">VkInstance</span><span class="p">;</span>
</pre></div>
</div>
<p>也就是说 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 在底层其实是作为一个类型为 <code class="docutils literal notranslate"><span class="pre">VkInstance_T</span></code> 的指针在使用。</p>
<div class="note admonition">
<p class="admonition-title">Vulkan 中的句柄</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中并不是所有的句柄都是指针类型，也有可能是一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位的无符号整形，具体是什么类型与平台相关。但用户并不需要关心句柄的底层表达， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中对所有的句柄都做了分别进行了声明，这样用户只需要使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供的句柄声明即可。
比如声明一个未初始化的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄（对象）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
</pre></div>
</div>
</div>
<section id="vkinstance">
<h3>创建 VkInstance<a class="headerlink" href="#vkinstance" title="Link to this heading">#</a></h3>
<section id="vkcreateinstance">
<h4>vkCreateInstance<a class="headerlink" href="#vkcreateinstance" title="Link to this heading">#</a></h4>
<p>我们通过之前获取到的 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 。相关声明如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateInstance</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="w">                 </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkInstance</span><span class="o">*</span><span class="w">                                 </span><span class="n">pInstance</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 指向 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 数据结构对象，用于控制 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的创建。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pInstance</span> 创建的目标 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 结果。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 属于全局函数。</p>
</div>
<div class="note admonition">
<p class="admonition-title">pAllocator</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中创建句柄是需要设置内存分配器的，也就是 <code class="docutils literal notranslate"><span class="pre">pAllocator</span></code> ，这对于统计内存使用情况和自定义非常重要，如果没有自定义分配器的话也可以是直接传 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> ，这将会使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 内置的分配器进行分配。</p>
</div>
<p>如果创建成功将会返回 <code class="docutils literal notranslate"><span class="pre">VkResult::VK_SUCCESS</span></code> 枚举值，否则将返回错误结果枚举值。</p>
<div class="note admonition">
<p class="admonition-title">VK_SUCCESS</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中返回的大多数结果值来说，成功基本都是 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> ，否则就是失败（有极个别返回其他结果也可以算作成功，遇到再说）。还有一点需要注意的是， <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 的枚举值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_SUCCESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="n">VkResult</span><span class="p">;</span>
</pre></div>
</div>
<p>也就是，不应该出现如下判断：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="c1">// 如果此时 result 为 VK_SUCCESS ，而 VK_SUCCESS 的枚举值为 0 ，会导致判定不满足条件。</span>
<span class="p">...</span>
</pre></div>
</div>
<p>而正确的做法为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
</section>
<section id="vkinstancecreateinfo">
<h4>VkInstanceCreateInfo<a class="headerlink" href="#vkinstancecreateinfo" title="Link to this heading">#</a></h4>
<p>来看一下 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 的定义：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstanceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkInstanceCreateFlags</span><span class="w">       </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkApplicationInfo</span><span class="o">*</span><span class="w">    </span><span class="n">pApplicationInfo</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">enabledLayerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">          </span><span class="n">ppEnabledLayerNames</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">enabledExtensionCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">          </span><span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkInstanceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 是 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateFlagBits</span></code> 所表示的位域值，用于设置 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的行为。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApplicationInfo</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向应用信息结构体，用于  <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的细节设置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledLayerCount</span> 激活的 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledLayerNames</span> 指向数量为 <code class="docutils literal notranslate"><span class="pre">enabledLayerCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 字符串数组，用于设置要激活的 <code class="docutils literal notranslate"><span class="pre">layer</span></code>。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 激活 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 扩展的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 指向数量为 <code class="docutils literal notranslate"><span class="pre">enabledExtensionCount</span></code> 的扩展字符串数组，用于设置要激活的 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 扩展。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">sType 与 pNext</p>
<p>初次学习 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 时会有个疑问： <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 已经是一个结构体了为什么还有使用 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 再指定一遍结构体类型呢？而且 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 成员，为什么？</p>
<p>这就不得不说明一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的扩展模块了。随着时代的发展，类似于 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 结构体中的数据可能并不满足于技术背景，需要进行扩展，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 引入了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员，而 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span></code> 类型，这也就是说 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 可以
指向任意一个类型对象的数据地址。由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员，这样每个结构体都可以使用 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指向下一个 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的结构体，这样一个接着一个将结构体进行串链就形成了一个扩展链。</p>
<div class="mermaid">
            flowchart LR
   subgraph VkInstanceCreateInfo
      direction TB
         VkInstanceCreateInfo_sType[&quot;sType = VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO&quot;]
         VkInstanceCreateInfo_pNext[&quot;pNext&quot;]
         %%VkInstanceCreateInfo_sType-.-&gt;VkInstanceCreateInfo_pNext
   end

   subgraph VulkanSomeStructureA[&quot;Vulkan某个结构体类型A&quot;]
      direction TB
         VulkanSomeStructureA_sType[&quot;sType = VkStructureType::某个结构体A类型&quot;]
         VulkanSomeStructureA_pNext[&quot;pNext&quot;]
         %%VulkanSomeStructureA_sType-.-&gt;VulkanSomeStructureA_pNext
   end

   subgraph VulkanSomeStructureB[&quot;Vulkan某个结构体类型B&quot;]
      direction TB
         VulkanSomeStructureB_sType[&quot;sType = VkStructureType::某个结构体B类型&quot;]
         VulkanSomeStructureB_pNext[&quot;pNext&quot;]
         %%VulkanSomeStructureB_sType-.-&gt;VulkanSomeStructureB_pNext
   end

   VkInstanceCreateInfo_pNext--&gt;VulkanSomeStructureA
   VulkanSomeStructureA_pNext--&gt;VulkanSomeStructureB
   VulkanSomeStructureB_pNext--&gt;a2[&quot;...&quot;]
        </div><p>这样驱动就可以根据 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指针链遍历所有的结构体数据了，但是有一个问题 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 只是个 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 指针，驱动在获取到 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指向的地址时并不知道这个地址应该按照哪种结构体类型进行解析，这时 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 的作用就体现出来了，驱动获取该地址下的 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 的数据，这样驱动就知道如何解析此块地址了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 驱动内部可能的实现</span>

<span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">某个结构体的地址</span><span class="p">;</span>
<span class="n">VkStructureType</span><span class="w"> </span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_MAX_ENUM</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sType</span><span class="p">,</span><span class="w"> </span><span class="n">pNext</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">VkStructureType</span><span class="p">));</span>

<span class="k">switch</span><span class="p">(</span><span class="n">sType</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">case</span><span class="w"> </span><span class="no">VkStructureType</span><span class="o">::</span><span class="no">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">:</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="w"> </span><span class="n">instance_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="p">)(</span><span class="n">pNext</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">break</span><span class="p">;</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="vkapplicationinfo">
<h4>VkApplicationInfo<a class="headerlink" href="#vkapplicationinfo" title="Link to this heading">#</a></h4>
<p>目前我们只需要关注 <code class="docutils literal notranslate"><span class="pre">VkApplicationInfo</span></code> 就好，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkApplicationInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">    </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">        </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">        </span><span class="n">pApplicationName</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">applicationVersion</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">        </span><span class="n">pEngineName</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">engineVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">apiVersion</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkApplicationInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApplicationName</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向一个以空字符为结尾的 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> 字符串，用于表示用户自定义应用名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">applicationVersion</span> 一个无符号整型，用于用户自定义应用版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pEngineName</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向一个以空字符为结尾的 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> 字符串，用于表示用户自定义引擎名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">engineVersion</span> 一个无符号整型，用于用户自定义引擎版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">apiVersion</span> 应用打算使用的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的最高版本，并且忽略 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">patch</span></code> 版本。</p></li>
</ul>
<p>如果设备驱动只支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 而用户设置的 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本高于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 的话， <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">VK_ERROR_INCOMPATIBLE_DRIVER</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo::pApplicationInfo</span></code> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的话，等价于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">VK_MAKE_API_VERSION(0,1,0,0)</span></code> 也就是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 版本。</p>
</div>
<p>这里我们主要关注 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 参数，这是一个非常重要的参数。该参数指定的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本决定了应用可以使用该版本及以前的版本功能，并不能使用高于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本功能。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 如何组成 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本的，已在 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan的版本</span></code> 中有讲解。</p>
</div>
<p>现在我们就可以创建一个最简单的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 版本的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkApplicationInfo</span><span class="w"> </span><span class="n">application_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_APPLICATION_INFO</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pApplicationName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">applicationVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pEngineName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">engineVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">apiVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_MAKE_API_VERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="n">VkInstanceCreateInfo</span><span class="w"> </span><span class="n">instance_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">pApplicationInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">application_info</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">enabledLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instance</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">创建失败</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>经过如上的代码，你可以发现创建一个句柄需要填写各种各样的 <code class="docutils literal notranslate"><span class="pre">Vk{结构体名称}Info</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Vk{句柄名称}CreateInfo</span></code> 等结构体。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中各式各样的结构体占了绝大多数。给人一种：<span class="sd-sphinx-override sd-badge sd-bg-info sd-bg-text-info">来，我这样有张大表，先把表填了，我才知道接下来如何干活</span> 的感觉。</p>
</div>
<div class="hint admonition">
<p class="admonition-title">现在我们面临一个问题</p>
<p>我咋知道设备支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的哪个版本？</p>
</div>
</section>
</section>
</section>
<section id="id7">
<h2>获取支持的 Vulkan 版本<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>由于历史原因 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 标准在设计时并没有考虑到获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本，只有获取驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。在 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 中我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本有两个版本，一个是系统端支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本，一个是驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。为什么会有两个版本？</p>
<p>这是由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的函数分为不同域。系统端支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本主要是用于配置系统支持的功能、 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 和扩展，不同版本支持的功能、 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 和扩展不尽相同。驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本主要是用于配置硬件设备支持的功能和扩展，不同版本支持的功能和扩展不尽相同。</p>
<p>之后在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.1</span></code> 标准中，推出了 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 接口来获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p>
<div class="note admonition">
<p class="admonition-title">硬件设备的 Layer</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 中硬件设备是有相关的 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 功能的，但用处不大，比较鸡肋，后来 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准组将硬件设备的 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 遗弃，但对外的接口还保留着。</p>
</div>
<p>由于在支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 的实现中 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 可能由于 <code class="docutils literal notranslate"><span class="pre">VK_ERROR_INCOMPATIBLE_DRIVER</span></code> 失败返回，所以需要在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 之前获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。获取流程如下：</p>
<div class="mermaid">
            flowchart TD
   TryToGetvkEnumerateInstanceVersion[&quot;尝试获取 vkEnumerateInstanceVersion 函数接口实现&quot;]
   IsNull{&quot;是否为 NULL&quot;}
   SupportVulkan_1_0[&quot;支持Vulkan 1.0&quot;]
   SupportVulkanFromvkEnumerateInstanceVersion[&quot;支持 vkEnumerateInstanceVersion 中获得的 Vulkan 版本&quot;]

   TryToGetvkEnumerateInstanceVersion--&gt;IsNull
   IsNull--是--&gt;SupportVulkan_1_0
   IsNull--否--&gt;SupportVulkanFromvkEnumerateInstanceVersion
        </div><section id="vkenumerateinstanceversion">
<h3>vkEnumerateInstanceVersion<a class="headerlink" href="#vkenumerateinstanceversion" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 函数定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEnumerateInstanceVersion</span><span class="p">(</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pApiVersion</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApiVersion</span> <code class="docutils literal notranslate"><span class="pre">instance</span></code> 域函数支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 属于全局函数。</p>
</div>
<p>接下来就让我们获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本吧：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkEnumerateInstanceVersion</span><span class="w"> </span><span class="n">vkEnumerateInstanceVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkEnumerateInstanceVersion</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">VK_NULL_HANDLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkEnumerateInstanceVersion&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">vkEnumerateInstanceVersion</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vulkan_version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkEnumerateInstanceVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vulkan_version</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">Vulkan</span><span class="w"> </span><span class="n">Loader</span><span class="w"> </span><span class="n">或任意一个</span><span class="w"> </span><span class="n">Layer</span><span class="w"> </span><span class="n">发生了内存分配失败</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">vulkan_version</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">VK_MAKE_API_VERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h2>获取物理硬件设备<a class="headerlink" href="#id8" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 具有能够发现连接在主板上支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 设备的能力。通过 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数获取支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备。</p>
<section id="vkenumeratephysicaldevices">
<h3>vkEnumeratePhysicalDevices<a class="headerlink" href="#vkenumeratephysicaldevices" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEnumeratePhysicalDevices</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkInstance</span><span class="w">                                  </span><span class="n">instance</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pPhysicalDeviceCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="o">*</span><span class="w">                           </span><span class="n">pPhysicalDevices</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">instance</span> 是之前使用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 创建的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pPhysicalDeviceCount</span> 是用于指定或获取的物理设备数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pPhysicalDevices</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么是数量不小于 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 数组。</p></li>
</ul>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数将会将查询到支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备数量写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 所指向的内存中，所以 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 必须是一个有效指针。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数将会将 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 数量的有效 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄依次写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 指向的数组中。如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 指定的数量小于支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备数量的话， <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 将会写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 个物理设备句柄到数组中并返回 <code class="docutils literal notranslate"><span class="pre">VK_INCOMPLETE</span></code> 表示并不是所有设备都写入数组返回。</p>
<p>如果一切正常 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄不需要通过类似 <code class="docutils literal notranslate"><span class="pre">vkCreatePhysicalDevice</span></code> 这样的函数创建（ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准也没有该函数 ），而是在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 时内部已经做好了管理。也就是说 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 的生命周期与 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄一致。</p>
</div>
<p>接下来就让我们获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的物理设备吧：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkEnumeratePhysicalDevices</span><span class="w"> </span><span class="n">vkEnumeratePhysicalDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkEnumeratePhysicalDevices</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkEnumeratePhysicalDevices&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此时 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 的第一个参数不为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 而为有效 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄。</p>
</div>
<p>之后即可以获取到物理设备了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_device_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_count</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">(</span><span class="n">physical_device_count</span><span class="p">);</span>
<span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_count</span><span class="p">,</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</pre></div>
</div>
</section>
</section>
<section id="id9">
<h2>获取物理设备属性<a class="headerlink" href="#id9" title="Link to this heading">#</a></h2>
<p>当获取到物理设备 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄之后，可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 函数获取对应物理设备的属性。</p>
<section id="vkgetphysicaldeviceproperties">
<h3>vkGetPhysicalDeviceProperties<a class="headerlink" href="#vkgetphysicaldeviceproperties" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceProperties</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceProperties</span><span class="o">*</span><span class="w">                 </span><span class="n">pProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 对应要获取属性的物理设备的句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pProperties</span> 对应返回的物理设备属性。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 定义如下：</p>
</section>
<section id="vkphysicaldeviceproperties">
<h3>VkPhysicalDeviceProperties<a class="headerlink" href="#vkphysicaldeviceproperties" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkPhysicalDeviceProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">apiVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">driverVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">vendorID</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">deviceID</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceType</span><span class="w">                </span><span class="n">deviceType</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w">                                </span><span class="n">deviceName</span><span class="p">[</span><span class="n">VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">                             </span><span class="n">pipelineCacheUUID</span><span class="p">[</span><span class="n">VK_UUID_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceLimits</span><span class="w">              </span><span class="n">limits</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceSparseProperties</span><span class="w">    </span><span class="n">sparseProperties</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">apiVersion</span> 该设备驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">driverVersion</span> 该设备驱动版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vendorID</span> 设备供应商的 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceID</span> 设备的 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceType</span> 设备类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceName</span> 设备名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pipelineCacheUUID</span> 设备的通用唯一识别码（ <code class="docutils literal notranslate"><span class="pre">universally</span> <span class="pre">unique</span> <span class="pre">identifier</span></code> ）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">limits</span> 设备的限值信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sparseProperties</span> 稀疏数据属性。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">稀疏</p>
<p><code class="docutils literal notranslate"><span class="pre">稀疏</span></code> 为离散在内存各处的大量数据，这些数据可以被一并使用，常用表述数据量巨大的资源。</p>
</div>
<p>这里我们主要关注 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 和 <code class="docutils literal notranslate"><span class="pre">deviceType</span></code> 属性。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 主要是用于描述对应设备支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的版本，该版本很重要，说明设备只支持 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 版本之前的标准，如果在此设备上使用高于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 版本的功能的话将会导致错误或未定义行为。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deviceType</span></code> 主要是用于描述对应设备是独立显卡还是集成显卡。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceType</span></code> 枚举值定义如下：</p>
</section>
<section id="vkphysicaldevicetype">
<h3>VkPhysicalDeviceType<a class="headerlink" href="#vkphysicaldevicetype" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkPhysicalDeviceType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_OTHER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_CPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_OTHER</span> 该设备类型不与任何其他类型匹配， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中未定义的设备类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span> 集成显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span> 独立显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span> 虚拟环境中的虚拟显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_CPU</span> 中央处理器（ <code class="docutils literal notranslate"><span class="pre">CPU</span></code> ）。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">VK_PHYSICAL_DEVICE_TYPE_CPU</p>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_CPU</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 类型的设备，但是在通过 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 获取物理设备时，并不一定会得到插在主板上的 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 设备句柄，由于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 并不一定支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，所以 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 不一定能够获得，大部分支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备还是显卡设备。</p>
</div>
<p>在使用时，一般首选使用 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span></code> 独立显卡，之后再考虑使用 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span></code> 集成显卡。</p>
<p>获取物理属性例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 获取相应的设备属性了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的所有设备</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkPhysicalDeviceProperties</span><span class="w"> </span><span class="n">physical_device_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">   </span><span class="n">vkGetPhysicalDeviceProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_properties</span><span class="p">);</span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Physical Device Name:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">physical_device_properties</span><span class="p">.</span><span class="n">deviceName</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id10">
<h2>设备队列<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>接下来简单介绍一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的设备队列。</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的每一个 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 物理设备上都有一到多个设备队列。设备队列用于执行所有的用户任务指令，包括渲染、计算、查询、剔除和构建等等各种任务指令。</p>
<p>每个设备队列支持一到多个功能域，这些功能域分为如下 <code class="docutils literal notranslate"><span class="pre">5</span></code> 种：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">图形</span> 主要用于图形渲染，执行各种渲染绘制指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">计算</span> 主要用于执行并行计算（计算着色器），执行各种计算指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">转移</span> 主要用于执行资源的布局转移并支持在不同队列中进行转移，执行各种转移指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">稀疏绑定</span> 主要用于稀疏内存的管理。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">受保护</span> 主要用于受保护的内存的管理。</p></li>
</ul>
<p>在使用时常用的为 <code class="docutils literal notranslate"><span class="pre">图形</span></code> 、 <code class="docutils literal notranslate"><span class="pre">计算</span></code> 和 <code class="docutils literal notranslate"><span class="pre">转移</span></code> 功能的队列。</p>
<div class="important admonition">
<p class="admonition-title">设备队列和功能域</p>
<p>每个物理设备上支持一到多个设备队列，每个设备队列支持一到多个功能域。这里很有可能多个设备队列支持相同的功能域。比如同一物理设备上的设备队列 <code class="docutils literal notranslate"><span class="pre">A</span></code> 和 <code class="docutils literal notranslate"><span class="pre">B</span></code> 都支持图形和计算功能。</p>
</div>
<section id="id11">
<h3>获取设备队列（族）信息<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中是通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数获取：</p>
<section id="vkgetphysicaldevicequeuefamilyproperties">
<h4>vkGetPhysicalDeviceQueueFamilyProperties<a class="headerlink" href="#vkgetphysicaldevicequeuefamilyproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pQueueFamilyPropertyCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkQueueFamilyProperties</span><span class="o">*</span><span class="w">                    </span><span class="n">pQueueFamilyProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 要获取属性的物理设备的句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyPropertyCount</span> 是用于指定或获取的设备队列族数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyProperties</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么是数量不小于 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组。</p></li>
</ul>
<p>该函数的用法与 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数是一样的。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数将会将查询到的设备队列族数量写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 所指向的内存中，所以 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 必须是一个有效指针。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数将会将 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 数量的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数据依次写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 指向的数组中。如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 指定的数量小于支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备队列数量的话， <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 将会写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 个设备队列族信息。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<div class="note admonition">
<p class="admonition-title">队列族</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中设备队列是按照 <code class="docutils literal notranslate"><span class="pre">族</span></code> 进行管理的，前面我们知道一个物理设备上的可能会有多个设备队列支持相同的功能域，这些支持相同功能域的设备队列算作同一族。</p>
<div class="mermaid">
            flowchart TB
   subgraph DeviceQueueFamily_A[&quot;设备队列族 A&quot;]
      direction LR
      subgraph DeviceQueueFamily_A_Flags[&quot;支持的功能域&quot;]
         direction LR
            DeviceQueueFamily_A_GRAPHICS[&quot;图形&quot;]
            DeviceQueueFamily_A_COMPUTE[&quot;计算&quot;]
            DeviceQueueFamily_A_TRANSFER[&quot;转移&quot;]

            DeviceQueueFamily_A_GRAPHICS -.- DeviceQueueFamily_A_COMPUTE -.- DeviceQueueFamily_A_TRANSFER
      end

      subgraph DeviceQueueFamily_A_Queues[&quot;支持的队列&quot;]
         direction TB
            DeviceQueueFamily_A_Queue0[&quot;队列0&quot;]
            DeviceQueueFamily_A_Queue1[&quot;队列1&quot;]
            DeviceQueueFamily_A_Queue2[&quot;队列2&quot;]

            DeviceQueueFamily_A_Queue0 -.- DeviceQueueFamily_A_Queue1 -.- DeviceQueueFamily_A_Queue2
      end

      DeviceQueueFamily_A_Flags o--o DeviceQueueFamily_A_Queues

   end

   subgraph DeviceQueueFamily_B[&quot;设备队列族 B&quot;]
      direction LR
      subgraph DeviceQueueFamily_B_Flags[&quot;支持的功能域&quot;]
         direction LR
            DeviceQueueFamily_B_COMPUTE[&quot;计算&quot;]
            DeviceQueueFamily_B_TRANSFER[&quot;转移&quot;]

            DeviceQueueFamily_B_COMPUTE -.- DeviceQueueFamily_B_TRANSFER
      end

      subgraph DeviceQueueFamily_B_Queues[&quot;支持的队列&quot;]
         direction TB
            DeviceQueueFamily_B_Queue3[&quot;队列3&quot;]
      end

      DeviceQueueFamily_B_Flags o--o DeviceQueueFamily_B_Queues

   end

   DeviceQueueFamily_A--&gt;DeviceQueueFamily_B
   DeviceQueueFamily_B--&gt;etc[&quot;...&quot;]

   style DeviceQueueFamily_A_Flags fill:#f96
   style DeviceQueueFamily_B_Flags fill:#f96
   style DeviceQueueFamily_A_Queues fill:#00bfa5
   style DeviceQueueFamily_B_Queues fill:#00bfa5
        </div></div>
<p>设备队列族 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 定义如下：</p>
</section>
<section id="vkqueuefamilyproperties">
<h4>VkQueueFamilyProperties<a class="headerlink" href="#vkqueuefamilyproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkQueueFamilyProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkQueueFlags</span><span class="w">    </span><span class="n">queueFlags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">queueCount</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">timestampValidBits</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkExtent3D</span><span class="w">      </span><span class="n">minImageTransferGranularity</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkQueueFamilyProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFlags</span> 为队列族位域，用于描述该队列族支持的功能域。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCount</span> 该队列族中的队列数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">timestampValidBits</span> 时间戳中有效的位数，有效的位数范围为 <code class="docutils literal notranslate"><span class="pre">36</span></code> 到 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位，如果为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 说明不支持时间戳。超出有效范围的位保证为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">minImageTransferGranularity</span> 在该族队列上进行图片转移操作时支持的最小转移粒度（大小）。</p></li>
</ul>
<p>目前我们主要关心 <code class="docutils literal notranslate"><span class="pre">queueFlags</span></code> 和 <code class="docutils literal notranslate"><span class="pre">queueCount</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">queueFlags</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 类型，其定义如下：</p>
</section>
<section id="vkqueueflags">
<h4>VkQueueFlags<a class="headerlink" href="#vkqueueflags" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">VkFlags</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">VkFlags</span><span class="w"> </span><span class="n">VkQueueFlags</span><span class="p">;</span>
</pre></div>
</div>
<p>可以看到 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 其实就是一个 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的标志位。</p>
<div class="note admonition">
<p class="admonition-title">VkFlags</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有的标志位 <code class="docutils literal notranslate"><span class="pre">Vk{标志位名称}Flags</span></code> 都为 <code class="docutils literal notranslate"><span class="pre">VkFlags</span></code> 也就是 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 。每一位对应的含义都在对应的 <code class="docutils literal notranslate"><span class="pre">Vk{标志位名称}FlagBits</span></code> 枚举中定义。</p>
</div>
<div class="note admonition">
<p class="admonition-title">标志位与位域</p>
<p>所谓标志位，也就是位域。像 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 其比特位有 <code class="docutils literal notranslate"><span class="pre">32</span></code> 个，如果某一比特位为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则说明对应的位域被激活，也就是对应位域表示的事物被激活。比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的二进制：0000 0000 0000 0000 0000 0000 0000 0001</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的二进制：0000 0000 0000 0000 0000 0000 0000 0010</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">likes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">某人的喜好</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">likes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">//什么也不喜欢</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LIKE_CAT_BI</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LIKE_CAT_BIT</span><span class="p">)</span><span class="w"> </span><span class="c1">//喜欢猫</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">)</span><span class="w"> </span><span class="c1">//喜欢狗</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">))</span><span class="w"> </span><span class="c1">//既喜欢猫，也喜欢狗</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 对应位域的 <code class="docutils literal notranslate"><span class="pre">VkQueueFlagBits</span></code> 定义如下:</p>
</section>
<section id="vkqueueflagbits">
<h4>VkQueueFlagBits<a class="headerlink" href="#vkqueueflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkQueueFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_COMPUTE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_TRANSFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_SPARSE_BINDING_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">    </span><span class="n">VK_QUEUE_PROTECTED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_GRAPHICS_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">图形</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_COMPUTE_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">计算</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_TRANSFER_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">转移</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_SPARSE_BINDING_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">稀疏绑定</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_PROTECTED_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">受保护</span></code> 功能。</p></li>
</ul>
<p>获取设备队列（族）信息例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceQueueFamilyProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceQueueFamilyProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 获取相应的设备队列（族）属性了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">queue_family_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkQueueFamilyProperties</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue_familys</span><span class="p">(</span><span class="n">queue_family_count</span><span class="p">);</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span><span class="w"> </span><span class="n">queue_familys</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">uint32_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint32_max</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">queue_family_count</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">queue_familys</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">queueFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="o">::</span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="o">::</span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 寻找支持图形的队列族</span>
<span class="w">      </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">assert</span><span class="p">(</span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">uint32_max</span><span class="p">)</span><span class="w"> </span><span class="c1">//没找到支持图形的队列族</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">support_graphics_queue_family_index</p>
<p>需要获取存储对应设备队列族在 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组中的索引值，这会在之后使用到。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VK_QUEUE_GRAPHICS_BIT</p>
<p>我们一般倾向于需要支持 <code class="docutils literal notranslate"><span class="pre">VK_QUEUE_GRAPHICS_BIT</span></code> 图形功能的队列族，这是因为大部分设备队列族如果支持图形功能的话，其他的计算、转移和稀疏绑定功能也会同时支持。</p>
</div>
</section>
</section>
</section>
<section id="id12">
<h2>逻辑设备<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>在获得了物理设备句柄之后，我们需要在某个物理设备上创建逻辑设备，之后所有的操作都应用于此逻辑设备上。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中使用 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 句柄表示一个逻辑设备。</p>
<section id="id13">
<h3>创建逻辑设备<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p>首先需要使用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建逻辑设备。</p>
<section id="vkcreatedevice">
<h4>vkCreateDevice<a class="headerlink" href="#vkcreatedevice" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateDevice</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkDeviceCreateInfo</span><span class="o">*</span><span class="w">                   </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="o">*</span><span class="w">                                   </span><span class="n">pDevice</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 为之前使用 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 获取到的某个物理设备句柄，逻辑设备将在此物理设备上创建。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 表示逻辑设备的创建信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pDevice</span> 创建返回的逻辑设备 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 句柄。</p></li>
</ul>
<p>如果创建成功将会返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。并且同一个物理设备可以创建多个逻辑设备。</p>
<p>创建逻辑设备的 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 结构体定义如下：</p>
</section>
<section id="vkdevicecreateinfo">
<h4>VkDeviceCreateInfo<a class="headerlink" href="#vkdevicecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkDeviceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">                    </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                        </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceCreateFlags</span><span class="w">                </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">queueCreateInfoCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkDeviceQueueCreateInfo</span><span class="o">*</span><span class="w">     </span><span class="n">pQueueCreateInfos</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">enabledLayerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">                 </span><span class="n">ppEnabledLayerNames</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">enabledExtensionCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">                 </span><span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkPhysicalDeviceFeatures</span><span class="o">*</span><span class="w">    </span><span class="n">pEnabledFeatures</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 标志位，保留为将来使用。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCreateInfoCount</span> 为 <code class="docutils literal notranslate"><span class="pre">pQueueCreateInfos</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueCreateInfos</span> 指向 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 数组指针，用于逻辑设备创建设备队列。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledLayerCount</span> 为 <code class="docutils literal notranslate"><span class="pre">ppEnabledLayerNames</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledLayerNames</span> 指向字符串数组指针，用于启用设备 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 为 <code class="docutils literal notranslate"><span class="pre">ppEnabledExtensionNames</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledExtensionNames</span> 指向字符串数组指针，用于启用设备扩展。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkPhysicalDeviceFeatures</span> 设置要激活的物理设备特性。</p></li>
</ul>
<p>此时我们主要关心数量为 <code class="docutils literal notranslate"><span class="pre">queueCreateInfoCount</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pQueueCreateInfos</span></code> 数组。该数组用于在创建逻辑设备时指定创建的设备队列信息。该结构体定义如下：</p>
</section>
<section id="vkdevicequeuecreateinfo">
<h4>VkDeviceQueueCreateInfo<a class="headerlink" href="#vkdevicequeuecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkDeviceQueueCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceQueueCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueFamilyIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w">                </span><span class="n">pQueuePriorities</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceQueueCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 标志位。用于设置目标设备队列的行为。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 对应的队列族在 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数返回的 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 数组中的索引值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCount</span> 在对应的队列族中创建的设备队列数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueuePriorities</span> 设备队列优先级。指向数量为 <code class="docutils literal notranslate"><span class="pre">queueCount</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">float</span></code> 的数组，对应设置每一个设备队列的优先级。</p></li>
</ul>
<p>这里 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 成员非常重要，该成员对应着使用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 获取到的设备队列族在 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 数组中的索引值，大部分情况会去选择支持图形功能的队列族所对应的索引。</p>
<p>这样我们就可以创建逻辑设备了，例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkCreateDevice</span><span class="w"> </span><span class="n">vkCreateDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateDevice</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateDevice&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建逻辑设备了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="n">中找到的支持图形功能的队列族索引</span><span class="p">;</span>

<span class="kt">float</span><span class="w"> </span><span class="n">queue_prioritie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="n">VkDeviceQueueCreateInfo</span><span class="w"> </span><span class="n">device_queue_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">queueCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">pQueuePriorities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_prioritie</span><span class="p">;</span>

<span class="n">VkDeviceCreateInfo</span><span class="w"> </span><span class="n">device_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">queueCreateInfoCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pQueueCreateInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_queue_create_info</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">enabledLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pEnabledFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateDevice</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="device">
<h2>获取 Device 域函数<a class="headerlink" href="#device" title="Link to this heading">#</a></h2>
<p>在创建完逻辑设备 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 之后，与 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 及其产生的子对象（句柄）的所有交互函数都属于 <code class="docutils literal notranslate"><span class="pre">Device</span> <span class="pre">域函数</span></code> 。我们通过 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供的 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数获取 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
<section id="vkgetdeviceprocaddr">
<h3>vkGetDeviceProcAddr<a class="headerlink" href="#vkgetdeviceprocaddr" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">PFN_vkVoidFunction</span><span class="w"> </span><span class="nf">vkGetDeviceProcAddr</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">                                 </span><span class="n">pName</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pName</span> 要获取的逻辑设备对应的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数驱动实现。</p></li>
</ul>
<p>该函数就是用于获取不同设备驱动实现的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数接口，不同的 <code class="docutils literal notranslate"><span class="pre">device</span></code> 支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 扩展函数不尽相同，但是如果支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 特定版本的话（ <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties::apiVersion</span></code> ）则一定能够获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心标准中的函数实现。</p>
<p>如果获取 <code class="docutils literal notranslate"><span class="pre">device</span></code> 对应驱动中没有实现的函数的话，将会返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>该函数的返回值与 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 一样为 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> ，与 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 一样， <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 在获取驱动中某一有效函数后需要强制转换成对应函数。</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数指针如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetDeviceProcAddr</span><span class="w"> </span><span class="n">vkGetDeviceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetDeviceProcAddr</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetDeviceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 获取 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域的函数了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">}</span><span class="w"> </span><span class="n">vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">})</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vk{Device 域函数名}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在创建完 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 之后，由于所有要调用的函数都作用在某一具体逻辑设备上，所以之后所有函数都是 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
</div>
</section>
</section>
<section id="id14">
<h2>获取设备队列<a class="headerlink" href="#id14" title="Link to this heading">#</a></h2>
<p>我们在创建逻辑设备时指定了需要使用的设备队列信息， <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建过程中会为我们创建对应的设备队列，之后我们需要通过 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数获取设备队列 <code class="docutils literal notranslate"><span class="pre">VkQueue</span></code> 句柄。</p>
<section id="vkgetdevicequeue">
<h3>vkGetDeviceQueue<a class="headerlink" href="#vkgetdevicequeue" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetDeviceQueue</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">queueFamilyIndex</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">queueIndex</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkQueue</span><span class="o">*</span><span class="w">                                    </span><span class="n">pQueue</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 创建设备队列时对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 创建设备队列时对应的队列族索引。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueIndex</span> 对应着队列族中设备队列的索引。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueue</span> 将会返回 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 索引对应的队列族中，设备队列索引值为 <code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 的索引句柄。</p></li>
</ul>
<p>由于一个队列族中可能有多个设备队列，并且在创建逻辑设备时可以同时创建多个设备队列，索引此时需要用户指定 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 和 <code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 来获取对应的设备队列（句柄）。</p>
<p>在使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 获取设备队列句柄之前，需要先获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数指针：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetDeviceQueue</span><span class="w"> </span><span class="n">vkGetDeviceQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetDeviceQueue</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetDeviceQueue&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数时使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 获取，其为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
</div>
<p>之后我们就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 获取对应的设备队列句柄了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="n">中找到的支持图形功能的队列族索引</span><span class="p">;</span>

<span class="n">VkQueue</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">vkGetDeviceQueue</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于在创建 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 代码示例中只指定了一个支持图形的队列，所以这里：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 为之前获取的 <code class="docutils literal notranslate"><span class="pre">support_graphics_queue_family_index</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
</ul>
</div>
</section>
</section>
<section id="id15">
<h2>内存<a class="headerlink" href="#id15" title="Link to this heading">#</a></h2>
<section id="id16">
<h3>内存分类<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中函数主要分为两类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数中主要在 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 能够访问的（主板上）内存中进行分配和访问。比如在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 时需要指定 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">VkAllocationCallbacks*</span> <span class="pre">pAllocator</span></code> 内存分配回调（一般回调内部使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 或 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 等进行分配）。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问的内存一般称为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存。</p>
<p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数中主要在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 能够访问的内存（显存）中进行内存分配和访问。这一部分内存称为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存。</p>
<div class="important admonition">
<p class="admonition-title">const VkAllocationCallbacks* pAllocator</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 内存分配回调分配的内存将会存储在内存条中，该部分内存属于特殊的 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存，确切的说使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 或 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 等分配的内存，在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中不属于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 管理的范畴。这里仅仅为了引出 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端做的简要引子。</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 的具体用法将会在之后单独的章节中进行讲解。</p>
</div>
<p>由此引出了 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的两个端分类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端</p></li>
</ul>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端一般是指 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 可以访问的那部分资源（内存），而该部分资源可能存储在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备上的内存中也可能存储在内存条上的内存中。只不过这部分资源可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问到并归为 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 管理范畴。</p>
<p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端表示 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备可访问的的专属资源（内存）。</p>
<p>这里可以看出内存条上的内存和 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上的显存都属于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 可访问的内存范畴。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中我们往往在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端将数据准备好，之后打算使用 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备访问该数据进行计算。然而 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端准备的数据只有 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 能够访问， <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备并不能直接访问 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中为我们提供了可被 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 访问的 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存。
也就是说这一部分内存既可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问也可以被 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端访问。一般来说，我们会先将 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的数据拷贝至可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问也可以被 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端访问的内存中，之后再将这部分数据拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存中被 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 访问使用。</p>
<div class="mermaid">
            flowchart LR

   Host[&quot;Host 端\n（使用 new 或 malloc 分配内存）&quot;]
   HostAndDevice[&quot;Host 端与 Device 都可访问的内存&quot;]
   Device[&quot;Device 端内存&quot;]

   Host--拷贝--&gt;HostAndDevice--&quot;（总线）拷贝&quot;--&gt;Device
        </div><div class="tip admonition">
<p class="admonition-title">既然数据在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端都可以访问的内存中，为什么还需要拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端中？</p>
<p>在硬件层面 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端都可以访问的内存，这类内存对于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 这种处理连续内存非常友好，而像 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 这种大量并行计算的设备来说就不尽人意了，拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端中的目的是将这一步分数据转换成设备友好的内存结构，提高内存读写性能。</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中可以在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备上直接访问 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 都可访问的内存。只不过我们经常将这部分内存数据拷贝至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 专属内存中提高性能。</p>
</div>
<p>最终可得出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的内存分类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存</p></li>
</ul>
<div class="important admonition">
<p class="admonition-title">Vulkan 内存</p>
<p>其实在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准看来，所有的内存都属于 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存，只不过有些 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问。有些 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 专属内存。</p>
</div>
</section>
<section id="id17">
<h3>获取 Vulkan 支持的缓存<a class="headerlink" href="#id17" title="Link to this heading">#</a></h3>
<div class="note admonition">
<p class="admonition-title">内存与缓存</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中与内存相关的英文为 <code class="docutils literal notranslate"><span class="pre">Buffer</span></code> ，翻译成 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 更加贴合 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准，这里与 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准保持一致。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 所有的缓存信息都可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数获取，其定义如下：</p>
<section id="vkgetphysicaldevicememoryproperties">
<h4>vkGetPhysicalDeviceMemoryProperties<a class="headerlink" href="#vkgetphysicaldevicememoryproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceMemoryProperties</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkPhysicalDevice</span><span class="w">                           </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkPhysicalDeviceMemoryProperties</span><span class="o">*</span><span class="w">          </span><span class="n">pMemoryProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 为对应获取对应缓存信息的物理设备。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemoryProperties</span> 相应的缓存信息将会写入并返回。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 结构体描述如下：</p>
</section>
<section id="vkphysicaldevicememoryproperties">
<h4>VkPhysicalDeviceMemoryProperties<a class="headerlink" href="#vkphysicaldevicememoryproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_MAX_MEMORY_TYPES 32U</span>
<span class="cp">#define VK_MAX_MEMORY_HEAPS 16U</span>

<span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                         </span><span class="n">memoryTypeCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryType</span><span class="w">                                     </span><span class="n">memoryTypes</span><span class="p">[</span><span class="n">VK_MAX_MEMORY_TYPES</span><span class="p">];</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                         </span><span class="n">memoryHeapCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryHeap</span><span class="w">                                     </span><span class="n">memoryHeaps</span><span class="p">[</span><span class="n">VK_MAX_MEMORY_HEAPS</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceMemoryProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypeCount</span> 内存类型的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypes</span> 对应的内存类型信息数据。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryHeapCount</span> 内存堆的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryHeaps</span> 对应的内存堆的信息数据。</p></li>
</ul>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 结构体描述如下：</p>
</section>
<section id="vkmemorytype">
<h4>VkMemoryType<a class="headerlink" href="#vkmemorytype" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkMemoryPropertyFlags</span><span class="w">          </span><span class="n">propertyFlags</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                       </span><span class="n">heapIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">propertyFlags</span> 该类内存的属性信息，使用标志位存储相应信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">heapIndex</span> 对应的内存堆的索引，表示指向 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps[heapIndex]</span></code> 的内存堆。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlags</span></code> 对应的各个比特位的值定义于 <code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlagBits</span></code> 枚举中，定义如下：</p>
</section>
<section id="vkmemorypropertyflagbits">
<h4>VkMemoryPropertyFlagBits<a class="headerlink" href="#vkmemorypropertyflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkMemoryPropertyFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_PROTECTED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 物理设备自身的内存只有物理设备自身可访问，也就是 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端可访问到的内存只有 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端自身可访问， <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端不可访问。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端连续内存，表示对于该内存的读写可连续进行（就像 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 对于内存的修改那样）。该内存类型不需要手动进行 <code class="docutils literal notranslate"><span class="pre">刷新</span></code> 和 <code class="docutils literal notranslate"><span class="pre">失效</span></code> 操作。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端高速缓存内存，并且自带 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span></code> 属性。这一部分内存大小相对较小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</span> 表示这部分内存为可以滞后分配内存，等要使用时再分配内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_PROTECTED_BIT</span> 表示这部分内存为受保护内存，并且只允许 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 硬件设备和受保护的队列（ <code class="docutils literal notranslate"><span class="pre">VK_QUEUE_PROTECTED_BIT</span></code> ）可以访问该内存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">刷新</span></code> 和 <code class="docutils literal notranslate"><span class="pre">失效</span></code> 操作</p>
<p>是指使用 <code class="docutils literal notranslate"><span class="pre">vkFlushMappedMemoryRanges</span></code> 进行内存刷新，使用 <code class="docutils literal notranslate"><span class="pre">vkInvalidateMappedMemoryRanges</span></code> 使内存失效。有关详细说明将会在单独的章节中进行讲解。</p>
</div>
<p>我们经常会使用到 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span></code> 、 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span></code> 属性的内存。</p>
<p>接下来我们来看一下 <code class="docutils literal notranslate"><span class="pre">VkMemoryType::heapIndex</span></code> 对应的 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 的定义：</p>
</section>
<section id="vkmemoryheap">
<h4>VkMemoryHeap<a class="headerlink" href="#vkmemoryheap" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryHeap</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w">                   </span><span class="n">size</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryHeapFlags</span><span class="w">              </span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryHeap</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 表示该内存堆的比特大小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 表示该堆的属性标志位，各位的含义被定义在 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 中。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlags</span></code> 对应的各个比特位的值定义于 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 枚举中，定义如下：</p>
</section>
<section id="vkmemoryheapflagbits">
<h4>VkMemoryHeapFlagBits<a class="headerlink" href="#vkmemoryheapflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkMemoryHeapFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">  </span><span class="n">VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span> 表示该内存堆为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 专属内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</span> 由于逻辑设备可以包含多个物理设备，此标志位表示该堆对应多个物理设备上的内存堆，对该堆的操作将会在每个物理设备的内存堆上进行相同的操作。</p></li>
</ul>
<p>常用的为 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span></code> 标志位。</p>
</section>
<section id="id18">
<h4>VkPhysicalDeviceMemoryProperties 结构图<a class="headerlink" href="#id18" title="Link to this heading">#</a></h4>
<p>为了更清晰的理解 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> ，在此给出一张 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 结构参考图：</p>
<div class="mermaid">
            flowchart TB
   subgraph memoryTypes[&quot;VkPhysicalDeviceMemoryProperties::memoryTypes&quot;]
   direction LR
      subgraph VkMemoryType0[&quot;VkMemoryType 0&quot;]
      direction TB
          VkMemoryType0_PropertyFlags[&quot;VkMemoryPropertyFlags propertyFlags&quot;] -.- VkMemoryType0_HeapIndex[&quot;uint32_t heapIndex&quot;]
      end
      subgraph VkMemoryType1[&quot;VkMemoryType 1&quot;]
      direction TB
          VkMemoryType1_PropertyFlags[&quot;VkMemoryPropertyFlags propertyFlags&quot;] -.- VkMemoryType1_HeapIndex[&quot;uint32_t heapIndex&quot;]
      end
      subgraph VkMemoryType2[&quot;VkMemoryType 2&quot;]
      direction TB
          VkMemoryType2_PropertyFlags[&quot;VkMemoryPropertyFlags propertyFlags&quot;] -.- VkMemoryType2_HeapIndex[&quot;uint32_t heapIndex&quot;]
      end
      subgraph VkMemoryTypeEtc[&quot;...&quot;]
      end

      VkMemoryType0 -.- VkMemoryType1 -.- VkMemoryType2 -.- VkMemoryTypeEtc
   end

   subgraph memoryHeaps[&quot;VkPhysicalDeviceMemoryProperties::memoryHeaps&quot;]
   direction LR
      subgraph VkMemoryHeap0[&quot;VkMemoryHeap 0&quot;]
      direction TB
          VkMemoryHeap0_Size[&quot;VkDeviceSize size&quot;] -.- VkMemoryHeap0_Flags[&quot;VkMemoryHeapFlags flags&quot;]
      end
      subgraph VkMemoryHeap1[&quot;VkMemoryHeap 1&quot;]
      direction TB
          VkMemoryHeap1_Size[&quot;VkDeviceSize size&quot;] -.- VkMemoryHeap1_Flags[&quot;VkMemoryHeapFlags flags&quot;]
      end
      subgraph VkMemoryHeap2[&quot;VkMemoryHeap 2&quot;]
      direction TB
          VkMemoryHeap2_Size[&quot;VkDeviceSize size&quot;] -.- VkMemoryHeap2_Flags[&quot;VkMemoryHeapFlags flags&quot;]
      end
      subgraph VkMemoryHeapEtc[&quot;...&quot;]
      end

      VkMemoryHeap0 -.- VkMemoryHeap1 -.- VkMemoryHeap2 -.- VkMemoryHeapEtc

   end

   VkMemoryType0_HeapIndex--&gt;VkMemoryHeap2
   VkMemoryType1_HeapIndex--&gt;VkMemoryHeap0
   VkMemoryType2_HeapIndex--&gt;VkMemoryHeap1
        </div><p>接下来就能够通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 获取内存信息了，和之前很多函数一样，首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceMemoryProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceMemoryProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以通过调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 获得内存相关信息了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>

<span class="n">VkPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="n">vkGetPhysicalDeviceMemoryProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_memory_properties</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryTypeCount</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkMemoryType</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryTypes</span><span class="p">[</span><span class="n">memory_type_index</span><span class="p">];</span>

<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt DEVICE_LOCAL&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt HOST_VISIBLE&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt HOST_COHERENT&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">heap_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_type</span><span class="p">.</span><span class="n">heapIndex</span><span class="p">;</span>

<span class="w">   </span><span class="n">VkMemoryHeap</span><span class="w"> </span><span class="n">memory_heap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryHeaps</span><span class="p">[</span><span class="n">heap_index</span><span class="p">];</span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;heap &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">heap_index</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">memory_heap</span><span class="p">.</span><span class="n">size</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; GB&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_heap</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s"> DEVICE_LOCAL&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id19">
<h3>分配缓存<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
<div class="related-pages">
    <a class="next-page" href="Literature/index.html">
        <div class="page-info">
            <div class="context">
                <span>Next</span>
            </div>
            <div class="title">文献</div>
        </div>
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
    </a>
    <a class="prev-page" href="EnvironmentalConfig.html">
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
        <div class="page-info">
            <div class="context">
                <span>Previous</span>
            </div>
            
            <div class="title">环境配置</div>
            
        </div>
    </a>
</div>
<div class="bottom-of-page">
    <div class="left-details">
        <div class="copyright">
            Copyright &#169; 2023, FuXii
        </div>
        Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
        
        <a href="https://github.com/pradyunsg/furo">Furo</a>
        
        <div>
             <span id="busuanzi_container_site_uv" style='display:none'>site view <span
                    id="busuanzi_value_site_uv"></span></span> 
        </div>
    </div>
    <div class="right-details">
        <div class="icons">
            <a class="muted-link " href="https://github.com/FuXiii/Essentials.of.Vulkan" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
            
        </div>
        <div class="left-details">
             <span id="busuanzi_container_page_pv" style='display:none'>page view <span
                    id="busuanzi_value_page_pv"></span></span> 
        </div>
    </div>
</div>

      </footer>
    </div>
    <aside class="toc-drawer">
      

<div class="toc-sticky toc-scroll" style="width: 500px;">
    <div class="toc-title-container" style="width: 500px;">
        <span class="toc-title" style="width: 500px;">
            On this page
        </span>
    </div>
    <div class="toc-tree-container" style="width: 500px;">
        <div class="toc-tree" style="width: 500px;">
            <ul>
<li><a class="reference internal" href="#">纵览</a><ul>
<li><a class="reference internal" href="#vulkan">Vulkan 能为我们做什么</a></li>
<li><a class="reference internal" href="#id3">Vulkan 的接口</a></li>
<li><a class="reference internal" href="#id4">获取 Vulkan 接口</a><ul>
<li><a class="reference internal" href="#id5">加载 Vulkan 动态库</a></li>
<li><a class="reference internal" href="#id6">Vulkan 函数分类</a></li>
<li><a class="reference internal" href="#vkgetinstanceprocaddr">vkGetInstanceProcAddr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vulkan-vkinstance">Vulkan 最初之物 VkInstance</a><ul>
<li><a class="reference internal" href="#vkinstance">创建 VkInstance</a><ul>
<li><a class="reference internal" href="#vkcreateinstance">vkCreateInstance</a></li>
<li><a class="reference internal" href="#vkinstancecreateinfo">VkInstanceCreateInfo</a></li>
<li><a class="reference internal" href="#vkapplicationinfo">VkApplicationInfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id7">获取支持的 Vulkan 版本</a><ul>
<li><a class="reference internal" href="#vkenumerateinstanceversion">vkEnumerateInstanceVersion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">获取物理硬件设备</a><ul>
<li><a class="reference internal" href="#vkenumeratephysicaldevices">vkEnumeratePhysicalDevices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">获取物理设备属性</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldeviceproperties">vkGetPhysicalDeviceProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldeviceproperties">VkPhysicalDeviceProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldevicetype">VkPhysicalDeviceType</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">设备队列</a><ul>
<li><a class="reference internal" href="#id11">获取设备队列（族）信息</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldevicequeuefamilyproperties">vkGetPhysicalDeviceQueueFamilyProperties</a></li>
<li><a class="reference internal" href="#vkqueuefamilyproperties">VkQueueFamilyProperties</a></li>
<li><a class="reference internal" href="#vkqueueflags">VkQueueFlags</a></li>
<li><a class="reference internal" href="#vkqueueflagbits">VkQueueFlagBits</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id12">逻辑设备</a><ul>
<li><a class="reference internal" href="#id13">创建逻辑设备</a><ul>
<li><a class="reference internal" href="#vkcreatedevice">vkCreateDevice</a></li>
<li><a class="reference internal" href="#vkdevicecreateinfo">VkDeviceCreateInfo</a></li>
<li><a class="reference internal" href="#vkdevicequeuecreateinfo">VkDeviceQueueCreateInfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#device">获取 Device 域函数</a><ul>
<li><a class="reference internal" href="#vkgetdeviceprocaddr">vkGetDeviceProcAddr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">获取设备队列</a><ul>
<li><a class="reference internal" href="#vkgetdevicequeue">vkGetDeviceQueue</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">内存</a><ul>
<li><a class="reference internal" href="#id16">内存分类</a></li>
<li><a class="reference internal" href="#id17">获取 Vulkan 支持的缓存</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldevicememoryproperties">vkGetPhysicalDeviceMemoryProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldevicememoryproperties">VkPhysicalDeviceMemoryProperties</a></li>
<li><a class="reference internal" href="#vkmemorytype">VkMemoryType</a></li>
<li><a class="reference internal" href="#vkmemorypropertyflagbits">VkMemoryPropertyFlagBits</a></li>
<li><a class="reference internal" href="#vkmemoryheap">VkMemoryHeap</a></li>
<li><a class="reference internal" href="#vkmemoryheapflagbits">VkMemoryHeapFlagBits</a></li>
<li><a class="reference internal" href="#id18">VkPhysicalDeviceMemoryProperties 结构图</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">分配缓存</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
    </div>
</div>


    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=7d86a446"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/tabs.js?v=3ee01567"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script src="https://unpkg.com/mermaid@10.2.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </body>
</html>