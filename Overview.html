<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="./">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="genindex.html" /><link rel="search" title="搜索" href="search.html" /><link rel="next" title="文献" href="Literature/index.html" /><link rel="prev" title="环境配置" href="EnvironmentalConfig.html" />
        <link rel="canonical" href="https://github.com/FuXiii/Essentials.of.Vulkan/Overview.html" />

    <link rel="shortcut icon" href="_static/VulkanLogo.png"/><!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>纵览 - Vulkan入门精要</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b20cc3f5" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Vulkan入门精要</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
<div class="sidebar-sticky" ><a class="sidebar-brand" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/Vulkan.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Vulkan入门精要</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">入门精要</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="StartFromVulkanSDK.html">开始于 Vulkan SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="EnvironmentalConfig.html">环境配置</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">纵览</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">文献翻译</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="Literature/index.html">文献</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 文献</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Literature/VulkanRayTracingFinalSpecificationRelease.html">Vulkan 光线追踪最终标准发布</a></li>
<li class="toctree-l2"><a class="reference internal" href="Literature/Vulkan-GuideRayTracing.html">光线追踪</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/NVIDIAVulkanRayTracingTutorial.html">NVIDIA Vulkan 光线追踪教程</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of NVIDIA Vulkan 光线追踪教程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/JitterCamera.html">相机抖动抗锯齿教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/AnyHitShaders.html">任意命中着色器（Any Hit Shaders）教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Instances.html">实例化</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Reflections.html">反射</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/MultipleClosestHitShaders.html">多重最近命中着色器</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/Animation.html">动态更新</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/IntersectionShader.html">相交着色器</a></li>
<li class="toctree-l3"><a class="reference internal" href="Literature/NVIDIAVulkanRayTracingTutorial/extensions/CallableShaders.html">可调用着色器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Literature/vk_mini_path_tracer.html">Vulkan迷你路径追踪</a></li>
<li class="toctree-l2"><a class="reference internal" href="Literature/TheRTXShaderBindingTableThreeWays.html">RTX 着色器绑定表的三种方式</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">随笔</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="InformalEssay/index.html">Vulkan 标准</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Vulkan 标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VulkanKHRRayTracing.html">Vulkan KHR 光线追踪标准</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Vulkan KHR 光线追踪标准</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_acceleration_structure.html">VK_KHR_acceleration_structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_ray_tracing_pipeline.html">VK_KHR_ray_tracing_pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/VK_KHR_deferred_host_operations.html">VK_KHR_deferred_host_operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="InformalEssay/VulkanKHRRayTracing/ShaderBindingTable.html">着色器绑定表</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="InformalEssay/VK_KHR_buffer_device_address.html">VK_KHR_buffer_device_address</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="InformalEssay/VulkanForAndroid.html">Android 平台适配</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">工程应用</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="Application/index.html">应用</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 应用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="Application/VolumetricCloud.html">体积云</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUImGui.html">WebGPU ImGui</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUHelloTriangle.html">WebGPU Hello Triangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="Application/WebGPUShaderCompiler.html">WebGPU Shader Compiler</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">更新日志</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Changelog.html">更新日志</a></li>
</ul>

</div>
</div>

</div>

    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/FuXiii/Essentials.of.Vulkan/edit/main/source/Overview.rst" title="Edit this page">
    <svg aria-hidden="true" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
      <line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
    </svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="id1">
<h1>纵览<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header sd-bg-muted sd-bg-text-muted">
<span class="sd-summary-icon"><svg version="1.1" width="1.0em" height="1.0em" class="sd-octicon sd-octicon-history" viewBox="0 0 16 16" aria-hidden="true"><path fill-rule="evenodd" d="M1.643 3.143L.427 1.927A.25.25 0 000 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 00.177-.427L2.715 4.215a6.5 6.5 0 11-1.18 4.458.75.75 0 10-1.493.154 8.001 8.001 0 101.6-5.684zM7.75 4a.75.75 0 01.75.75v2.992l2.028.812a.75.75 0 01-.557 1.392l-2.5-1A.75.75 0 017 8.25v-3.5A.75.75 0 017.75 4z"></path></svg></span>更新记录<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<ul class="simple">
<li><p class="sd-card-text">2023/5/15 增加该文章</p></li>
<li><p class="sd-card-text">2023/5/16 将 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 章节的内容移动至单独 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 文章中</p></li>
<li><p class="sd-card-text">2023/6/23 更新该文档</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">能为我们做什么</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">接口</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/23 增加 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">最初之物</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/24 增加 <code class="docutils literal notranslate"><span class="pre">创建</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 更新 <code class="docutils literal notranslate"><span class="pre">创建</span> <span class="pre">VkInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">VkApplicationInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/25 增加 <code class="docutils literal notranslate"><span class="pre">获取支持的</span> <span class="pre">Vulkan</span> <span class="pre">版本</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">获取支持的</span> <span class="pre">Vulkan</span> <span class="pre">版本</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的接口</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">获取物理硬件设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/26 增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节并增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 声明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/26 更新 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">全局函数</span></code> 相关说明</p></li>
<li><p class="sd-card-text">2023/6/27 更新 <code class="docutils literal notranslate"><span class="pre">获取物理硬件设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/27 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节，增加全局函数的条目</p></li>
<li><p class="sd-card-text">2023/6/27 增加 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">获取物理设备属性</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 更新 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceType</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/28 更新 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">句柄</span></code> 描述</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">设备队列</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 更新 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">稀疏</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列信息</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/29 增加 <code class="docutils literal notranslate"><span class="pre">VkQueueFlagBits</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 更新 <code class="docutils literal notranslate"><span class="pre">加载</span> <span class="pre">Vulkan</span> <span class="pre">动态库</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">的静态库</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">逻辑设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">创建逻辑设备</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/6/30 更新 <code class="docutils literal notranslate"><span class="pre">获取设备队列（族）信息</span></code> 章节。修改 <code class="docutils literal notranslate"><span class="pre">例程</span></code> 的错误</p></li>
<li><p class="sd-card-text">2023/6/30 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列（族）信息</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">获取设备队列</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Device</span> <span class="pre">域函数</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 增加 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数特殊性</span></code> 说明，修正分类说明，删除 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/2 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">内存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">内存分类</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 增加 <code class="docutils literal notranslate"><span class="pre">分配内存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/8 更新 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">函数分类</span></code> 章节中的 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数特殊性</span></code> 说明</p></li>
<li><p class="sd-card-text">2023/7/9 更新 <code class="docutils literal notranslate"><span class="pre">分配内存</span></code> 章节更名为 <code class="docutils literal notranslate"><span class="pre">分配缓存</span></code></p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 修正 <code class="docutils literal notranslate"><span class="pre">内存分类</span></code> 章节中的一些错误，优化调理，增加新的说明。</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/9 增加 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span> <span class="pre">结构图</span></code> 章节</p></li>
<li><p class="sd-card-text">2023/7/10 增加 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数例程</p></li>
<li><p class="sd-card-text">2023/10/3 将 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存</span></code> 章节重命名为 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存信息</span></code></p></li>
<li><p class="sd-card-text">2023/10/3 更新 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节，增加 <code class="docutils literal notranslate"><span class="pre">堆</span></code> 说明。</p></li>
<li><p class="sd-card-text">2023/10/3 更新 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 章节，更新 <code class="docutils literal notranslate"><span class="pre">队列族</span></code> 说明图示。</p></li>
<li><p class="sd-card-text">2023/10/3 更新 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span> <span class="pre">结构图</span></code> 章节，更新说明图示。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 章节中的说明。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">分配缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">获取</span> <span class="pre">Vulkan</span> <span class="pre">支持的缓存信息</span></code> 章节。将 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 更改为 <code class="docutils literal notranslate"><span class="pre">内存</span></code> 。</p></li>
<li><p class="sd-card-text">2023/10/4 更新 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">VkAllocationCallbacks*</span> <span class="pre">pAllocator</span></code> 说明。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">内存管理</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/6 更新 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 章节。修正 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap::size</span></code> 单位讲解错误。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">回收内存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/6 增加 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/12 增加开头 <code class="docutils literal notranslate"><span class="pre">篇幅</span></code> 注意事项。</p></li>
<li><p class="sd-card-text">2023/10/12 增加 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/12 增加 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 更新 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 更新 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkDeviceSize</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkBufferUsageFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/15 增加 <code class="docutils literal notranslate"><span class="pre">VkSharingMode</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">VkImageType</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/18 增加 <code class="docutils literal notranslate"><span class="pre">VkExtent3D</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkSampleCountFlagBits</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageTiling</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageUsageFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkFormat</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageLayout</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/19 增加 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span> <span class="pre">其他参数和综述</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">VkImageLayout</span></code> 章节。修正一些语句不通顺的地方。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">VkImageUsageFlags</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span> <span class="pre">其他参数和综述</span></code> 章节。</p></li>
<li><p class="sd-card-text">2023/10/21 更新 <code class="docutils literal notranslate"><span class="pre">综述</span></code> 章节。</p></li>
</ul>
</div>
</details><p>由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 比较复杂，为了更好的入门 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，还是大致过一遍 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的核心思路，这对以后的学习很有帮助。</p>
<div class="caution admonition">
<p class="admonition-title">篇幅</p>
<p>该 <code class="docutils literal notranslate"><span class="pre">纵览</span></code> 章节会比较长。但也推荐您通读一遍。之后会分章节进行精讲。</p>
</div>
<section id="vulkan">
<h2>Vulkan 能为我们做什么<a class="headerlink" href="#vulkan" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 最主要的任务就是为我们提供了 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 并行计算的接口。是的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 仅仅只是规定了一套接口，其并没有接口的具体实现，而实现是需要硬件厂商自己适配实现，所以市面上并不是所有硬件设备都支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 。像 <code class="docutils literal notranslate"><span class="pre">NVIDIA</span></code> 、 <code class="docutils literal notranslate"><span class="pre">AMD</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Intel</span></code> 等国际大厂基本提供了完整的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code>
核心标准接口。而像国产的后起之秀 <a class="reference external" href="https://www.mthreads.com/">摩尔线程</a> 也在努力适配 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准（ <span class="sd-sphinx-override sd-badge sd-bg-warning sd-bg-text-warning">景嘉微你要加油啊</span>）。由于标准的实现都是自家的，所以每家厂商都可以根据自家设备的特点进行优化和扩展，这样在提供 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心功能的基础上也推出了自家的扩展功能，而扩展功能往往是该设备的卖点（比如硬件实时光线追踪扩展功能）。</p>
<p>而在使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 时，相比于标准，我们往往更关注于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 所提供的功能，主要的功能如下：</p>
<ul class="simple">
<li><p>光栅化渲染</p></li>
<li><p>实时光线追踪</p></li>
<li><p>视频编解码</p></li>
<li><p>（通用）并行计算</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">光栅化渲染</span></code> 应该是最主要的功能了（同时也是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的核心功能）。该章节也主要以 <code class="docutils literal notranslate"><span class="pre">光栅化渲染</span></code> 为核心进行纵览。</p>
</section>
<section id="id3">
<h2>Vulkan 的接口<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的接口，也就是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数，最开始是使用 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言发布的，有些繁琐，后来推出了 <code class="docutils literal notranslate"><span class="pre">C++</span></code> 版本的接口，现在 <code class="docutils literal notranslate"><span class="pre">Python</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Java</span></code> 和 <code class="docutils literal notranslate"><span class="pre">C#</span></code> 等高级语言也陆续支持开发 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的家族也在慢慢壮大。</p>
<p>本教程主要是用最原始的 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言版本进行讲解。</p>
</section>
<section id="id4">
<h2>获取 Vulkan 接口<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 只是一套标准，具体的实现都在硬件驱动中，为了能够使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 驱动硬件设备，我们需要获取驱动中 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准实现的接口。</p>
<section id="id5">
<h3>加载 Vulkan 动态库<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中提供了 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 进行 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准实现接口的获取。根据前文介绍我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 对应着 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库，所以我们第一步就是加载 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库。</p>
<div class="note admonition">
<p class="admonition-title">Vulkan 的动态库</p>
<p><code class="docutils literal notranslate"><span class="pre">Windows</span></code> 操作系统上 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的动态库为 <code class="docutils literal notranslate"><span class="pre">vulkan-1.dll</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 上的为 <code class="docutils literal notranslate"><span class="pre">libvulkan.so.1</span></code> 或 <code class="docutils literal notranslate"><span class="pre">libvulkan.so</span></code> 。</p>
</div>
<div class="hint admonition">
<p class="admonition-title">Vulkan 的静态库</p>
<p>为什么不是用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的静态库呢？最主要的原因来源于 <a class="reference external" href="https://github.com/KhronosGroup/Vulkan-Loader/blob/main/docs/LoaderApplicationInterface.md#static-linking">Vulkan Loader 的 Static Linking</a> 文档：</p>
<blockquote>
<div><p>In previous versions of the loader, it was possible to statically link the loader. This was removed and is no longer possible. The decision to remove static linking was because of changes to the driver which made older applications that statically linked unable to find newer drivers.</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 之前的版本中，是可以静态链接 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 的。这将会在不久的将来移除。这是由于之前静态链接的老程序无法找到新的驱动。</p>
</div></blockquote>
<p>此外静态链接有如下问题：</p>
<ul class="simple">
<li><p>除非重编译链接原工程否则永远得不到新 <code class="docutils literal notranslate"><span class="pre">Loader</span></code> 内容</p></li>
<li><p>包含的两个库可能会链接了不同版本的 <code class="docutils literal notranslate"><span class="pre">Loader</span></code></p></li>
</ul>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-0">
Windows 加载</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Windows.h&gt;</span>

<span class="n">HMODULE</span><span class="w"> </span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">&quot;vulkan-1.dll&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-1">
Linux 加载</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dlfcn.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libvulkan.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RTLD_NOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTLD_LOCAL</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">library</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">library</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libvulkan.so&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">RTLD_NOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RTLD_LOCAL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id6">
<h3>Vulkan 函数分类<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>之后我们就可以从加载的动态库中获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的函数了，但是在获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数前我们需要先介绍一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中函数的分类：</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Instance 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 进行交互。主要是获取一些与设备不相关与环境相关的函数。</dt><dd><ul>
<li><dl class="simple">
<dt><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">全局函数</span> 在 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数中有几个函数为全局函数。所谓全局函数是指任何驱动都需要实现的接口，并且用户可直接无条件获取其实现。全局函数如下：</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceExtensionProperties</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceLayerProperties</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">PhysicalDevice 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 进行交互。主要是一些获取硬件设备相关信息的函数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">Device 域函数</span> 主要是通过 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数接口获取，该类函数大部分与 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 进行交互。主要是获取一些与硬件设备相关的功能函数。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">PhysicalDevice 域函数特殊性</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 文档中 <a class="reference external" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#_extending_physical_device_core_functionality">4.1.1 Extending Physical Device Core Functionality</a> 中有相关 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 的描述。</p>
<blockquote>
<div><p>当物理设备支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本等于或高于对应函数发布时的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本的话，用户可以使用对应函数。换句话就是，如果在创建 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境时（创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 时）使用了较低版本，但是物理设备支持的版本高于此版本（ <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> ），并且 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 在物理设备支持的高版本中被定义并实现，则可以获取高版本的 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 使用。</p>
</div></blockquote>
<p>一般可以认为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span></code> 域函数为特殊的 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数。</p>
</div>
<div class="note admonition">
<p class="admonition-title">vkGetInstanceProcAddr 和 Device 域函数</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中并没有禁止用户使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 获得 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数，但这是不推荐的，当有多个硬件设备时会造成模棱两可的函数获取。比如电脑上插着两个显卡，一个是摩尔线程的，一个是景嘉微的，这两个设备都支持绘制函数 <code class="docutils literal notranslate"><span class="pre">vkCmdDraw</span></code> 函数 ，但是到底获取的是哪个设备的实现是由 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">Loader</span></code> 定义的，用户并不能知道返回的函数是哪个设备的实现。</p>
</div>
</section>
<section id="vkgetinstanceprocaddr">
<h3>vkGetInstanceProcAddr<a class="headerlink" href="#vkgetinstanceprocaddr" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中获取 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数，提供了统一的 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数获取接口，如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">VKAPI_PTR</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_vkVoidFunction</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">PFN_vkVoidFunction</span><span class="w"> </span><span class="nf">vkGetInstanceProcAddr</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pName</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">instance</span> 获取 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 兼容的函数接口，或是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 用于获取不依赖任何 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的函数。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pName</span> 获取的接口函数名称。</p></li>
</ul>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 函数之后就可以使用该函数获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数了。</p>
<div class="note admonition">
<p class="admonition-title">获取全局函数</p>
<p>获取全局函数时 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code></p>
</div>
<div class="note admonition">
<p class="admonition-title">PFN_{函数名}</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中，所有的接口函数都有对应的函数指针声明，命名规则为 <code class="docutils literal notranslate"><span class="pre">PFN_{函数名}</span></code> 。</p>
</div>
<div class="note admonition">
<p class="admonition-title">PFN_vkVoidFunction 与 vkGetInstanceProcAddr</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型函数指针。但是我们想获得 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中如 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 这样的函数指针，该指针并不是 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型的，而是 <code class="docutils literal notranslate"><span class="pre">PFN_vkCreateInstance</span></code> 类型的，如何从 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> 类型获得 <code class="docutils literal notranslate"><span class="pre">PFN_vkCreateInstance</span></code> 类型呢？
在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中规定直接使用强制类型转换即可。下文有示例。</p>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-2" name="sd-tab-set-1" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-2">
Windows 获取</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="w"> </span><span class="n">vkGetInstanceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetInstanceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<input id="sd-tab-item-3" name="sd-tab-set-1" type="radio">
</input><label class="sd-tab-label" for="sd-tab-item-3">
Linux 获取</label><div class="sd-tab-content docutils">
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="w"> </span><span class="n">vkGetInstanceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetInstanceProcAddr</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">library</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetInstanceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>之后就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 获取 <code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域的函数了。比如获取 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数接口：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkCreateInstance</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateInstance</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">VK_NULL_HANDLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateInstance&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">VK_NULL_HANDLE</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 被定义为空或无效句柄，一般被声明为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 、 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>对于获取 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span></code> 域函数和 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数将会在后文有所体现。</p>
</div>
<div class="note admonition">
<p class="admonition-title">句柄</p>
<p>英文为 <code class="docutils literal notranslate"><span class="pre">Handle</span></code> ，一般认为句柄与唯一识别号作用相同，一个句柄代表一个具体对象，函数作用在句柄上，内部是在修改句柄背后对应的那个对象。</p>
</div>
</section>
</section>
<section id="vulkan-vkinstance">
<h2>Vulkan 最初之物 VkInstance<a class="headerlink" href="#vulkan-vkinstance" title="Link to this heading">#</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中首先要创建的就是 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 对象。该对象包含了用户设置的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境信息，包括使用的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的版本信息等，用于初始化 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 环境，并构建出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 这个繁杂的系统根基。 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;</span>

<span class="n">VK_DEFINE_HANDLE</span><span class="p">(</span><span class="n">VkInstance</span><span class="p">)</span>
</pre></div>
</div>
<p>从 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 定义可知为一个句柄，该句柄为一个结构体指针。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有的对象都是一个句柄。</p>
<p>如上 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 声明等价于:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstance_T</span><span class="o">*</span><span class="w"> </span><span class="n">VkInstance</span><span class="p">;</span>
</pre></div>
</div>
<p>也就是说 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 在底层其实是作为一个类型为 <code class="docutils literal notranslate"><span class="pre">VkInstance_T</span></code> 的指针在使用。</p>
<div class="note admonition">
<p class="admonition-title">Vulkan 中的句柄</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中并不是所有的句柄都是指针类型，也有可能是一个 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位的无符号整形，具体是什么类型与平台相关。但用户并不需要关心句柄的底层表达， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中对所有的句柄都做了分别进行了声明，这样用户只需要使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供的句柄声明即可。
比如声明一个未初始化的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄（对象）：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
</pre></div>
</div>
</div>
<section id="vkinstance">
<h3>创建 VkInstance<a class="headerlink" href="#vkinstance" title="Link to this heading">#</a></h3>
<section id="vkcreateinstance">
<h4>vkCreateInstance<a class="headerlink" href="#vkcreateinstance" title="Link to this heading">#</a></h4>
<p>我们通过之前获取到的 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 。相关声明如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateInstance</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="w">                 </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkInstance</span><span class="o">*</span><span class="w">                                 </span><span class="n">pInstance</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 指向 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 数据结构对象，用于控制 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的创建。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pInstance</span> 创建的目标 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 结果。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 属于全局函数。</p>
</div>
<div class="note admonition">
<p class="admonition-title">pAllocator</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中创建句柄是需要设置内存分配器的，也就是 <code class="docutils literal notranslate"><span class="pre">pAllocator</span></code> ，这对于统计内存使用情况和自定义非常重要，如果没有自定义分配器的话也可以是直接传 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> ，这将会使用 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 内置的分配器进行分配。</p>
</div>
<p>如果创建成功将会返回 <code class="docutils literal notranslate"><span class="pre">VkResult::VK_SUCCESS</span></code> 枚举值，否则将返回错误结果枚举值。</p>
<div class="note admonition">
<p class="admonition-title">VK_SUCCESS</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中返回的大多数结果值来说，成功基本都是 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> ，否则就是失败（有极个别返回其他结果也可以算作成功，遇到再说）。还有一点需要注意的是， <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 的枚举值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> ：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_SUCCESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="n">VkResult</span><span class="p">;</span>
</pre></div>
</div>
<p>也就是，不应该出现如下判断：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="c1">// 如果此时 result 为 VK_SUCCESS ，而 VK_SUCCESS 的枚举值为 0 ，会导致判定不满足条件。</span>
<span class="p">...</span>
</pre></div>
</div>
<p>而正确的做法为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
</section>
<section id="vkinstancecreateinfo">
<h4>VkInstanceCreateInfo<a class="headerlink" href="#vkinstancecreateinfo" title="Link to this heading">#</a></h4>
<p>来看一下 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 的定义：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkInstanceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkInstanceCreateFlags</span><span class="w">       </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkApplicationInfo</span><span class="o">*</span><span class="w">    </span><span class="n">pApplicationInfo</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">enabledLayerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">          </span><span class="n">ppEnabledLayerNames</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">enabledExtensionCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">          </span><span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkInstanceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 是 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateFlagBits</span></code> 所表示的位域值，用于设置 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的行为。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApplicationInfo</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向应用信息结构体，用于  <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 的细节设置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledLayerCount</span> 激活的 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledLayerNames</span> 指向数量为 <code class="docutils literal notranslate"><span class="pre">enabledLayerCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 字符串数组，用于设置要激活的 <code class="docutils literal notranslate"><span class="pre">layer</span></code>。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 激活 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 扩展的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 指向数量为 <code class="docutils literal notranslate"><span class="pre">enabledExtensionCount</span></code> 的扩展字符串数组，用于设置要激活的 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 扩展。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">sType 与 pNext</p>
<p>初次学习 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 时会有个疑问： <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 已经是一个结构体了为什么还有使用 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 再指定一遍结构体类型呢？而且 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 成员，为什么？</p>
<p>这就不得不说明一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的扩展模块了。随着时代的发展，类似于 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo</span></code> 结构体中的数据可能并不满足于技术背景，需要进行扩展，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 引入了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员，而 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span></code> 类型，这也就是说 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 可以
指向任意一个类型对象的数据地址。由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中几乎所有的结构体内都声明了 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 成员，这样每个结构体都可以使用 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指向下一个 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的结构体，这样一个接着一个将结构体进行串链就形成了一个扩展链。</p>
<div class="mermaid">
            flowchart LR
   subgraph VkInstanceCreateInfo
      direction TB
         VkInstanceCreateInfo_sType[&quot;sType = VkStructureType::VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO&quot;]
         VkInstanceCreateInfo_pNext[&quot;pNext&quot;]
         %%VkInstanceCreateInfo_sType-.-&gt;VkInstanceCreateInfo_pNext
   end

   subgraph VulkanSomeStructureA[&quot;Vulkan某个结构体类型A&quot;]
      direction TB
         VulkanSomeStructureA_sType[&quot;sType = VkStructureType::某个结构体A类型&quot;]
         VulkanSomeStructureA_pNext[&quot;pNext&quot;]
         %%VulkanSomeStructureA_sType-.-&gt;VulkanSomeStructureA_pNext
   end

   subgraph VulkanSomeStructureB[&quot;Vulkan某个结构体类型B&quot;]
      direction TB
         VulkanSomeStructureB_sType[&quot;sType = VkStructureType::某个结构体B类型&quot;]
         VulkanSomeStructureB_pNext[&quot;pNext&quot;]
         %%VulkanSomeStructureB_sType-.-&gt;VulkanSomeStructureB_pNext
   end

   VkInstanceCreateInfo_pNext--&gt;VulkanSomeStructureA
   VulkanSomeStructureA_pNext--&gt;VulkanSomeStructureB
   VulkanSomeStructureB_pNext--&gt;a2[&quot;...&quot;]
        </div><p>这样驱动就可以根据 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指针链遍历所有的结构体数据了，但是有一个问题 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 只是个 <code class="docutils literal notranslate"><span class="pre">void*</span></code> 指针，驱动在获取到 <code class="docutils literal notranslate"><span class="pre">pNext</span></code> 指向的地址时并不知道这个地址应该按照哪种结构体类型进行解析，这时 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 的作用就体现出来了，驱动获取该地址下的 <code class="docutils literal notranslate"><span class="pre">sType</span></code> 的数据，这样驱动就知道如何解析此块地址了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 驱动内部可能的实现</span>

<span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">某个结构体的地址</span><span class="p">;</span>
<span class="n">VkStructureType</span><span class="w"> </span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_MAX_ENUM</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sType</span><span class="p">,</span><span class="w"> </span><span class="n">pNext</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">VkStructureType</span><span class="p">));</span>

<span class="k">switch</span><span class="p">(</span><span class="n">sType</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">case</span><span class="w"> </span><span class="no">VkStructureType</span><span class="o">::</span><span class="no">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">:</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="w"> </span><span class="n">instance_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">VkInstanceCreateInfo</span><span class="o">*</span><span class="p">)(</span><span class="n">pNext</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">break</span><span class="p">;</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="vkapplicationinfo">
<h4>VkApplicationInfo<a class="headerlink" href="#vkapplicationinfo" title="Link to this heading">#</a></h4>
<p>目前我们只需要关注 <code class="docutils literal notranslate"><span class="pre">VkApplicationInfo</span></code> 就好，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkApplicationInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">    </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">        </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">        </span><span class="n">pApplicationName</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">applicationVersion</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">        </span><span class="n">pEngineName</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">engineVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">           </span><span class="n">apiVersion</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkApplicationInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApplicationName</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向一个以空字符为结尾的 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> 字符串，用于表示用户自定义应用名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">applicationVersion</span> 一个无符号整型，用于用户自定义应用版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pEngineName</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向一个以空字符为结尾的 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code> 字符串，用于表示用户自定义引擎名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">engineVersion</span> 一个无符号整型，用于用户自定义引擎版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">apiVersion</span> 应用打算使用的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的最高版本，并且忽略 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">patch</span></code> 版本。</p></li>
</ul>
<p>如果设备驱动只支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 而用户设置的 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本高于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 的话， <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">VK_ERROR_INCOMPATIBLE_DRIVER</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">VkInstanceCreateInfo::pApplicationInfo</span></code> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的话，等价于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">VK_MAKE_API_VERSION(0,1,0,0)</span></code> 也就是 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 版本。</p>
</div>
<p>这里我们主要关注 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 参数，这是一个非常重要的参数。该参数指定的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本决定了应用可以使用该版本及以前的版本功能，并不能使用高于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本功能。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 如何组成 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本的，已在 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 的 <code class="docutils literal notranslate"><span class="pre">Vulkan的版本</span></code> 中有讲解。</p>
</div>
<p>现在我们就可以创建一个最简单的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 版本的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkApplicationInfo</span><span class="w"> </span><span class="n">application_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_APPLICATION_INFO</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pApplicationName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">applicationVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">pEngineName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">engineVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">application_info</span><span class="p">.</span><span class="n">apiVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_MAKE_API_VERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="n">VkInstanceCreateInfo</span><span class="w"> </span><span class="n">instance_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">pApplicationInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">application_info</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">enabledLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">instance_create_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateInstance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instance</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">创建失败</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>经过如上的代码，你可以发现创建一个句柄需要填写各种各样的 <code class="docutils literal notranslate"><span class="pre">Vk{结构体名称}Info</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Vk{句柄名称}CreateInfo</span></code> 等结构体。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中各式各样的结构体占了绝大多数。给人一种：<span class="sd-sphinx-override sd-badge sd-bg-info sd-bg-text-info">来，我这样有张大表，先把表填了，我才知道接下来如何干活</span> 的感觉。</p>
</div>
<div class="hint admonition">
<p class="admonition-title">现在我们面临一个问题</p>
<p>我咋知道设备支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的哪个版本？</p>
</div>
</section>
</section>
</section>
<section id="id7">
<h2>获取支持的 Vulkan 版本<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>由于历史原因 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 标准在设计时并没有考虑到获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本，只有获取驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。在 <code class="docutils literal notranslate"><span class="pre">开始于</span> <span class="pre">Vulkan</span> <span class="pre">SDK</span></code> 中我们知道 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本有两个版本，一个是系统端支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本，一个是驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。为什么会有两个版本？</p>
<p>这是由于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的函数分为不同域。系统端支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本主要是用于配置系统支持的功能、 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 和扩展，不同版本支持的功能、 <code class="docutils literal notranslate"><span class="pre">layer</span></code> 和扩展不尽相同。驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本主要是用于配置硬件设备支持的功能和扩展，不同版本支持的功能和扩展不尽相同。</p>
<p>之后在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.1</span></code> 标准中，推出了 <code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 接口来获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p>
<div class="note admonition">
<p class="admonition-title">硬件设备的 Layer</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 中硬件设备是有相关的 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 功能的，但用处不大，比较鸡肋，后来 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准组将硬件设备的 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 遗弃，但对外的接口还保留着。</p>
</div>
<p>由于在支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span> <span class="pre">1.0</span></code> 的实现中 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 可能由于 <code class="docutils literal notranslate"><span class="pre">VK_ERROR_INCOMPATIBLE_DRIVER</span></code> 失败返回，所以需要在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 之前获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。获取流程如下：</p>
<div class="mermaid">
            flowchart TD
   TryToGetvkEnumerateInstanceVersion[&quot;尝试获取 vkEnumerateInstanceVersion 函数接口实现&quot;]
   IsNull{&quot;是否为 NULL&quot;}
   SupportVulkan_1_0[&quot;支持Vulkan 1.0&quot;]
   SupportVulkanFromvkEnumerateInstanceVersion[&quot;支持 vkEnumerateInstanceVersion 中获得的 Vulkan 版本&quot;]

   TryToGetvkEnumerateInstanceVersion--&gt;IsNull
   IsNull--是--&gt;SupportVulkan_1_0
   IsNull--否--&gt;SupportVulkanFromvkEnumerateInstanceVersion
        </div><section id="vkenumerateinstanceversion">
<h3>vkEnumerateInstanceVersion<a class="headerlink" href="#vkenumerateinstanceversion" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vkEnumerateInstanceVersion</span></code> 函数定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEnumerateInstanceVersion</span><span class="p">(</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pApiVersion</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pApiVersion</span> <code class="docutils literal notranslate"><span class="pre">instance</span></code> 域函数支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p><code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 属于全局函数。</p>
</div>
<p>接下来就让我们获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本吧：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_vkEnumerateInstanceVersion</span><span class="w"> </span><span class="n">vkEnumerateInstanceVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkEnumerateInstanceVersion</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">VK_NULL_HANDLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkEnumerateInstanceVersion&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">vkEnumerateInstanceVersion</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vulkan_version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkEnumerateInstanceVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vulkan_version</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">VK_SUCCESS</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">Vulkan</span><span class="w"> </span><span class="n">Loader</span><span class="w"> </span><span class="n">或任意一个</span><span class="w"> </span><span class="n">Layer</span><span class="w"> </span><span class="n">发生了内存分配失败</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">vulkan_version</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">VK_MAKE_API_VERSION</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h2>获取物理硬件设备<a class="headerlink" href="#id8" title="Link to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 具有能够发现连接在主板上支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 设备的能力。通过 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数获取支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备。</p>
<section id="vkenumeratephysicaldevices">
<h3>vkEnumeratePhysicalDevices<a class="headerlink" href="#vkenumeratephysicaldevices" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkEnumeratePhysicalDevices</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkInstance</span><span class="w">                                  </span><span class="n">instance</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pPhysicalDeviceCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="o">*</span><span class="w">                           </span><span class="n">pPhysicalDevices</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">instance</span> 是之前使用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 创建的 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pPhysicalDeviceCount</span> 是用于指定或获取的物理设备数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pPhysicalDevices</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么是数量不小于 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 数组。</p></li>
</ul>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数将会将查询到支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备数量写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 所指向的内存中，所以 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 必须是一个有效指针。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数将会将 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 数量的有效 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄依次写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDevices</span></code> 指向的数组中。如果 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 指定的数量小于支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备数量的话， <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 将会写入 <code class="docutils literal notranslate"><span class="pre">pPhysicalDeviceCount</span></code> 个物理设备句柄到数组中并返回 <code class="docutils literal notranslate"><span class="pre">VK_INCOMPLETE</span></code> 表示并不是所有设备都写入数组返回。</p>
<p>如果一切正常 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 将会返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄不需要通过类似 <code class="docutils literal notranslate"><span class="pre">vkCreatePhysicalDevice</span></code> 这样的函数创建（ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准也没有该函数 ），而是在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 时内部已经做好了管理。也就是说 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 的生命周期与 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄一致。</p>
</div>
<p>接下来就让我们获取支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的物理设备吧：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkEnumeratePhysicalDevices</span><span class="w"> </span><span class="n">vkEnumeratePhysicalDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkEnumeratePhysicalDevices</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkEnumeratePhysicalDevices&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>此时 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 的第一个参数不为 <code class="docutils literal notranslate"><span class="pre">VK_NULL_HANDLE</span></code> 而为有效 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 句柄。</p>
</div>
<p>之后即可以获取到物理设备了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_device_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_count</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">(</span><span class="n">physical_device_count</span><span class="p">);</span>
<span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_count</span><span class="p">,</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</pre></div>
</div>
</section>
</section>
<section id="id9">
<h2>获取物理设备属性<a class="headerlink" href="#id9" title="Link to this heading">#</a></h2>
<p>当获取到物理设备 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 句柄之后，可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 函数获取对应物理设备的属性。</p>
<section id="vkgetphysicaldeviceproperties">
<h3>vkGetPhysicalDeviceProperties<a class="headerlink" href="#vkgetphysicaldeviceproperties" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceProperties</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceProperties</span><span class="o">*</span><span class="w">                 </span><span class="n">pProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 对应要获取属性的物理设备的句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pProperties</span> 对应返回的物理设备属性。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties</span></code> 定义如下：</p>
</section>
<section id="vkphysicaldeviceproperties">
<h3>VkPhysicalDeviceProperties<a class="headerlink" href="#vkphysicaldeviceproperties" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkPhysicalDeviceProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">apiVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">driverVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">vendorID</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                            </span><span class="n">deviceID</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceType</span><span class="w">                </span><span class="n">deviceType</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w">                                </span><span class="n">deviceName</span><span class="p">[</span><span class="n">VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">                             </span><span class="n">pipelineCacheUUID</span><span class="p">[</span><span class="n">VK_UUID_SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceLimits</span><span class="w">              </span><span class="n">limits</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkPhysicalDeviceSparseProperties</span><span class="w">    </span><span class="n">sparseProperties</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">apiVersion</span> 该设备驱动支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">driverVersion</span> 该设备驱动版本。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">vendorID</span> 设备供应商的 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceID</span> 设备的 <code class="docutils literal notranslate"><span class="pre">ID</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceType</span> 设备类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">deviceName</span> 设备名称。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pipelineCacheUUID</span> 设备的通用唯一识别码（ <code class="docutils literal notranslate"><span class="pre">universally</span> <span class="pre">unique</span> <span class="pre">identifier</span></code> ）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">limits</span> 设备的限值信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sparseProperties</span> 稀疏数据属性。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">稀疏</p>
<p><code class="docutils literal notranslate"><span class="pre">稀疏</span></code> 为离散在内存各处的大量数据，这些数据可以被一并使用，常用表述数据量巨大的资源。</p>
</div>
<p>这里我们主要关注 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 和 <code class="docutils literal notranslate"><span class="pre">deviceType</span></code> 属性。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 主要是用于描述对应设备支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的版本，该版本很重要，说明设备只支持 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 版本之前的标准，如果在此设备上使用高于 <code class="docutils literal notranslate"><span class="pre">apiVersion</span></code> 版本的功能的话将会导致错误或未定义行为。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deviceType</span></code> 主要是用于描述对应设备是独立显卡还是集成显卡。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceType</span></code> 枚举值定义如下：</p>
</section>
<section id="vkphysicaldevicetype">
<h3>VkPhysicalDeviceType<a class="headerlink" href="#vkphysicaldevicetype" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkPhysicalDeviceType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_OTHER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_PHYSICAL_DEVICE_TYPE_CPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_OTHER</span> 该设备类型不与任何其他类型匹配， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中未定义的设备类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span> 集成显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span> 独立显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU</span> 虚拟环境中的虚拟显卡。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_PHYSICAL_DEVICE_TYPE_CPU</span> 中央处理器（ <code class="docutils literal notranslate"><span class="pre">CPU</span></code> ）。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">VK_PHYSICAL_DEVICE_TYPE_CPU</p>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_CPU</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 类型的设备，但是在通过 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 获取物理设备时，并不一定会得到插在主板上的 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 设备句柄，由于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 并不一定支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> ，所以 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 不一定能够获得，大部分支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备还是显卡设备。</p>
</div>
<p>在使用时，一般首选使用 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU</span></code> 独立显卡，之后再考虑使用 <code class="docutils literal notranslate"><span class="pre">VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</span></code> 集成显卡。</p>
<p>获取物理属性例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceProperties</span></code> 获取相应的设备属性了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_devices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的所有设备</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">physical_devices</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkPhysicalDeviceProperties</span><span class="w"> </span><span class="n">physical_device_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">   </span><span class="n">vkGetPhysicalDeviceProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_properties</span><span class="p">);</span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Physical Device Name:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">physical_device_properties</span><span class="p">.</span><span class="n">deviceName</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id10">
<h2>设备队列<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>接下来简单介绍一下 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的设备队列。</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的每一个 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDevice</span></code> 物理设备上都有一到多个设备队列。设备队列用于执行所有的用户任务指令，包括渲染、计算、查询、剔除和构建等等各种任务指令。</p>
<p>每个设备队列支持一到多个功能域，这些功能域分为如下 <code class="docutils literal notranslate"><span class="pre">5</span></code> 种：</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">图形</span> 主要用于图形渲染，执行各种渲染绘制指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">计算</span> 主要用于执行并行计算（计算着色器），执行各种计算指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">转移</span> 主要用于执行资源的布局转移并支持在不同队列中进行转移，执行各种转移指令。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">稀疏绑定</span> 主要用于稀疏内存的管理。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">受保护</span> 主要用于受保护的内存的管理。</p></li>
</ul>
<p>在使用时常用的为 <code class="docutils literal notranslate"><span class="pre">图形</span></code> 、 <code class="docutils literal notranslate"><span class="pre">计算</span></code> 和 <code class="docutils literal notranslate"><span class="pre">转移</span></code> 功能的队列。</p>
<div class="important admonition">
<p class="admonition-title">设备队列和功能域</p>
<p>每个物理设备上支持一到多个设备队列，每个设备队列支持一到多个功能域。这里很有可能多个设备队列支持相同的功能域。比如同一物理设备上的设备队列 <code class="docutils literal notranslate"><span class="pre">A</span></code> 和 <code class="docutils literal notranslate"><span class="pre">B</span></code> 都支持图形和计算功能。</p>
</div>
<section id="id11">
<h3>获取设备队列（族）信息<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中是通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数获取：</p>
<section id="vkgetphysicaldevicequeuefamilyproperties">
<h4>vkGetPhysicalDeviceQueueFamilyProperties<a class="headerlink" href="#vkgetphysicaldevicequeuefamilyproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">                                   </span><span class="n">pQueueFamilyPropertyCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkQueueFamilyProperties</span><span class="o">*</span><span class="w">                    </span><span class="n">pQueueFamilyProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 要获取属性的物理设备的句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyPropertyCount</span> 是用于指定或获取的设备队列族数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyProperties</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么是数量不小于 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组。</p></li>
</ul>
<p>该函数的用法与 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 函数是一样的。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数将会将查询到的设备队列族数量写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 所指向的内存中，所以 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 必须是一个有效指针。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的话 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数将会将 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 数量的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数据依次写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 指向的数组中。如果 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 指定的数量小于支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备队列数量的话， <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 将会写入 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyPropertyCount</span></code> 个设备队列族信息。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<div class="note admonition">
<p class="admonition-title">队列族</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中设备队列是按照 <code class="docutils literal notranslate"><span class="pre">族</span></code> 进行管理的，前面我们知道一个物理设备上的可能会有多个设备队列支持相同的功能域，这些支持相同功能域的设备队列算作同一族。</p>
<figure class="align-default" id="id27">
<img alt="_images/vk_queue_family_struct.svg" src="_images/vk_queue_family_struct.svg" /><figcaption>
<p><span class="caption-text">如上图中。队列0、1、2三个队列属于队列族A，则这三个队列支持计算、图形和转移功能。队列3属于队列族B，则该队列支持计算和转移功能。</span><a class="headerlink" href="#id27" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
<p>设备队列族 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 定义如下：</p>
</section>
<section id="vkqueuefamilyproperties">
<h4>VkQueueFamilyProperties<a class="headerlink" href="#vkqueuefamilyproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkQueueFamilyProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkQueueFlags</span><span class="w">    </span><span class="n">queueFlags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">queueCount</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">        </span><span class="n">timestampValidBits</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkExtent3D</span><span class="w">      </span><span class="n">minImageTransferGranularity</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkQueueFamilyProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFlags</span> 为队列族位域，用于描述该队列族支持的功能域。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCount</span> 该队列族中的队列数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">timestampValidBits</span> 时间戳中有效的位数，有效的位数范围为 <code class="docutils literal notranslate"><span class="pre">36</span></code> 到 <code class="docutils literal notranslate"><span class="pre">64</span></code> 位，如果为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 说明不支持时间戳。超出有效范围的位保证为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">minImageTransferGranularity</span> 在该族队列上进行图片转移操作时支持的最小转移粒度（大小）。</p></li>
</ul>
<p>目前我们主要关心 <code class="docutils literal notranslate"><span class="pre">queueFlags</span></code> 和 <code class="docutils literal notranslate"><span class="pre">queueCount</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">queueFlags</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 类型，其定义如下：</p>
</section>
<section id="vkqueueflags">
<h4>VkQueueFlags<a class="headerlink" href="#vkqueueflags" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">VkFlags</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">VkFlags</span><span class="w"> </span><span class="n">VkQueueFlags</span><span class="p">;</span>
</pre></div>
</div>
<p>可以看到 <code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 其实就是一个 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的标志位。</p>
<div class="note admonition">
<p class="admonition-title">VkFlags</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中所有的标志位 <code class="docutils literal notranslate"><span class="pre">Vk{标志位名称}Flags</span></code> 都为 <code class="docutils literal notranslate"><span class="pre">VkFlags</span></code> 也就是 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 。每一位对应的含义都在对应的 <code class="docutils literal notranslate"><span class="pre">Vk{标志位名称}FlagBits</span></code> 枚举中定义。</p>
</div>
<div class="note admonition">
<p class="admonition-title">标志位与位域</p>
<p>所谓标志位，也就是位域。像 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 其比特位有 <code class="docutils literal notranslate"><span class="pre">32</span></code> 个，如果某一比特位为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则说明对应的位域被激活，也就是对应位域表示的事物被激活。比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的二进制：0000 0000 0000 0000 0000 0000 0000 0001</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的二进制：0000 0000 0000 0000 0000 0000 0000 0010</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">likes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">某人的喜好</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">likes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">//什么也不喜欢</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LIKE_CAT_BI</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LIKE_CAT_BIT</span><span class="p">)</span><span class="w"> </span><span class="c1">//喜欢猫</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">)</span><span class="w"> </span><span class="c1">//喜欢狗</span>
<span class="k">if</span><span class="p">((</span><span class="n">likes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">LIKE_CAT_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">LIKE_DOG_BIT</span><span class="p">))</span><span class="w"> </span><span class="c1">//既喜欢猫，也喜欢狗</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VkQueueFlags</span></code> 对应位域的 <code class="docutils literal notranslate"><span class="pre">VkQueueFlagBits</span></code> 定义如下:</p>
</section>
<section id="vkqueueflagbits">
<h4>VkQueueFlagBits<a class="headerlink" href="#vkqueueflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkQueueFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_COMPUTE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_TRANSFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_QUEUE_SPARSE_BINDING_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">    </span><span class="n">VK_QUEUE_PROTECTED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_GRAPHICS_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">图形</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_COMPUTE_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">计算</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_TRANSFER_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">转移</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_SPARSE_BINDING_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">稀疏绑定</span></code> 功能。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_QUEUE_PROTECTED_BIT</span> 表示该队列族中的队列支持 <code class="docutils literal notranslate"><span class="pre">受保护</span></code> 功能。</p></li>
</ul>
<p>获取设备队列（族）信息例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceQueueFamilyProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceQueueFamilyProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 获取相应的设备队列（族）属性了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">queue_family_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkQueueFamilyProperties</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue_familys</span><span class="p">(</span><span class="n">queue_family_count</span><span class="p">);</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span><span class="w"> </span><span class="n">queue_familys</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="n">uint32_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uint32_max</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">queue_family_count</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">queue_familys</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">queueFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="o">::</span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkQueueFlagBits</span><span class="o">::</span><span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 寻找支持图形的队列族</span>
<span class="w">      </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">assert</span><span class="p">(</span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">uint32_max</span><span class="p">)</span><span class="w"> </span><span class="c1">//没找到支持图形的队列族</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">support_graphics_queue_family_index</p>
<p>需要获取存储对应设备队列族在 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组中的索引值，这会在之后使用到。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VK_QUEUE_GRAPHICS_BIT</p>
<p>我们一般倾向于需要支持 <code class="docutils literal notranslate"><span class="pre">VK_QUEUE_GRAPHICS_BIT</span></code> 图形功能的队列族，这是因为大部分设备队列族如果支持图形功能的话，其他的计算、转移和稀疏绑定功能也会同时支持。</p>
</div>
</section>
</section>
</section>
<section id="id12">
<h2>逻辑设备<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>在获得了物理设备句柄之后，我们需要在某个物理设备上创建逻辑设备，之后所有的操作都应用于此逻辑设备上。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中使用 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 句柄表示一个逻辑设备。</p>
<section id="id13">
<h3>创建逻辑设备<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p>首先需要使用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建逻辑设备。</p>
<section id="vkcreatedevice">
<h4>vkCreateDevice<a class="headerlink" href="#vkcreatedevice" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateDevice</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkPhysicalDevice</span><span class="w">                            </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkDeviceCreateInfo</span><span class="o">*</span><span class="w">                   </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="o">*</span><span class="w">                                   </span><span class="n">pDevice</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 为之前使用 <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDevices</span></code> 获取到的某个物理设备句柄，逻辑设备将在此物理设备上创建。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 表示逻辑设备的创建信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pDevice</span> 创建返回的逻辑设备 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 句柄。</p></li>
</ul>
<p>如果创建成功将会返回 <code class="docutils literal notranslate"><span class="pre">VK_SUCCESS</span></code> 。并且同一个物理设备可以创建多个逻辑设备。</p>
<p>创建逻辑设备的 <code class="docutils literal notranslate"><span class="pre">VkDeviceCreateInfo</span></code> 结构体定义如下：</p>
</section>
<section id="vkdevicecreateinfo">
<h4>VkDeviceCreateInfo<a class="headerlink" href="#vkdevicecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkDeviceCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">                    </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                        </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceCreateFlags</span><span class="w">                </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">queueCreateInfoCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkDeviceQueueCreateInfo</span><span class="o">*</span><span class="w">     </span><span class="n">pQueueCreateInfos</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">enabledLayerCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">                 </span><span class="n">ppEnabledLayerNames</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                           </span><span class="n">enabledExtensionCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w">                 </span><span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkPhysicalDeviceFeatures</span><span class="o">*</span><span class="w">    </span><span class="n">pEnabledFeatures</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 标志位，保留为将来使用。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCreateInfoCount</span> 为 <code class="docutils literal notranslate"><span class="pre">pQueueCreateInfos</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueCreateInfos</span> 指向 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 数组指针，用于逻辑设备创建设备队列。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledLayerCount</span> 为 <code class="docutils literal notranslate"><span class="pre">ppEnabledLayerNames</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledLayerNames</span> 指向字符串数组指针，用于启用设备 <code class="docutils literal notranslate"><span class="pre">Layer</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">enabledExtensionCount</span> 为 <code class="docutils literal notranslate"><span class="pre">ppEnabledExtensionNames</span></code> 数组的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">ppEnabledExtensionNames</span> 指向字符串数组指针，用于启用设备扩展。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkPhysicalDeviceFeatures</span> 设置要激活的物理设备特性。</p></li>
</ul>
<p>此时我们主要关心数量为 <code class="docutils literal notranslate"><span class="pre">queueCreateInfoCount</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">VkDeviceQueueCreateInfo</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pQueueCreateInfos</span></code> 数组。该数组用于在创建逻辑设备时指定创建的设备队列信息。该结构体定义如下：</p>
</section>
<section id="vkdevicequeuecreateinfo">
<h4>VkDeviceQueueCreateInfo<a class="headerlink" href="#vkdevicequeuecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkDeviceQueueCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">             </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                 </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceQueueCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueFamilyIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                    </span><span class="n">queueCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w">                </span><span class="n">pQueuePriorities</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkDeviceQueueCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 标志位。用于设置目标设备队列的行为。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 对应的队列族在 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数返回的 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 数组中的索引值。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueCount</span> 在对应的队列族中创建的设备队列数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueuePriorities</span> 设备队列优先级。指向数量为 <code class="docutils literal notranslate"><span class="pre">queueCount</span></code> 类型为 <code class="docutils literal notranslate"><span class="pre">float</span></code> 的数组，对应设置每一个设备队列的优先级。</p></li>
</ul>
<p>这里 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 成员非常重要，该成员对应着使用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 获取到的设备队列族在 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyProperties</span></code> 数组中的索引值，大部分情况会去选择支持图形功能的队列族所对应的索引。</p>
<p>这样我们就可以创建逻辑设备了，例程如下：</p>
<p>首先获取 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkCreateDevice</span><span class="w"> </span><span class="n">vkCreateDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateDevice</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateDevice&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建逻辑设备了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="n">中找到的支持图形功能的队列族索引</span><span class="p">;</span>

<span class="kt">float</span><span class="w"> </span><span class="n">queue_prioritie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="n">VkDeviceQueueCreateInfo</span><span class="w"> </span><span class="n">device_queue_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">queueCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">device_queue_create_info</span><span class="p">.</span><span class="n">pQueuePriorities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue_prioritie</span><span class="p">;</span>

<span class="n">VkDeviceCreateInfo</span><span class="w"> </span><span class="n">device_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">queueCreateInfoCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pQueueCreateInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_queue_create_info</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">enabledLayerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">device_create_info</span><span class="p">.</span><span class="n">pEnabledFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateDevice</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="device">
<h2>获取 Device 域函数<a class="headerlink" href="#device" title="Link to this heading">#</a></h2>
<p>在创建完逻辑设备 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 之后，与 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 及其产生的子对象（句柄）的所有交互函数都属于 <code class="docutils literal notranslate"><span class="pre">Device</span> <span class="pre">域函数</span></code> 。我们通过 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 提供的 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数获取 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
<section id="vkgetdeviceprocaddr">
<h3>vkGetDeviceProcAddr<a class="headerlink" href="#vkgetdeviceprocaddr" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">PFN_vkVoidFunction</span><span class="w"> </span><span class="nf">vkGetDeviceProcAddr</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w">                                 </span><span class="n">pName</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pName</span> 要获取的逻辑设备对应的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数驱动实现。</p></li>
</ul>
<p>该函数就是用于获取不同设备驱动实现的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 函数接口，不同的 <code class="docutils literal notranslate"><span class="pre">device</span></code> 支持的 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 扩展函数不尽相同，但是如果支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 特定版本的话（ <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceProperties::apiVersion</span></code> ）则一定能够获取 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 核心标准中的函数实现。</p>
<p>如果获取 <code class="docutils literal notranslate"><span class="pre">device</span></code> 对应驱动中没有实现的函数的话，将会返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>该函数的返回值与 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 一样为 <code class="docutils literal notranslate"><span class="pre">PFN_vkVoidFunction</span></code> ，与 <code class="docutils literal notranslate"><span class="pre">vkGetInstanceProcAddr</span></code> 一样， <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 在获取驱动中某一有效函数后需要强制转换成对应函数。</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 函数指针如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetDeviceProcAddr</span><span class="w"> </span><span class="n">vkGetDeviceProcAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetDeviceProcAddr</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetDeviceProcAddr&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 获取 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域的函数了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">}</span><span class="w"> </span><span class="n">vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vk</span><span class="p">{</span><span class="n">Device</span><span class="w"> </span><span class="n">域函数名</span><span class="p">})</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vk{Device 域函数名}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在创建完 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 之后，由于之后所有要调用的函数最终都作用在某一具体逻辑设备上（或由该逻辑设备创建的相关对象上），所以之后所有函数都是 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
</div>
</section>
</section>
<section id="id14">
<h2>获取设备队列<a class="headerlink" href="#id14" title="Link to this heading">#</a></h2>
<p>我们在创建逻辑设备时指定了需要使用的设备队列信息， <code class="docutils literal notranslate"><span class="pre">vkCreateDevice</span></code> 创建过程中会为我们创建对应的设备队列，之后我们需要通过 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数获取设备队列 <code class="docutils literal notranslate"><span class="pre">VkQueue</span></code> 句柄。</p>
<section id="vkgetdevicequeue">
<h3>vkGetDeviceQueue<a class="headerlink" href="#vkgetdevicequeue" title="Link to this heading">#</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetDeviceQueue</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">queueFamilyIndex</span><span class="p">,</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                                    </span><span class="n">queueIndex</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkQueue</span><span class="o">*</span><span class="w">                                    </span><span class="n">pQueue</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 创建设备队列时对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndex</span> 创建设备队列时对应的队列族索引。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueIndex</span> 对应着队列族中设备队列的索引。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueue</span> 将会返回 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 索引对应的队列族中，设备队列索引值为 <code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 的索引句柄。</p></li>
</ul>
<p>由于一个队列族中可能有多个设备队列，并且在创建逻辑设备时可以同时创建多个设备队列，索引此时需要用户指定 <code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 和 <code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 来获取对应的设备队列（句柄）。</p>
<p>在使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 获取设备队列句柄之前，需要先获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数指针：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetDeviceQueue</span><span class="w"> </span><span class="n">vkGetDeviceQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetDeviceQueue</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetDeviceQueue&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>获取 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 函数时使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceProcAddr</span></code> 获取，其为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数。</p>
</div>
<p>之后我们就可以使用 <code class="docutils literal notranslate"><span class="pre">vkGetDeviceQueue</span></code> 获取对应的设备队列句柄了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkDevice</span><span class="w"> </span><span class="p">;</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="n">中找到的支持图形功能的队列族索引</span><span class="p">;</span>

<span class="n">VkQueue</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">vkGetDeviceQueue</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">support_graphics_queue_family_index</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>由于在创建 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 代码示例中只指定了一个支持图形的队列，所以这里：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">queueFamilyIndex</span></code> 为之前获取的 <code class="docutils literal notranslate"><span class="pre">support_graphics_queue_family_index</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
</ul>
</div>
</section>
</section>
<section id="id15">
<h2>内存<a class="headerlink" href="#id15" title="Link to this heading">#</a></h2>
<section id="id16">
<h3>内存分类<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中函数主要分为两类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Instance</span></code> 域函数中主要在 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 能够访问的（主板上）内存中进行分配和访问。比如在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateInstance</span></code> 函数创建 <code class="docutils literal notranslate"><span class="pre">VkInstance</span></code> 时需要指定 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">VkAllocationCallbacks*</span> <span class="pre">pAllocator</span></code> 内存分配回调（一般回调内部使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 或 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 等进行分配）。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问的内存一般称为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存。</p>
<p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 域函数中主要在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 能够访问的内存（显存）中进行内存分配和访问。这一部分内存称为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存。</p>
<div class="important admonition">
<p class="admonition-title">const VkAllocationCallbacks* pAllocator</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 内存分配回调分配的内存将会存储在内存条中，该部分内存属于特殊的 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存，确切的说使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 或 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 等分配的内存，在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中不属于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 管理的范畴（ <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中属于 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端范畴，其本质上属于 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 范畴）。这里仅仅为了引出 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端做的简要引子。</p>
<p>有关 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 的具体用法将会在之后单独的章节中进行讲解。</p>
</div>
<p>由此引出了 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的两个 <code class="docutils literal notranslate"><span class="pre">端</span></code> 分类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端</p></li>
</ul>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端一般是指 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 可以访问的那部分资源（内存），而该部分资源可能存储在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备上的内存中也可能存储在内存条上的内存中。只不过这部分资源可以被 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 访问到并归为 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 管理范畴。</p>
<p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端表示 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备可访问的的专属资源（内存）。</p>
<p>这里可以看出内存条上的内存和 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上的显存都属于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 可访问的内存范畴。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中我们往往在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端将数据准备好，之后使用 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备访问该数据进行计算。然而 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端准备的数据只有 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 能够访问， <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备并不能直接访问 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存，为此 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准中为我们提供了可被 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 访问的 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存。
也就是说这一部分内存既可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问也可以被 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端访问。一般来说，我们会先将 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的数据拷贝至可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问也可以被 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端访问的内存中，之后再将这部分数据拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存中被 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 访问使用。</p>
<div class="mermaid">
            flowchart LR

   Host[&quot;Host 端\n（使用 new 或 malloc 分配内存）&quot;]
   HostAndDevice[&quot;Host 端与 Device 都可访问的内存&quot;]
   Device[&quot;Device 端内存&quot;]

   Host--拷贝--&gt;HostAndDevice--&quot;（总线）拷贝&quot;--&gt;Device
        </div><div class="tip admonition">
<p class="admonition-title">既然数据在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端都可以访问的内存中，为什么还需要拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端中？</p>
<p>在硬件层面 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端都可以访问的内存，这类内存对于 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 这种处理连续内存非常友好，而像 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 这种大量并行计算的设备来说就不尽人意了，拷贝至 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端中的目的是将这一步分数据转换成设备友好的内存结构，提高内存读写性能。</p>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中可以在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 设备上直接访问 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 都可访问的内存。只不过我们经常将这部分内存数据拷贝至 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 专属内存中提高性能。</p>
</div>
<p>最终可得出 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的内存分类：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端内存</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Host</span></code> 端与 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存</p></li>
</ul>
<div class="important admonition">
<p class="admonition-title">Vulkan 内存</p>
<p>其实在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 标准看来，所有的内存都属于 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存，只不过有些 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存可以被 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端访问。有些 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存为 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 专属内存。</p>
</div>
</section>
<section id="id17">
<h3>获取 Vulkan 支持的内存信息<a class="headerlink" href="#id17" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 所有的内存信息都可以通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数获取，其定义如下：</p>
<section id="vkgetphysicaldevicememoryproperties">
<h4>vkGetPhysicalDeviceMemoryProperties<a class="headerlink" href="#vkgetphysicaldevicememoryproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkGetPhysicalDeviceMemoryProperties</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkPhysicalDevice</span><span class="w">                           </span><span class="n">physicalDevice</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkPhysicalDeviceMemoryProperties</span><span class="o">*</span><span class="w">          </span><span class="n">pMemoryProperties</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">physicalDevice</span> 为对应获取对应内存信息的物理设备。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemoryProperties</span> 相应的内存信息将会写入并返回。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 为 <code class="docutils literal notranslate"><span class="pre">PhysicalDevice</span> <span class="pre">域函数</span></code> 。</p>
</div>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 结构体描述如下：</p>
</section>
<section id="vkphysicaldevicememoryproperties">
<h4>VkPhysicalDeviceMemoryProperties<a class="headerlink" href="#vkphysicaldevicememoryproperties" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define VK_MAX_MEMORY_TYPES 32U</span>
<span class="cp">#define VK_MAX_MEMORY_HEAPS 16U</span>

<span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                         </span><span class="n">memoryTypeCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryType</span><span class="w">                                     </span><span class="n">memoryTypes</span><span class="p">[</span><span class="n">VK_MAX_MEMORY_TYPES</span><span class="p">];</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                         </span><span class="n">memoryHeapCount</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryHeap</span><span class="w">                                     </span><span class="n">memoryHeaps</span><span class="p">[</span><span class="n">VK_MAX_MEMORY_HEAPS</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkPhysicalDeviceMemoryProperties</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypeCount</span> 内存类型的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypes</span> 对应的内存类型信息数据。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryHeapCount</span> 内存堆的数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryHeaps</span> 对应的内存堆的信息数据。</p></li>
</ul>
<p>对应的 <code class="docutils literal notranslate"><span class="pre">VkMemoryType</span></code> 结构体描述如下：</p>
</section>
<section id="vkmemorytype">
<h4>VkMemoryType<a class="headerlink" href="#vkmemorytype" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkMemoryPropertyFlags</span><span class="w">          </span><span class="n">propertyFlags</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                       </span><span class="n">heapIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">propertyFlags</span> 该类内存的属性信息，使用标志位存储相应信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">heapIndex</span> 对应的内存堆的索引，表示指向 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps[heapIndex]</span></code> 的内存堆。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlags</span></code> 对应的各个比特位的值定义于 <code class="docutils literal notranslate"><span class="pre">VkMemoryPropertyFlagBits</span></code> 枚举中，定义如下：</p>
</section>
<section id="vkmemorypropertyflagbits">
<h4>VkMemoryPropertyFlagBits<a class="headerlink" href="#vkmemorypropertyflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkMemoryPropertyFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">  </span><span class="n">VK_MEMORY_PROPERTY_PROTECTED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 物理设备自身的内存只有物理设备自身可访问，也就是 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端可访问到的内存只有 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端自身可访问， <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端不可访问。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端连续内存，表示对于该内存的读写可连续进行（就像 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 对于内存的修改那样）。该内存类型不需要手动进行 <code class="docutils literal notranslate"><span class="pre">刷新</span></code> 和 <code class="docutils literal notranslate"><span class="pre">失效</span></code> 操作。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</span> 表示这部分内存为 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端高速内存，并且自带 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span></code> 属性。这一部分内存大小相对较小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</span> 表示这部分内存为可以滞后分配内存，等要使用时再分配内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_PROPERTY_PROTECTED_BIT</span> 表示这部分内存为受保护内存，并且只允许 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 硬件设备和受保护的队列（ <code class="docutils literal notranslate"><span class="pre">VK_QUEUE_PROTECTED_BIT</span></code> ）可以访问该内存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">刷新</span></code> 和 <code class="docutils literal notranslate"><span class="pre">失效</span></code> 操作</p>
<p>是指使用 <code class="docutils literal notranslate"><span class="pre">vkFlushMappedMemoryRanges</span></code> 进行内存刷新，使用 <code class="docutils literal notranslate"><span class="pre">vkInvalidateMappedMemoryRanges</span></code> 使内存失效。有关详细说明将会在单独的章节中进行讲解。</p>
</div>
<p>我们经常会使用到 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span></code> 、 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span></code> 属性的内存。</p>
<p>接下来我们来看一下 <code class="docutils literal notranslate"><span class="pre">VkMemoryType::heapIndex</span></code> 对应的 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 的定义：</p>
</section>
<section id="vkmemoryheap">
<h4>VkMemoryHeap<a class="headerlink" href="#vkmemoryheap" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryHeap</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w">                   </span><span class="n">size</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkMemoryHeapFlags</span><span class="w">              </span><span class="n">flags</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryHeap</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 表示该内存堆的大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 表示该堆的属性标志位，各位的含义被定义在 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 中。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 与 <code class="docutils literal notranslate"><span class="pre">堆</span></code></p>
<p>一个 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeap</span></code> 对应这一个内存 <code class="docutils literal notranslate"><span class="pre">堆</span></code> 。 <code class="docutils literal notranslate"><span class="pre">堆</span></code> 就是用于存储数据的地方，一般对应着物理存储介质。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中内存是从堆上进行分配和管理的。</p>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkDeviceSize</span></code> 定义如下：</p>
</section>
<section id="vkdevicesize">
<h4>VkDeviceSize<a class="headerlink" href="#vkdevicesize" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">VkDeviceSize</span><span class="p">;</span>
</pre></div>
</div>
<p>从定义来看 <code class="docutils literal notranslate"><span class="pre">VkDeviceSize</span></code> 就是一个正整数。</p>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlags</span></code> 对应的各个比特位的值定义于 <code class="docutils literal notranslate"><span class="pre">VkMemoryHeapFlagBits</span></code> 枚举中，定义如下：</p>
</section>
<section id="vkmemoryheapflagbits">
<h4>VkMemoryHeapFlagBits<a class="headerlink" href="#vkmemoryheapflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkMemoryHeapFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">  </span><span class="c1">// 由 VK_VERSION_1_1 提供</span>
<span class="w">  </span><span class="n">VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span> 表示该内存堆为 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 专属内存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</span> 由于逻辑设备可以包含多个物理设备，此标志位表示该堆对应多个物理设备上的内存堆，对该堆的操作将会在每个物理设备的内存堆上进行相同的操作。</p></li>
</ul>
<p>常用的为 <code class="docutils literal notranslate"><span class="pre">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span></code> 标志位。</p>
</section>
<section id="id18">
<h4>VkPhysicalDeviceMemoryProperties 结构图<a class="headerlink" href="#id18" title="Link to this heading">#</a></h4>
<p>为了更清晰的理解 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> ，在此给出一张 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties</span></code> 结构参考图：</p>
<figure class="align-default" id="id28">
<img alt="_images/VkPhysicalDeviceMemoryProperties_struct.svg" src="_images/VkPhysicalDeviceMemoryProperties_struct.svg" /><figcaption>
<p><span class="caption-text">如图所示为一种可能的结构。第一种内存类型对应着第三个内存堆，第二种内存类型对应着第一个内存堆，第三种内存类型对应着第二个内存堆。</span><a class="headerlink" href="#id28" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>接下来就能够通过 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 获取内存信息了，和之前很多函数一样，首先获取 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 函数实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkInstance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的</span><span class="w"> </span><span class="n">VkInstance</span><span class="w"> </span><span class="p">;</span>

<span class="n">PFN_vkGetPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="n">vkGetPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkGetPhysicalDeviceMemoryProperties</span><span class="p">)</span><span class="n">vkGetInstanceProcAddr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkGetPhysicalDeviceMemoryProperties&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以通过调用 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceMemoryProperties</span></code> 获得内存相关信息了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">physical_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前获取到的物理设备句柄</span><span class="p">;</span>

<span class="n">VkPhysicalDeviceMemoryProperties</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="n">vkGetPhysicalDeviceMemoryProperties</span><span class="p">(</span><span class="n">physical_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">physical_device_memory_properties</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryTypeCount</span><span class="p">;</span><span class="w"> </span><span class="n">memory_type_index</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">VkMemoryType</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryTypes</span><span class="p">[</span><span class="n">memory_type_index</span><span class="p">];</span>

<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt DEVICE_LOCAL&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt HOST_VISIBLE&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_type</span><span class="p">.</span><span class="n">propertyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryPropertyFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Supprt HOST_COHERENT&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">heap_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_type</span><span class="p">.</span><span class="n">heapIndex</span><span class="p">;</span>

<span class="w">   </span><span class="n">VkMemoryHeap</span><span class="w"> </span><span class="n">memory_heap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">physical_device_memory_properties</span><span class="p">.</span><span class="n">memoryHeaps</span><span class="p">[</span><span class="n">heap_index</span><span class="p">];</span>

<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;heap &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">heap_index</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">memory_heap</span><span class="p">.</span><span class="n">size</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; GB&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">((</span><span class="n">memory_heap</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkMemoryHeapFlagBits</span><span class="o">::</span><span class="n">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s"> DEVICE_LOCAL&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id19">
<h3>内存管理<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 中分配内存使用 <code class="docutils literal notranslate"><span class="pre">malloc</span></code> 、 <code class="docutils literal notranslate"><span class="pre">new</span></code> ，回收内存使用 <code class="docutils literal notranslate"><span class="pre">free</span></code> 、 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 。而在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中分配内存使用 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 函数，回收内存使用 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 函数。</p>
<div class="note admonition">
<p class="admonition-title">const VkAllocationCallbacks* pAllocator</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 的内存回调在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中为特殊的内存管理，其本质应该算作 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 的内存管理。将会在单独的章节进行讲解。</p>
</div>
<div class="note admonition">
<p class="admonition-title">VkAllocationCallbacks 与 vk[Allocate/Free]Memory</p>
<p><code class="docutils literal notranslate"><span class="pre">VkAllocationCallbacks</span></code> 为 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code> 的内存管理范畴。 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 和 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 将会在 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps</span></code> 中的某一内存堆上进行内存管理（分配和回收）。</p>
</div>
<section id="id20">
<h4>分配内存<a class="headerlink" href="#id20" title="Link to this heading">#</a></h4>
<p>在某一个堆上进行内存分配，调用 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 函数，其定义如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkAllocateMemory</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkDevice</span><span class="w">                          </span><span class="n">device</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkMemoryAllocateInfo</span><span class="o">*</span><span class="w">       </span><span class="n">pAllocateInfo</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">      </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkDeviceMemory</span><span class="o">*</span><span class="w">                   </span><span class="n">pMemory</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。内存将会在该逻辑设备上进行分配。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocateInfo</span> 为内存分配的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pMemory</span> 为分配完的内存句柄。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo</span></code> 定义如下：</p>
<section id="vkmemoryallocateinfo">
<h5>VkMemoryAllocateInfo<a class="headerlink" href="#vkmemoryallocateinfo" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkMemoryAllocateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VkStructureType</span><span class="w">                         </span><span class="n">sType</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">                             </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">  </span><span class="n">VkDeviceSize</span><span class="w">                            </span><span class="n">allocationSize</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">                                </span><span class="n">memoryTypeIndex</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkMemoryAllocateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">allocationSize</span> 为要分配的内存大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memoryTypeIndex</span> 为在 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes</span></code> 数组对应的 <code class="docutils literal notranslate"><span class="pre">memoryTypeIndex</span></code> 索引处的堆上分配内存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">注意</p>
<p><code class="docutils literal notranslate"><span class="pre">VkMemoryAllocateInfo::memoryTypeIndex</span></code> 为 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes</span></code> 内存类型数组所对应的索引值，而 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">不是</span> <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryHeaps</span></code> 内存堆数组所对应的索引值。</p>
</div>
<p>这样我们就可以在支持 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 的设备上分配内存了。在正式分配内存前，首先获取 <code class="docutils literal notranslate"><span class="pre">vkAllocateMemory</span></code> 函数的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkAllocateMemory</span><span class="w"> </span><span class="n">vkAllocateMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkAllocateMemory</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkAllocateMemory&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>现在 <code class="docutils literal notranslate"><span class="pre">VkPhysicalDeviceMemoryProperties::memoryTypes[0]</span></code> 对应内存类型的堆上分配 <code class="docutils literal notranslate"><span class="pre">1KB</span></code> 内存（假如，对应的内存堆大小足够大）。示例代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">VkMemoryAllocateInfo</span><span class="w"> </span><span class="n">memory_allocate_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span><span class="p">;</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">allocationSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="c1">//1KB</span>
<span class="n">memory_allocate_info</span><span class="p">.</span><span class="n">memoryTypeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//在 VkPhysicalDeviceMemoryProperties::memoryTypes[0] 对应内存类型的堆上分配</span>

<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span><span class="w"> </span><span class="c1">// 分配的目标内存句柄</span>
<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkAllocateMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memory_allocate_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_memory</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
<section id="id21">
<h4>回收内存<a class="headerlink" href="#id21" title="Link to this heading">#</a></h4>
<p>内存成功分配完之后，可以通过 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 函数进行回收。其定义如下：</p>
<section id="vkfreememory">
<h5>vkFreeMemory<a class="headerlink" href="#vkfreememory" title="Link to this heading">#</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">vkFreeMemory</span><span class="p">(</span>
<span class="w">  </span><span class="n">VkDevice</span><span class="w">                             </span><span class="n">device</span><span class="p">,</span>
<span class="w">  </span><span class="n">VkDeviceMemory</span><span class="w">                       </span><span class="n">memory</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">         </span><span class="n">pAllocator</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">memory</span> 要回收的内存句柄。需要为 <code class="docutils literal notranslate"><span class="pre">device</span></code> 上分配的内存句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
</ul>
<p>这样我们就可以回收内存了。在正式回收内存前，首先获取 <code class="docutils literal notranslate"><span class="pre">vkFreeMemory</span></code> 函数的实现。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkFreeMemory</span><span class="w"> </span><span class="n">vkFreeMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkFreeMemory</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkFreeMemory&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以进行内存回收了，示例代码如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>
<span class="n">VkDeviceMemory</span><span class="w"> </span><span class="n">device_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功分配的内存句柄</span><span class="p">;</span>

<span class="n">vkFreeMemory</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">device_memory</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="id22">
<h2>资源<a class="headerlink" href="#id22" title="Link to this heading">#</a></h2>
<p>分配内存的目的是存储数据并用于计算，之后储存获得的结果。但在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中，并不能直接对内存进行操作，内存只能绑定到具体 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 上才能够使用。这是由于 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 的并行性，在并行处理多块特定结构的数据时能够得到更优效率，而 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 非常善于处理连续内存。为了能够使得用户分配的内存在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 上尽可能的高速处理， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 为用户提供了 <code class="docutils literal notranslate"><span class="pre">资源</span></code> 来为用户屏蔽掉复杂的 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 内存结构。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中为我们提供了 <code class="docutils literal notranslate"><span class="pre">2</span></code> 种资源：</p>
<ol class="arabic simple">
<li><p>缓存（ <code class="docutils literal notranslate"><span class="pre">Buffer</span></code> ）</p></li>
<li><p>图片（ <code class="docutils literal notranslate"><span class="pre">Image</span></code> ）</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">缓存</span></code> 资源和 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 资源都需要绑定一块特定内存才能够使用。对于 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 可以简单理解为其代表一块连续的内存（虽然在实际存储中内部的结构可能是非常复杂的），其内存可以存储任何数据。对于 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 可以简单理解为一个二维或三维的数组（也可以是一维的，但用的较少），其内部可以存储特定格式的数据（ <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 内部数据对格式没有要求，但 <code class="docutils literal notranslate"><span class="pre">图片</span></code> 有要求，其目的是高速并行）。</p>
<p>所以创建完内存后，下一步就是创建要绑定的资源。</p>
<section id="id23">
<h3>缓存<a class="headerlink" href="#id23" title="Link to this heading">#</a></h3>
<p>现在我们知道 <code class="docutils literal notranslate"><span class="pre">缓存</span></code> 代表一段连续的内存，其内部拥有自己的优化格式。不同用途的缓存，其内部的格式不尽相同，具体创建何种用途的缓存与开发需求有关，并在创建缓存时通过 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 指定相关信息。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中通过 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 函数创建缓存。</p>
<section id="vkcreatebuffer">
<h4>vkCreateBuffer<a class="headerlink" href="#vkcreatebuffer" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateBuffer</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkBufferCreateInfo</span><span class="o">*</span><span class="w">                   </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkBuffer</span><span class="o">*</span><span class="w">                                   </span><span class="n">pBuffer</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 创建缓存的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pBuffer</span> 创建的缓存结果。</p></li>
</ul>
<p>其中最重要的就是配置 <code class="docutils literal notranslate"><span class="pre">pCreateInfo</span></code> 信息。 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 定义如下：</p>
</section>
<section id="vkbuffercreateinfo">
<h4>VkBufferCreateInfo<a class="headerlink" href="#vkbuffercreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkBufferCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">        </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">            </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkBufferCreateFlags</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkDeviceSize</span><span class="w">           </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkBufferUsageFlags</span><span class="w">     </span><span class="n">usage</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkSharingMode</span><span class="w">          </span><span class="n">sharingMode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">               </span><span class="n">queueFamilyIndexCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">        </span><span class="n">pQueueFamilyIndices</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkBufferCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 缓存额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">size</span> 创建的缓存大小。单位为字节。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">usage</span> 缓存的用途。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sharingMode</span> 共享模式。用于配置缓存是否可在设备队列间进行共享。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndexCount</span> 对应 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyIndices</span></code> 的元素数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyIndices</span> 对应类型为 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的数组。用于配置需要互相共享访问该缓存的那些队列族索引。如果 <code class="docutils literal notranslate"><span class="pre">sharingMode</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">VK_SHARING_MODE_CONCURRENT</span></code> 的话，该项将被忽略。</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyIndices</span></code> 中的索引值对应于 <code class="docutils literal notranslate"><span class="pre">vkGetPhysicalDeviceQueueFamilyProperties</span></code> 函数中获取的 <code class="docutils literal notranslate"><span class="pre">VkQueueFamilyProperties</span></code> 数组索引。</p>
<p>其中最重要的就是对于 <code class="docutils literal notranslate"><span class="pre">usage</span></code> 的配置。 其为我们提供了缓存的各种用途。其定义如下：</p>
</section>
<section id="vkbufferusageflags">
<h4>VkBufferUsageFlags<a class="headerlink" href="#vkbufferusageflags" title="Link to this heading">#</a></h4>
<p>其中最常用的缓存用途如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkBufferUsageFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000080</span><span class="p">,</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span> 将该缓存作为数据传输的源。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span> 将该缓存作为数据传输的目标。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</span> 将该缓存作为统一缓存（用于向着色器中传递数据）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span> 将该缓存作为存储缓存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</span> 将该缓存作为索引缓存。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span> 将该缓存作为顶点缓存。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">其他 VK_BUFFER_USAGE_*_BUFFER_BIT</p>
<p>还有很多其他的缓存用途枚举，比如 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</span></code> 用于存储 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 硬件实时光追标准中的 <code class="docutils literal notranslate"><span class="pre">加速结构</span></code> 数据。其他缓存用途将在专门的章节进行讲解。</p>
</div>
<p>而 <code class="docutils literal notranslate"><span class="pre">VkSharingMode</span></code> 的类型枚举就比较简单：</p>
</section>
<section id="vksharingmode">
<h4>VkSharingMode<a class="headerlink" href="#vksharingmode" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkSharingMode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SHARING_MODE_CONCURRENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkSharingMode</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SHARING_MODE_EXCLUSIVE</span> 对于该缓存的访问一次只能在单独的一个队列族上进行。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SHARING_MODE_CONCURRENT</span> 对于该缓存的访问一次可以在多个队列族上进行。</p></li>
</ul>
<p>现在来尝试创建一个存有一个三角形的三个顶点信息的顶点缓存，并使用 <code class="docutils literal notranslate"><span class="pre">VK_SHARING_MODE_EXCLUSIVE</span></code> 模式。在创建前需要获取到 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 的函数实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkCreateBuffer</span><span class="w"> </span><span class="n">vkCreateBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateBuffer</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateBuffer&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateBuffer</span></code> 进行缓存创建了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备</span><span class="p">;</span>

<span class="c1">// 顶点位置</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Position</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 顶点颜色</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Color</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">g</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 位置和颜色</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PositionAndColor</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">Position</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">   </span><span class="n">Color</span><span class="w"> </span><span class="n">color</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 组建一个三角形</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PositionAndColor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position_and_colors</span><span class="p">;</span>
<span class="n">position_and_colors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">{{</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">}});</span>
<span class="n">position_and_colors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">{{</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">}});</span>
<span class="n">position_and_colors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">{{</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="p">}});</span>

<span class="n">VkBufferCreateInfo</span><span class="w"> </span><span class="n">buffer_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PositionAndColor</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">position_and_colors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">sharingMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkSharingMode</span><span class="o">::</span><span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">buffer_create_info</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">VkBuffer</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateBuffer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</p>
<p>在如上的代码示例中 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo::usage</span></code> 设置为：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer_create_info</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">VkBufferUsageFlagBits</span><span class="o">::</span><span class="n">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span> 表示该缓存将会作为数据传输的目标，用于之后的数据拷贝（具体如何将数据拷贝进该缓存将在之后的章节进行讲解）。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</span> 表示该缓存将会作为顶点缓存进行内存优化。</p></li>
</ul>
</div>
</section>
</section>
<section id="id24">
<h3>图片<a class="headerlink" href="#id24" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">图片</span></code> 为一维、二维或三维块内存结构的资源。每个内存块都有相同且特定的格式。与缓存不同的是，图片的内存块格式是强制要求明确指定的，与缓存相同的是图片创建时也需要指明其用途，当然这是为了内存的内部优化。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中图片资源使用 <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 句柄表示。</p>
<p>图片资源通过 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 函数创建。其定义如下：</p>
<section id="vkcreateimage">
<h4>vkCreateImage<a class="headerlink" href="#vkcreateimage" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="n">VkResult</span><span class="w"> </span><span class="nf">vkCreateImage</span><span class="p">(</span>
<span class="w">    </span><span class="n">VkDevice</span><span class="w">                                    </span><span class="n">device</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkImageCreateInfo</span><span class="o">*</span><span class="w">                    </span><span class="n">pCreateInfo</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VkAllocationCallbacks</span><span class="o">*</span><span class="w">                </span><span class="n">pAllocator</span><span class="p">,</span>
<span class="w">    </span><span class="n">VkImage</span><span class="o">*</span><span class="w">                                    </span><span class="n">pImage</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">device</span> 对应的 <code class="docutils literal notranslate"><span class="pre">VkDevice</span></code> 逻辑设备句柄。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pCreateInfo</span> 创建图片的配置信息。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pAllocator</span> 内存分配器。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pImage</span> 创建的图片结果。</p></li>
</ul>
<p>与创建缓存资源类似，我们来看一下 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span></code> 的配置信息定义：</p>
</section>
<section id="vkimagecreateinfo">
<h4>VkImageCreateInfo<a class="headerlink" href="#vkimagecreateinfo" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkImageCreateInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VkStructureType</span><span class="w">          </span><span class="n">sType</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w">              </span><span class="n">pNext</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageCreateFlags</span><span class="w">       </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageType</span><span class="w">              </span><span class="n">imageType</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkFormat</span><span class="w">                 </span><span class="n">format</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkExtent3D</span><span class="w">               </span><span class="n">extent</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">mipLevels</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">arrayLayers</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkSampleCountFlagBits</span><span class="w">    </span><span class="n">samples</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageTiling</span><span class="w">            </span><span class="n">tiling</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageUsageFlags</span><span class="w">        </span><span class="n">usage</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkSharingMode</span><span class="w">            </span><span class="n">sharingMode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">                 </span><span class="n">queueFamilyIndexCount</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w">          </span><span class="n">pQueueFamilyIndices</span><span class="p">;</span>
<span class="w">    </span><span class="n">VkImageLayout</span><span class="w">            </span><span class="n">initialLayout</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageCreateInfo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sType</span> 是该结构体的类型枚举值，必须是 <code class="docutils literal notranslate"><span class="pre">VkStructureType::VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pNext</span> 要么是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 要么指向其他结构体来扩展该结构体。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">flags</span> 图片额外标志位配置。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">imageType</span> 图片的类型。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">format</span> 图片格式。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">extent</span> 图片大小。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">mipLevels</span> 多级渐远纹理级别。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">arrayLayers</span> 层级数量。<span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 大于 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">samples</span> 采样点数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">tiling</span> 瓦片排布。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">usage</span> 图片的用途。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">sharingMode</span> 共享模式。用于配置缓存是否可在设备队列间进行共享。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">queueFamilyIndexCount</span> 对应 <code class="docutils literal notranslate"><span class="pre">pQueueFamilyIndices</span></code> 的元素数量。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">pQueueFamilyIndices</span> 对应类型为 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 的数组。用于配置需要互相共享访问该缓存的那些队列族索引。如果 <code class="docutils literal notranslate"><span class="pre">sharingMode</span></code> 不是 <code class="docutils literal notranslate"><span class="pre">VK_SHARING_MODE_CONCURRENT</span></code> 的话，该项将被忽略。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">initialLayout</span> 初始化布局</p></li>
</ul>
<p>其中 <code class="docutils literal notranslate"><span class="pre">imageType</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkImageType</span></code> 类型定义如下：</p>
</section>
<section id="vkimagetype">
<h4>VkImageType<a class="headerlink" href="#vkimagetype" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_IMAGE_TYPE_1D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_TYPE_2D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_IMAGE_TYPE_3D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageType</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TYPE_1D</span> 表示一维图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TYPE_2D</span> 表示二维图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TYPE_3D</span> 表示三维图片。</p></li>
</ul>
</section>
<section id="vkformat">
<h4>VkFormat<a class="headerlink" href="#vkformat" title="Link to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">VkFormat</span></code> 即代表着每个像素的数据格式。在 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中声明了大量的格式枚举，这里我们挑几个经典的进行讲解。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkFormat</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_FORMAT_B8G8R8A8_UNORM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">44</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkFormat</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_FORMAT_B8G8R8A8_UNORM</span> 表示有 <code class="docutils literal notranslate"><span class="pre">BGRA</span></code> 蓝、绿、红和透明四个分量，每个分量占 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特。 <code class="docutils literal notranslate"><span class="pre">UNORM</span></code> 表示无符号归一化（ <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">normalized</span></code> ），也就是颜色值的有限范围为 <span class="math notranslate nohighlight">\([0,1]\)</span> 。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_FORMAT_B8G8R8A8_SRGB</span> 表示有 <code class="docutils literal notranslate"><span class="pre">BGRA</span></code> 蓝、绿、红和透明四个分量，每个分量占 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特。 <code class="docutils literal notranslate"><span class="pre">SRGB</span></code> 表示使用 <code class="docutils literal notranslate"><span class="pre">sRGB</span></code> 标准红绿蓝协议（ <code class="docutils literal notranslate"><span class="pre">standard</span> <span class="pre">Red</span> <span class="pre">Green</span> <span class="pre">Blue</span></code> ） 。</p></li>
</ul>
<p>还有其他各种各样的格式，而最常用的也就是 <code class="docutils literal notranslate"><span class="pre">RGBA</span></code> 这样的红绿蓝和透明四个分量的组合格式。更多格式将会在单独章节进行讲解。</p>
<p>其中 <code class="docutils literal notranslate"><span class="pre">extent</span></code> 的 <code class="docutils literal notranslate"><span class="pre">VkExtent3D</span></code> 类型定义如下：</p>
</section>
<section id="vkextent3d">
<h4>VkExtent3D<a class="headerlink" href="#vkextent3d" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VkExtent3D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">depth</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkExtent3D</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">width</span> 表示宽。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">height</span> 表示高。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">depth</span> 表示深度。</p></li>
</ul>
<p>图片的 <code class="docutils literal notranslate"><span class="pre">extent</span></code> 大小和 <code class="docutils literal notranslate"><span class="pre">arrayLayers</span></code> 层级与其 <code class="docutils literal notranslate"><span class="pre">imageType</span></code> 图片类型有关：</p>
<ul class="simple">
<li><p>当图片为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TYPE_1D</span></code> 时 <code class="docutils literal notranslate"><span class="pre">extent.depth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">extent.height</span></code> 两者皆 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
<li><p>当图片为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TYPE_2D</span></code> 时 <code class="docutils literal notranslate"><span class="pre">extent.depth</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
<li><p>当图片为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TYPE_3D</span></code> 时 <code class="docutils literal notranslate"><span class="pre">arrayLayers</span></code> <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">VkSampleCountFlagBits</span></code> 其定义如下：</p>
</section>
<section id="vksamplecountflagbits">
<h4>VkSampleCountFlagBits<a class="headerlink" href="#vksamplecountflagbits" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkSampleCountFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_1_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_2_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_4_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_8_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_16_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_32_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="w">    </span><span class="n">VK_SAMPLE_COUNT_64_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkSampleCountFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_1_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">1</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_2_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">2</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_4_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">4</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_8_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">8</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_16_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">16</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_32_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">32</span></code> 个采样点。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_SAMPLE_COUNT_64_BIT</span> 图片的每个像素有 <code class="docutils literal notranslate"><span class="pre">64</span></code> 个采样点。</p></li>
</ul>
<p>该 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::samples</span></code> 是用于配置图片中的每一个像素由多少个子像素构成，这些子像素会在多采样阶段合并作为整个像素的结果。这在抗锯齿方面非常有用。</p>
<p><code class="docutils literal notranslate"><span class="pre">VkImageTiling</span></code> 其定义如下：</p>
</section>
<section id="vkimagetiling">
<h4>VkImageTiling<a class="headerlink" href="#vkimagetiling" title="Link to this heading">#</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageTiling</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VK_IMAGE_TILING_OPTIMAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">VK_IMAGE_TILING_LINEAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageTiling</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TILING_OPTIMAL</span> 图片的瓦片按照 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 本地优化方式排布。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_TILING_LINEAR</span> 图片的瓦片按照线性方式排布。</p></li>
</ul>
<p>资源在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端和在 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端，其内部的内存结构是不一样的，这个我们反复强调过。 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 为了得到更高的性能将图片的多个像素合成一个瓦片并使用内部的一种高效结构，这也就是 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TILING_OPTIMAL</span></code> 的目的，这种结构在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端是不能被识别的，一般处于 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的 <code class="docutils literal notranslate"><span class="pre">CPU</span></code> 擅长处理线性连续的资源数据，
所以想要在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端对 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端的资源进行读写，需要现将 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端的资源转成 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端能够识别的排布，这也就是 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_TILING_LINEAR</span></code> 的目的。</p>
</section>
<section id="vkimageusageflags">
<h4>VkImageUsageFlags<a class="headerlink" href="#vkimageusageflags" title="Link to this heading">#</a></h4>
<p>与缓存类似，为了更高的性能，您需要指定图片的用途， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中图片的用途如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 由 VK_VERSION_1_0 提供</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageUsageFlagBits</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_TRANSFER_SRC_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_SAMPLED_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000004</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_STORAGE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000008</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000010</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000020</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000040</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000080</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageUsageFlagBits</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_TRANSFER_SRC_BIT</span> 将该图片作为数据传输的源。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span> 将该图片作为数据传输的目标。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_SAMPLED_BIT</span> 将该图片作为可采样图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_STORAGE_BIT</span> 将该图片作为可存储图片。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span> 将该图片作为颜色附件。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span> 将该图片作为深度-模板附件。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</span> 将该图片作为暂存附件。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</span> 将该图片作为输入附件。</p></li>
</ul>
<p>在这里我们仅关注 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_SAMPLED_BIT</span></code> 。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code> 在渲染时，需要告诉 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 渲染到哪张图片上，此时作为渲染目标的图片需要使用 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code> 创建。其他的用途将会在单独章节中进行讲解。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_SAMPLED_BIT</span></code> 用于表示该图片将用于渲染时纹理采样。</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">VK_IMAGE_USAGE_TRANSFER_SRC_BIT 和 VK_IMAGE_USAGE_TRANSFER_DST_BIT</p>
<p>这两种用途与缓存的 <code class="docutils literal notranslate"><span class="pre">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_USAGE_TRANSFER_DST_BIT</span></code> 相似。都是用资源间数据传输的。</p>
</div>
</section>
<section id="vkimagelayout">
<h4>VkImageLayout<a class="headerlink" href="#vkimagelayout" title="Link to this heading">#</a></h4>
<p>为了进一步优化图片， <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中需要对图片进行布局设置，特定布局下的图片在特定用途下将会有更加优良的性能表现。 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中同样提供的大量的图片布局枚举供我们使用，在这里也挑几个经典的进行讲解。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Provided by VK_VERSION_1_0</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">VkImageLayout</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_UNDEFINED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_GENERAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="n">VK_IMAGE_LAYOUT_PREINITIALIZED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">VkImageLayout</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_UNDEFINED</span> 表示未定义布局。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_GENERAL</span> 表示通用布局。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span> 表示颜色附件布局。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VK_IMAGE_LAYOUT_PREINITIALIZED</span> 表示内存中已经存有特定布局的数据将用于图片。也就是图片已被提前初始化完成。该布局的目的是将 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端的数据写入图片中，并且目前该布局只能用于线性图片中（ <code class="docutils literal notranslate"><span class="pre">VkImageTiling::VK_IMAGE_TILING_LINEAR</span></code> ）。</p></li>
</ul>
<p>在通过 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo</span></code> 创建图片时 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 要求 <code class="docutils literal notranslate"><span class="pre">initialLayout</span></code> 的布局 <span class="sd-sphinx-override sd-badge sd-bg-danger sd-bg-text-danger">必须</span> 为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 或 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_PREINITIALIZED</span></code> 。但大多数情况下图片都没有预制的数据，所以在创建图片时 <code class="docutils literal notranslate"><span class="pre">initialLayout</span></code> 的布局一般都是 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 。</p>
<p>当图片内的布局为 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 时表示内部的数据布局是未定义的，这时 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 并不知道如何解析该图片，为了能让 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 识别出该资源，需要将布局从 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_UNDEFINED</span></code> 转换至其他布局。是的，布局可以转换。不同阶段转换成对应阶段的特定布局会得到更加高效的性能表现（比如在渲染结果输出阶段将图片的布局转换成 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span></code> ）。同样 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 也考虑到布局转来转去过于繁琐，所以
提供了 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_GENERAL</span></code> 通用布局，该布局是通用的，在任何阶段都可以使用，代价就是稍稍降低了一点点性能，但好处是不再需要管理图片的布局，而 <code class="docutils literal notranslate"><span class="pre">VK_IMAGE_LAYOUT_GENERAL</span></code> 布局也作为很多引擎的首选布局（因为真的很方便）。</p>
</section>
<section id="id25">
<h4>VkImageCreateInfo 其他参数和综述<a class="headerlink" href="#id25" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::mipLevels</span> 用于图片的多级渐远级别。对于多级渐远将会在专门的章节中讲解。</p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::arrayLayers</span> 用于配置图片的层级。一般在创建 <code class="docutils literal notranslate"><span class="pre">CubeMap</span></code> （天空盒）时与 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::flags</span></code> 配合使用。这一部分将会在专门的章节中讲解。</p></li>
</ul>
<p>而对于如下参数则与 <code class="docutils literal notranslate"><span class="pre">VkBufferCreateInfo</span></code> 中的概念相同。</p>
<ul class="simple">
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::sharingMode</span></p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::queueFamilyIndexCount</span></p></li>
<li><p><span class="sd-sphinx-override sd-badge sd-bg-secondary sd-bg-text-secondary">VkImageCreateInfo::pQueueFamilyIndices</span></p></li>
</ul>
<p>这些参数都是用于配置该资源在哪些队列中进行数据共享。</p>
<section id="id26">
<h5>综述<a class="headerlink" href="#id26" title="Link to this heading">#</a></h5>
<p>对于 <code class="docutils literal notranslate"><span class="pre">Vulkan</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">VkImage</span></code> 图片资源有如下特点：</p>
<ul class="simple">
<li><p>所有图片都是以三维图片进行表示的（一维、二维图片只是相应的扩展维度度量缩减到了 <code class="docutils literal notranslate"><span class="pre">1</span></code> ）。并使用 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::extent</span></code> 配置每个维度的像素数量。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::format</span></code> 用于表示图片的单个像素的数据格式。</p></li>
<li><p>每个像素中都有逻辑子像素，类似于将一个像素按照九宫格的方式进行分割，具体分成几宫格是使用 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::samples</span></code> 进行配置的。如果配置为 <code class="docutils literal notranslate"><span class="pre">VkImageUsageFlagBits::VK_SAMPLE_COUNT_1_BIT</span></code> 则表示当前像素即为最终像素。其它的配置都会将一个像素分割成多个小像素，并在渲染的多采样阶段将多个小像素的值合并，并做为最终像素值保存。</p></li>
<li><p>图片在 <code class="docutils literal notranslate"><span class="pre">Host</span></code> 端和 <code class="docutils literal notranslate"><span class="pre">Device</span></code> 端的排布不同。具体何种排布使用 <code class="docutils literal notranslate"><span class="pre">VkImageCreateInfo::tiling</span></code> 进行配置。</p></li>
<li><p>图片具有布局属性。通过特定阶段将图片转换成特定布局将会提升性能表现。</p></li>
</ul>
<p>现在来尝试创建一个图片，该图片具有如下特点：</p>
<ul class="simple">
<li><p>该图片为二维图片。<code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::imageType</span> <span class="pre">=</span> <span class="pre">VkImageType::VK_IMAGE_TYPE_2D</span></code></p></li>
<li><p>每个像素都有 <code class="docutils literal notranslate"><span class="pre">RGBA</span></code> 四个分量，每个分量 <code class="docutils literal notranslate"><span class="pre">8</span></code> 比特，并使用 <code class="docutils literal notranslate"><span class="pre">sRGB</span></code> 标准。<code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::format</span> <span class="pre">=</span> <span class="pre">VkFormat::VK_FORMAT_B8G8R8A8_SRGB</span></code></p></li>
<li><p>图片大小为 <span class="math notranslate nohighlight">\(1920 \times 1080\)</span> 。<code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::extent</span> <span class="pre">=</span> <span class="pre">VkExtent3D{width</span> <span class="pre">=</span> <span class="pre">1920,</span> <span class="pre">height</span> <span class="pre">=</span> <span class="pre">1080,</span> <span class="pre">depth</span> <span class="pre">=</span> <span class="pre">1}</span></code></p></li>
<li><p>该图片将在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 中作为颜色附件使用。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::usage</span> <span class="pre">=</span> <span class="pre">VkImageUsageFlagBits::VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span></code></p></li>
<li><p>没有多级渐远。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::mipLevels</span> <span class="pre">=</span> <span class="pre">1</span></code></p></li>
<li><p>没有子像素。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::samples</span> <span class="pre">=</span> <span class="pre">VkSampleCountFlagBits::VK_SAMPLE_COUNT_1_BIT</span></code></p></li>
<li><p>仅在 <code class="docutils literal notranslate"><span class="pre">GPU</span></code> 中访问。 <code class="code docutils literal notranslate"><span class="pre">VkImageCreateInfo::tiling</span> <span class="pre">=</span> <span class="pre">VkImageTiling::VK_IMAGE_TILING_OPTIMAL</span></code></p></li>
</ul>
<p>在调用 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 前首先获取该函数的驱动实现：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备句柄</span><span class="p">;</span>

<span class="n">PFN_vkCreateImage</span><span class="w"> </span><span class="n">vkCreateImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PFN_vkCreateImage</span><span class="p">)</span><span class="n">vkGetDeviceProcAddr</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vkCreateImage&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>之后就可以调用 <code class="docutils literal notranslate"><span class="pre">vkCreateImage</span></code> 创建图片了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VkDevice</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">之前成功创建的逻辑设备</span><span class="p">;</span>

<span class="n">VkExtent3D</span><span class="w"> </span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">extent</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1920</span><span class="p">;</span>
<span class="n">extent</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1080</span><span class="p">;</span>
<span class="n">extent</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="n">VkImageCreateInfo</span><span class="w">  </span><span class="n">image_create_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkStructureType</span><span class="o">::</span><span class="n">VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">imageType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageType</span><span class="o">::</span><span class="n">VK_IMAGE_TYPE_2D</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkFormat</span><span class="o">::</span><span class="n">VK_FORMAT_B8G8R8A8_SRGB</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extent</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">mipLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">arrayLayers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkSampleCountFlagBits</span><span class="o">::</span><span class="n">VK_SAMPLE_COUNT_1_BIT</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">tiling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageTiling</span><span class="o">::</span><span class="n">VK_IMAGE_TILING_OPTIMAL</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageUsageFlagBits</span><span class="o">::</span><span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">sharingMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkSharingMode</span><span class="o">::</span><span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">image_create_info</span><span class="p">.</span><span class="n">initialLayout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VkImageLayout</span><span class="o">::</span><span class="n">VK_IMAGE_LAYOUT_UNDEFINED</span><span class="w"> </span><span class="p">;</span>

<span class="n">VkImage</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_NULL_HANDLE</span><span class="p">;</span>

<span class="n">VkResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkCreateImage</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">image_create_info</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">image</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VkResult</span><span class="o">::</span><span class="n">VK_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="c1">//是否创建成功</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
<div class="related-pages">
    <a class="next-page" href="Literature/index.html">
        <div class="page-info">
            <div class="context">
                <span>Next</span>
            </div>
            <div class="title">文献</div>
        </div>
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
    </a>
    <a class="prev-page" href="EnvironmentalConfig.html">
        <svg class="furo-related-icon">
            <use href="#svg-arrow-right"></use>
        </svg>
        <div class="page-info">
            <div class="context">
                <span>Previous</span>
            </div>
            
            <div class="title">环境配置</div>
            
        </div>
    </a>
</div>
<div class="bottom-of-page">
    <div class="left-details">
        <div class="copyright">
            Copyright &#169; 2023, FuXii
        </div>
        Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
        
        <a href="https://github.com/pradyunsg/furo">Furo</a>
        
        <div>
             <span id="busuanzi_container_site_uv" style='display:none'>site view <span
                    id="busuanzi_value_site_uv"></span></span> 
        </div>
    </div>
    <div class="right-details">
        <div class="icons">
            <a class="muted-link " href="https://github.com/FuXiii/Essentials.of.Vulkan" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
            
        </div>
        <div class="left-details">
             <span id="busuanzi_container_page_pv" style='display:none'>page view <span
                    id="busuanzi_value_page_pv"></span></span> 
        </div>
    </div>
</div>

      </footer>
    </div>
    <aside class="toc-drawer">
      

<div class="toc-sticky toc-scroll" style="width: 500px;">
    <div class="toc-title-container" style="width: 500px;">
        <span class="toc-title" style="width: 500px;">
            On this page
        </span>
    </div>
    <div class="toc-tree-container" style="width: 500px;">
        <div class="toc-tree" style="width: 500px;">
            <ul>
<li><a class="reference internal" href="#">纵览</a><ul>
<li><a class="reference internal" href="#vulkan">Vulkan 能为我们做什么</a></li>
<li><a class="reference internal" href="#id3">Vulkan 的接口</a></li>
<li><a class="reference internal" href="#id4">获取 Vulkan 接口</a><ul>
<li><a class="reference internal" href="#id5">加载 Vulkan 动态库</a></li>
<li><a class="reference internal" href="#id6">Vulkan 函数分类</a></li>
<li><a class="reference internal" href="#vkgetinstanceprocaddr">vkGetInstanceProcAddr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vulkan-vkinstance">Vulkan 最初之物 VkInstance</a><ul>
<li><a class="reference internal" href="#vkinstance">创建 VkInstance</a><ul>
<li><a class="reference internal" href="#vkcreateinstance">vkCreateInstance</a></li>
<li><a class="reference internal" href="#vkinstancecreateinfo">VkInstanceCreateInfo</a></li>
<li><a class="reference internal" href="#vkapplicationinfo">VkApplicationInfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id7">获取支持的 Vulkan 版本</a><ul>
<li><a class="reference internal" href="#vkenumerateinstanceversion">vkEnumerateInstanceVersion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">获取物理硬件设备</a><ul>
<li><a class="reference internal" href="#vkenumeratephysicaldevices">vkEnumeratePhysicalDevices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">获取物理设备属性</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldeviceproperties">vkGetPhysicalDeviceProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldeviceproperties">VkPhysicalDeviceProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldevicetype">VkPhysicalDeviceType</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">设备队列</a><ul>
<li><a class="reference internal" href="#id11">获取设备队列（族）信息</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldevicequeuefamilyproperties">vkGetPhysicalDeviceQueueFamilyProperties</a></li>
<li><a class="reference internal" href="#vkqueuefamilyproperties">VkQueueFamilyProperties</a></li>
<li><a class="reference internal" href="#vkqueueflags">VkQueueFlags</a></li>
<li><a class="reference internal" href="#vkqueueflagbits">VkQueueFlagBits</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id12">逻辑设备</a><ul>
<li><a class="reference internal" href="#id13">创建逻辑设备</a><ul>
<li><a class="reference internal" href="#vkcreatedevice">vkCreateDevice</a></li>
<li><a class="reference internal" href="#vkdevicecreateinfo">VkDeviceCreateInfo</a></li>
<li><a class="reference internal" href="#vkdevicequeuecreateinfo">VkDeviceQueueCreateInfo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#device">获取 Device 域函数</a><ul>
<li><a class="reference internal" href="#vkgetdeviceprocaddr">vkGetDeviceProcAddr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">获取设备队列</a><ul>
<li><a class="reference internal" href="#vkgetdevicequeue">vkGetDeviceQueue</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">内存</a><ul>
<li><a class="reference internal" href="#id16">内存分类</a></li>
<li><a class="reference internal" href="#id17">获取 Vulkan 支持的内存信息</a><ul>
<li><a class="reference internal" href="#vkgetphysicaldevicememoryproperties">vkGetPhysicalDeviceMemoryProperties</a></li>
<li><a class="reference internal" href="#vkphysicaldevicememoryproperties">VkPhysicalDeviceMemoryProperties</a></li>
<li><a class="reference internal" href="#vkmemorytype">VkMemoryType</a></li>
<li><a class="reference internal" href="#vkmemorypropertyflagbits">VkMemoryPropertyFlagBits</a></li>
<li><a class="reference internal" href="#vkmemoryheap">VkMemoryHeap</a></li>
<li><a class="reference internal" href="#vkdevicesize">VkDeviceSize</a></li>
<li><a class="reference internal" href="#vkmemoryheapflagbits">VkMemoryHeapFlagBits</a></li>
<li><a class="reference internal" href="#id18">VkPhysicalDeviceMemoryProperties 结构图</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">内存管理</a><ul>
<li><a class="reference internal" href="#id20">分配内存</a><ul>
<li><a class="reference internal" href="#vkmemoryallocateinfo">VkMemoryAllocateInfo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id21">回收内存</a><ul>
<li><a class="reference internal" href="#vkfreememory">vkFreeMemory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id22">资源</a><ul>
<li><a class="reference internal" href="#id23">缓存</a><ul>
<li><a class="reference internal" href="#vkcreatebuffer">vkCreateBuffer</a></li>
<li><a class="reference internal" href="#vkbuffercreateinfo">VkBufferCreateInfo</a></li>
<li><a class="reference internal" href="#vkbufferusageflags">VkBufferUsageFlags</a></li>
<li><a class="reference internal" href="#vksharingmode">VkSharingMode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id24">图片</a><ul>
<li><a class="reference internal" href="#vkcreateimage">vkCreateImage</a></li>
<li><a class="reference internal" href="#vkimagecreateinfo">VkImageCreateInfo</a></li>
<li><a class="reference internal" href="#vkimagetype">VkImageType</a></li>
<li><a class="reference internal" href="#vkformat">VkFormat</a></li>
<li><a class="reference internal" href="#vkextent3d">VkExtent3D</a></li>
<li><a class="reference internal" href="#vksamplecountflagbits">VkSampleCountFlagBits</a></li>
<li><a class="reference internal" href="#vkimagetiling">VkImageTiling</a></li>
<li><a class="reference internal" href="#vkimageusageflags">VkImageUsageFlags</a></li>
<li><a class="reference internal" href="#vkimagelayout">VkImageLayout</a></li>
<li><a class="reference internal" href="#id25">VkImageCreateInfo 其他参数和综述</a><ul>
<li><a class="reference internal" href="#id26">综述</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
    </div>
</div>


    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=7d86a446"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/tabs.js?v=3ee01567"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/mermaid@10.2.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </body>
</html>